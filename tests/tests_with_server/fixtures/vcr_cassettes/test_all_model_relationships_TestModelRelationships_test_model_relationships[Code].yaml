interactions:
- request:
    body: '{"model": "Code", "id": 76858}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['30']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=ryG1ZmPAVWInPDRxMMiijd8WFRCc6dCZpI3EGLbG%2FiXbN%2Fzg88vQ7%2BczJuUut%2FvxYE6Rz%2Fq1amcQbjBt%2FKXJGg%3D%3D;
          _aquarium_NURSERY_production_session=NWhyM201MVd3UnlRNUVwUGNCekhZS0I2S21oeUg5dUlpdmM5NFpxd3V4MUNGayt1aG40RHVIOGgxeWE2eTAwTjh6VW5Gc3ZwN2xGNHM2YmdaNHFGQnpjeGV5cHhpd1hGRzY2RVZQME96M2xqaS9SVjFtOWk3VThXeEx2ZDlsdnZyLzR3a3o0UFVkdnNHSG5hZ3lyTnZRRGJFRC9PQTFTcjdUTC9sdnpnUWRVcDdYSU9CbmZqVzJtVWdzUFVxTTM5SjM4WFlmSndHbElNRkZVWjNBMVlKTmVPS1ZKdTRadmd2cUIxUlJZcDNTQStmOVgxdTZEZ3dhaXhnUTBVVEU1aFVxcEdoRDlNV0ZGYkZuL29aU1pIOHYrRGlkR0FROERyTUdXMUNQbVhkRWd3UzBCS3hBWjY1bUdFZGxsOTI2b3U2SzFmNTNQbHFWMk9saE1KWitGNDdKcXNPcnBQSDVVTS8wT2FiZVRBRE1CRS9IaE5EMFhQQkR0UFB3dzMwODQyRi9PVkpoSDBYbE0rTUVlQTlpalRHN3BVUE9WbTZoNCt5Q2hDOVVSdmcwYz0tLWJ0T0hWVjNYTWtMOUZUeHB0aWdMNGc9PQ%3D%3D--ff37e8cc5987848eb7bd17e698cd41d8fd37c97e;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":76858,"name":"protocol","content":"# Creator: Xavaar\r\n#
        Last updated: 7/1/2018\r\n\r\n# Title: Gel Lesson for SynBio4Beginners\r\n#
        Purpose: To walk students through the steps of Gel electrophoresis and teach
        them the purpose of each step.\r\n\r\nneeds \"SynBio4Beginners/General\"\r\n\r\nclass
        Protocol\r\n    \r\n    #ignore variables called ''nada'' they are imaginary\r\n\r\n    $debug
        = true #DO NOT TURN THIS OFF UNLESS YOU WANT INIFITNITE LOOPS, ONLY TURN On
        FOR THE DEPLOYED VERYSION!\r\n    $correctAnswers = true\r\n    \r\n    def
        main\r\n        \r\n\r\n        operations.retrieve.make\r\n        \r\n        \r\n        #
        Order of Operation -START\r\n        \r\n        # Student enters their name,
        actually unecesary but fun\r\n        studentName = introduce \r\n        \r\n        #
        Introduces the lesson and tells the student to grap their PCR product from
        the fridege\r\n        intro(studentName)\r\n        \r\n        # Tells student
        to get loading dye and mix it with PCR product\r\n        step1\r\n        \r\n        #
        Tells student to go learn how to load a gel with the TA\r\n        step2\r\n        \r\n        miniLecture1(studentName)\r\n        \r\n        quizA2
        = miniLecture2\r\n        \r\n        answer = miniLecture3 \r\n        \r\n        miniLecture4(answer)
        \r\n        \r\n        miniLecture5\r\n        \r\n        nada = miniLecture6\r\n        \r\n        nada
        = miniLecture7\r\n        \r\n        miniLecture8(studentName)\r\n        \r\n        gelReadPractice1\r\n        \r\n        gelReadPractice2\r\n        \r\n        #
        Cut out the gel \r\n        \r\n        #purify the gel and explain the process\r\n        \r\n        #
        Order of Operation -END-\r\n    \r\n        \r\n        operations.store\r\n        \r\n        return
        {}\r\n    \r\n    end\r\n    \r\n    def introduce\r\n       studentName =
        show do\r\n            title\"...\"\r\n            get \"text\", var: :a_studentName,
        label:\"Wait, what''s your name?\", default:\"Mark Cuban\"\r\n        end\r\n        \r\n        studentName
        = studentName[:a_studentName]\r\n        \r\n    return studentName\r\n    \r\n    end\r\n        \r\n        \r\n    def
        intro studentName\r\n        show do \r\n          title \"Week 2 - Intro:
        Gel Electrophoresis\"\r\n          note \"Ok #{studentName} Last week we amplified
        a specific section of DNA, a fragment, via PCR. That took about 3 hours, after
        it was done we put it in the fridge for you. Now your going to take the product
        of that reaction and first seperate the DNA that we want from all the other
        stuff and  also verify that fragment is same length as we expect it to be.
        We do both these things with a process called Gel Electrophoresis. First \r\n          go
        grab the PCR tube with your initial on it from the fridge.\"\r\n          check
        \"I got it.\"\r\n        end\r\n    end\r\n    \r\n    def step1\r\n        show
        do\r\n            title \"Week 2 - Step 1\" \r\n            note \"Great,
        put your PCR tube in a small tube holder and grab the 6x purple loading dye
        from the --place--\"\r\n            check \"Set the red pipet to 10 uL\"\r\n            check
        \"Pipet 10 uL of loading dye into the PCR tube\"\r\n            warning \"Mix
        the dye thoughouly with the PCR product by pipeting up and down to the first
        first stop\"\r\n            \r\n        end\r\n    end\r\n    \r\n    def
        step2\r\n        show do\r\n            title \"Week 2 - Step 2\"\r\n            note\"Next
        your going to load the PCR product into a gel. The dye is added just so you
        can see the liquid while your loading it, that''s why its called loading dye.
        Your TA will demonstrate how to load the gel by adding a ladder to the first
        lane. Now go find your TA and don''t worry I''ll explain what a ladder is
        in a minute.\"\r\n            note \"Load lane X ( how to automate this?)\"\r\n            check
        \"I''m back, I loaded the gel\"\r\n        end\r\n    end\r\n    \r\n    def
        miniLecture1(studentName)\r\n     \r\n        n = 0\r\n        while n \u003c
        5\r\n             \r\n            quizA1 = show do \r\n                title
        \"Minilecture\"\r\n                note \"Alright #{studentName} the gel has
        to run for about half an hour so we have time talk about what that really
        means. \r\n                First lets review what you know about PCR...\"\r\n                select
        [\"Agarose\",\"DNA\",\"RNA\",\"Ligase\",\"dNTPs\",\"dextrose\",\"DNA polymerase\",\"RNA
        polymerase\",\"inducers\",\"tris-EDTA\",\"helicase\",\"DMSO\",\"primers\",\"promoters\"],
        var: \"a_miniLec1A1\" , label: \"Select the 4 things you need in order to
        run a PCR\" , default: 1\r\n                select [\"Agarose\",\"DNA\",\"RNA\",\"Ligase\",\"dNTPs\",\"dextrose\",\"DNA
        polymerase\",\"RNA polymerase\",\"inducers\",\"tris-EDTA\",\"helicase\",\"DMSO\",\"primers\",\"promoters\"],
        var: \"a_miniLec1A2\", label: \"\" , default: nil\r\n                select
        [\"Agarose\",\"DNA\",\"RNA\",\"Ligase\",\"dNTPs\",\"dextrose\",\"DNA polymerase\",\"RNA
        polymerase\",\"inducers\",\"tris-EDTA\",\"helicase\",\"DMSO\",\"primers\",\"promoters\"],
        var: \"a_miniLec1A3\", label: \"\", default: nil\r\n                select
        [\"Agarose\",\"DNA\",\"RNA\",\"Ligase\",\"dNTPs\",\"dextrose\",\"DNA polymerase\",\"RNA
        polymerase\",\"inducers\",\"tris-EDTA\",\"helicase\",\"DMSO\",\"primers\",\"promoters\"],
        var: \"a_miniLec1A4\", label: \"\", default: nil\r\n            end\r\n            \r\n             #
        These two lines make a new array (list) of the answers from the Quiz.\r\n            quizA1_answers=[]\r\n            quizA1_answers.push(quizA1[:a_miniLec1A1],quizA1[:a_miniLec1A2],
        quizA1[:a_miniLec1A3], quizA1[:a_miniLec1A4])\r\n            \r\n            if
        $correctAnswers == true\r\n                quizA1_answers=[\"DNA\",\"dNTPs\",\"DNA
        polymerase\",\"primers\"]\r\n            end\r\n            \r\n            #This
        next line checks if the answers include the following four. Order should not
        matter. \r\n            if quizA1_answers.include?(\"DNA\" \u0026\u0026 \"dNTPs\"
        \u0026\u0026 \"DNA polymerase\" \u0026\u0026 \"primers\") \r\n                \r\n                show
        do \r\n                    note \"Well done! You got it.\"\r\n                end\r\n                \r\n                break\r\n            end\r\n            \r\n            show
        do\r\n                    title\"Try again\"\r\n                    note \"mmm...that
        wasn''t the correct combination of reagents\"\r\n            end\r\n                \r\n            n
        = n + 1\r\n        end\r\n        \r\n        if n == 5\r\n            show
        do\r\n                note \"Please ask your TA for clarification before going
        to the next step\"\r\n                check \"I get it now\"\r\n            end\r\n        end\r\n    end\r\n    \r\n    def
        miniLecture2\r\n        \r\n        n = 0\r\n        while n \u003c 5\r\n        \r\n           quizA2
        = show do\r\n                title \"Minilecture\"\r\n                note
        \"Cool, you know what reagents go into a PCR now tell me what each one does...\"\r\n                select
        [\"DNA\",\"dNTPs\",\"DNA polymerase\",\"primers\"], var: :a_miniLec2A1, label:
        \"This is what we''re are trying to make more copies of\", default: nil\r\n                select
        [\"DNA\",\"dNTPs\",\"DNA polymerase\",\"primers\"], var: :a_miniLec2A2, label:
        \"This is what those copies are built out (aka. building blocks) of\", default:
        nil\r\n                select [\"DNA\",\"dNTPs\",\"DNA polymerase\",\"primers\"],
        var: :a_miniLec2A3, label: \"This is what builds those copies\", default:
        nil\r\n                select [\"DNA\",\"dNTPs\",\"DNA polymerase\",\"primers\"],
        var: :a_miniLec2A4, label: \"This is what guides the things that builds the
        copies\", default: nil\r\n            end\r\n            \r\n            ##
        These two lines make a new array (list) of the answers from the Quiz.\r\n            quizA2_answers=[]\r\n            quizA2_answers.push(quizA2[:a_miniLec2A1],quizA2[:a_miniLec2A2],
        quizA2[:a_miniLec2A3], quizA2[:a_miniLec2A4])\r\n            \r\n            if
        $correctAnswers == true\r\n                quizA2_answers = [\"DNA\",\"dNTPs\",\"DNA
        polymerase\",\"primers\"]\r\n            end\r\n            \r\n            #
        This checks that each key equals the correct answer to its question\r\n            if
        quizA2_answers == [\"DNA\",\"dNTPs\",\"DNA polymerase\",\"primers\"]\r\n               \r\n                show
        do\r\n                  note \"Well done! You got it.\"\r\n                end\r\n                \r\n                break\r\n                \r\n            end\r\n            \r\n            show
        do\r\n             title\"Try again\"\r\n             note \"mmm...that wasn''t
        the correct combination of reagents\"\r\n            end\r\n                \r\n            n
        = n + 1\r\n        end\r\n        \r\n        if n == 5\r\n            show
        do\r\n                note \"Please ask your TA for clarification before going
        to the next step\"\r\n                check \"I get it now\"\r\n            end\r\n        end\r\n        \r\n    end\r\n    \r\n    def
        miniLecture3\r\n        \r\n        answer = nil\r\n        while true\r\n           answer
        = show do\r\n                title \"Minilecture\"\r\n                note
        \"Yep you got it. Here''s a question though... \"\r\n                select
        [\"Yeah\", \"No\", \"...Maybe\"], var: :a_miniLec3A1, label: \"Do you think
        perfect copies of that section of DNA we wanted are the only things left at
        the end of the reaction?\", default: 3 \r\n            end\r\n            \r\n            if
        $correctAnswers == true\r\n                answer[:a_miniLec3A1] = \"...Maybe\"\r\n            end\r\n            \r\n                answer
        = answer[:a_miniLec3A1]\r\n        \r\n            if answer == nil #ask andrew
        why nil doesn''t work here\r\n                show do\r\n                    note
        \"Please enter an answer\"\r\n                end\r\n            end\r\n            \r\n            if
        $debug == true\r\n                break\r\n            end\r\n            \r\n        end\r\n        \r\n        return
        answer\r\n        \r\n    end\r\n    \r\n    def miniLecture4(answer)\r\n        \r\n        if
        answer == \"Yeah\"\r\n            show do \r\n                title \"Minilecture\"\r\n                note
        \"Not quite but I like your confidence. There''s actually some other stuff
        in there too. First theres the original DNA that we started with, then theres
        a bunch of left over primers, and finally since primers may not have bound
        correctly or missed there targets we might have ended up with other random
        bits of DNA in there too.  To seperate the one piece of DNA we want from all
        the other stuff or just make sure the PCR worked at al we use Gel Electrophoresis\"\r\n            end\r\n        end\r\n        \r\n        if
        answer == \"No\"\r\n            show do \r\n                title \"Minilecture\"\r\n                note
        \"That''s right. There''s actually some other stuff in there too. First theres
        the original DNA that we started with, then theres a bunch of left over primers,
        and finally since primers may not have bound correctly or missed there targets
        we might have ended up with other random bits of DNA in there too.  To seperate
        the one piece of DNA we want from all the other stuff or just make sure the
        PCR worked at al we use Gel Electrophoresis\"\r\n            end\r\n        end\r\n    \r\n        if
        answer == \"...Maybe\"\r\n             show do \r\n                title \"Minilecture\"\r\n                note
        \"True wisdom is knowing what you don''t know said Confucius\"\r\n                note
        \"There''s actually some other stuff in there too. First theres the original
        DNA that we started with, then theres a bunch of left over primers, and finally
        since primers may not have bound correctly or missed there targets we might
        have ended up with other random bits of DNA in there too.  To seperate the
        one piece of DNA we want from all the other stuff or just make sure the PCR
        worked at al we use Gel Electrophoresis\"\r\n             end\r\n        end\r\n\r\n         if
        answer == nil\r\n             show do\r\n                 note \"debug\"\r\n             end\r\n        end\r\n    end\r\n    \r\n    def
        miniLecture5\r\n        show do\r\n            title \"Minilecture - How does
        Gel Electrophoresis work?\"\r\n            note \"You just loaded the product
        of your PCR into a well on a gel. Then you began to run current through it.  It
        was very important to make sure that the wells were on the side of the box
        with the black electrode this is because DNA is a negatively charged molecule
        and it will be attracted through the gel to the positively charged red electrode.
        . Shorter, lighter, molecules of DNA will move more quickly through the gel
        than larger ones. Therefore if we run electricity through the gel for a set
        amount of time DNA will seperate itself by length. Also we put the gel in
        backwards the DNA would just run out the back of the gel straight to the red
        electrode\"\r\n            note\"put an image here\"\r\n        end\r\n    end\r\n    \r\n    def
        miniLecture6\r\n        nada = show do\r\n            title\"Minilecture\"\r\n            note\"put
        an image of a gel here\"\r\n            note\"Here is an example what a gel
        looks like as you can see there are bands which each correspond to a different
        length of DNA and glow under a blacklight...\"\r\n            select [\"Well
        kind of, its just I didn''t realize that DNA glows green under a black light....why
        don''t I glow green?\"], var: :nada, label: \"What''s that I see you have
        a question?\", default: nil\r\n        end\r\n    end\r\n\r\n    def miniLecture7\r\n        nada
        = show do\r\n            title \"Minilecture\"\r\n            note \"Very
        astute. You do not glow green because DNA does not glow green. When we made
        the gel ee added a flourescent dye which binds to DNA, if we didn''t do this
        the DNA would still seperate in to bands but we would have no idea where they
        are because we could see them. There are several types of dyes used by different
        labs but generally they are all at least somewhat toxic because y''know they
        bind to DNA. \"\r\n            warning \"This means you should always where
        gloves if you are working with gels\"\r\n            select [\"Ok cool, but
        I still don''t understand how we actually know how long the pieces of DNA
        in these bands are because theres nothing to compare them to. All we can say
        is that some are shorter and some are longer\"], var: :nada, label: \"Oh?
        you have another question?\", default: nil\r\n        end\r\n    end\r\n    \r\n    def
        miniLecture8(studentName)\r\n        show do\r\n            title \"Minilecture\"\r\n            note
        \"Great question #{studentName}! Thats why we use the ladder. They ladder
        is a mixture of many fragments of DNA of known lenth.\"\r\n            note
        \"Show an image here which explains how we always know that for example the
        third band is 1500 bp or whatever on a 10 kb ladder\"\r\n            note
        \"See how it kinda looks like a ladder once its been run...thats why its called
        a ladder...\"\r\n            note \"Ready for some practice reading gels?\"\r\n            check
        \"yup\"\r\n        end\r\n    end\r\n    \r\n    def gelReadPractice1\r\n        while
        true\r\n            gelRP1answers = show do\r\n                title \"Practice
        Reading Gels\"\r\n                note \"put image of a gel ladder key her\"\r\n                note
        \"put image of a gel next to the other image (make sure the ladder corresponds
        to the key) *Three bands are circled in        different colors*\"\r\n                note
        \"Tell me the length of these bands.\"\r\n                \r\n                #
        The ABC thing is for reasons inquire in person...\r\n                select
        [\"A\",\"B\",\"C\"], var: :a_gelRP1A1, label: \"The band circled in Red is
        A , B , or C\", default: nil #B is correct\r\n                select [\"A\",\"B\",\"C\"],
        var: :a_gelRP1A2, label: \"The band circled in Blue is A, B, or C\", default:
        nil  #B is correct\r\n                select [\"A\",\"B\",\"C\"], var: :a_gelRP1A3,
        label: \"The band circled in Yellow is A, B, or C\", default: nil #C is correct\r\n            end\r\n            \r\n            gelRP1answers
        = gelRP1answers[:a_gelRP1A1],gelRP1answers[:a_gelRP1A2],gelRP1answers[:a_gelRP1A3]\r\n            \r\n            if
        $correctAnswers == true\r\n                gelRP1answers = \"B\" \"B\" \"C\"\r\n            end\r\n            \r\n            if
        gelRP1answers == \"B\" \"B\" \"C\"\r\n                show do\r\n                    note
        \"That''s Right!\"\r\n                end\r\n                \r\n                break\r\n                \r\n            else\r\n                show
        do\r\n                    note \"That''s not correct, try again\"\r\n                end\r\n            end\r\n            \r\n            if
        $debug ==true\r\n                break\r\n            end\r\n        end\r\n    end\r\n        \r\n        #
        This stuff was because we were trying not to do the ABC thing, if Andrew bothers
        someone about the source code we may get a better solution\r\n        # AHu,
        testing here\r\n        # show do\r\n        #     note(\"choices: #{gelRP1answers[:choices]}\")\r\n        #
        end\r\n        \r\n        # gelRP1answers = [gelRP1answers[:a_gelRP1A1],gelRP1answers[:a_gelRP1A2],gelRP1answers[:a_gelRP1A3]]\r\n    \r\n    def
        gelReadPractice2\r\n        while true\r\n            gelRP2answers = show
        do\r\n                title \"Practice Reading Gels again\"\r\n                note
        \"put image of a gel ladder key her\"\r\n                note \"put image
        of a gel next to the other image (make sure the ladder corresponds to the
        key) *Three bands are circled in different colors, this time the bands should
        not directly align with the ladder bands but instead be imbetween*\"\r\n                note
        \"Now, tell me the length of these bands. Tts a tiny bit trickier this time...\"\r\n                \r\n                #
        The ABC thing is for reasons inquire in person...\r\n                select
        [\"A\",\"B\",\"C\"], var: :a_gelRP2A1, label: \"The band circled in Red is
        A , B , or C\", default: nil #A is correct\r\n                select [\"A\",\"B\",\"C\"],
        var: :a_gelRP2A2, label: \"The band circled in Blue is A, B, or C\", default:
        nil  #C is correct\r\n                select [\"A\",\"B\",\"C\"], var: :a_gelRP2A3,
        label: \"The band circled in Yellow is A, B, or C\", default: nil #B is correct\r\n            end\r\n            \r\n            gelRP2answers
        = gelRP2answers[:a_gelRP2A1],gelRP2answers[:a_gelRP2A2],gelRP2answers[:a_gelRP2A3]\r\n            \r\n            if
        $correctAnswers == true\r\n                gelRP2answers = \"A\" \"C\" \"B\"\r\n            end\r\n            \r\n            if
        gelRP2answers == \"A\" \"C\" \"B\"\r\n                show do\r\n                    note
        \"That''s Right!\"\r\n                end\r\n                \r\n                break\r\n                \r\n            else\r\n                show
        do\r\n                    note \"That''s not correct, try again\"\r\n                end\r\n            end\r\n            \r\n            if
        $debug ==true\r\n                break\r\n            end\r\n        end\r\n    end\r\n\r\n    def
        afterGelPractice\r\n        show do\r\n            title \"Next Steps\"\r\n            note
        \"It seems like you understand how gels read gels. Now that you''ve isolated
        the strand of DNA you want using gel electrophoresis lets get it back out
        of the gel. \"\r\n        end\r\n    end\r\n    \r\n    def cut gel\r\n         show
        do\r\n             title \"Cutting the Gel\"\r\n             note \r\n        end\r\n    end\r\n\r\n\r\n    \r\n    \r\nend","parent_id":1341,"parent_class":"OperationType","created_at":"2018-07-02T16:59:21.000-07:00","updated_at":"2018-07-02T16:59:21.000-07:00","user_id":211}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 03:54:55 GMT']
      ETag: [W/"04a4b19e3811fa274c4b7c208c2372e2"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=UutxCEZR4s8tO9VsDHQRrxA9Q6oGcGtBXKzDs5vfoAIm%2FTiO1lpnQu00x%2FgSC0jTr2XHdWAs0b%2FoTzfG0byXPQ%3D%3D;
          path=/, _aquarium_NURSERY_production_session=djBOWDJWMTNZZHFhK1cwamZyblVtSUJpMmt2QTZEbWV3NXowNkE3TmJsdUpINGZoZWtNYiswQmJrR053MXFmSXp1Z2kwK0tLeTNweS91d3p6UkdzTTIrTUhsZjY2ck9uQU1nOUVpTW41eGdoOFMzTlExYTB1bzhyTXI5U1ArVTd2RWxUYmpDQ05HWWNISzdUQkRyOFFWSGNWRnVub1pldFFHQ0ZKRm50Sk5sY29tKzFjbzRGVmZmdWxJVnRCeVEvSkdvbmJvUEs3NU5sd0pzckZLRWs0UHpVVitvak5SNnN4ckRlendOWXZlMS9zSzRORlV6Vm1lWnljSVNYb1lLbXRGcHJROU5Pek1DUERmR2xEeVdpUDN1b21xM1hxeVlKcDU5N2tmT3BiTDkzeGlLaE5xTXp2aENDN1BVTnkwSGRmMXFQVEtYV3FEVVE1NGNjUExFdmhGUlFyL2FYOTRvNlVXWE9ZZzBwQm5PVEFHblZDYjVyM3pZUFNpRng2TmxQeXQzRkNYWFcrdjUwTkgrMDhvZHlmcXJUNGNra3JPcmZBaGdJd0REaEYybz0tLXYvN3Q4Qm5hOSs2Ri9EV3JEK1U2Ync9PQ%3D%3D--6a9497bd27fa992c118f6dbcd93638c2f8e63d1d;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [91ea3be8-0642-490e-ad61-7037c327c6ae]
      X-Runtime: ['0.005543']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "User", "id": 211}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['28']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=ryG1ZmPAVWInPDRxMMiijd8WFRCc6dCZpI3EGLbG%2FiXbN%2Fzg88vQ7%2BczJuUut%2FvxYE6Rz%2Fq1amcQbjBt%2FKXJGg%3D%3D;
          _aquarium_NURSERY_production_session=NWhyM201MVd3UnlRNUVwUGNCekhZS0I2S21oeUg5dUlpdmM5NFpxd3V4MUNGayt1aG40RHVIOGgxeWE2eTAwTjh6VW5Gc3ZwN2xGNHM2YmdaNHFGQnpjeGV5cHhpd1hGRzY2RVZQME96M2xqaS9SVjFtOWk3VThXeEx2ZDlsdnZyLzR3a3o0UFVkdnNHSG5hZ3lyTnZRRGJFRC9PQTFTcjdUTC9sdnpnUWRVcDdYSU9CbmZqVzJtVWdzUFVxTTM5SjM4WFlmSndHbElNRkZVWjNBMVlKTmVPS1ZKdTRadmd2cUIxUlJZcDNTQStmOVgxdTZEZ3dhaXhnUTBVVEU1aFVxcEdoRDlNV0ZGYkZuL29aU1pIOHYrRGlkR0FROERyTUdXMUNQbVhkRWd3UzBCS3hBWjY1bUdFZGxsOTI2b3U2SzFmNTNQbHFWMk9saE1KWitGNDdKcXNPcnBQSDVVTS8wT2FiZVRBRE1CRS9IaE5EMFhQQkR0UFB3dzMwODQyRi9PVkpoSDBYbE0rTUVlQTlpalRHN3BVUE9WbTZoNCt5Q2hDOVVSdmcwYz0tLWJ0T0hWVjNYTWtMOUZUeHB0aWdMNGc9PQ%3D%3D--ff37e8cc5987848eb7bd17e698cd41d8fd37c97e;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":211,"name":"Xavaar","login":"xavaarq","created_at":"2018-06-20T10:48:13.000-07:00","updated_at":"2018-06-20T10:48:13.000-07:00","password_digest":"$2a$10$W.GOWpPFPKanb9rfG490pOluGQMn6s9LpV13v08yXK3kV0xoOu0P6","remember_token":"tXC0hkM8n7_kHszYJ9itNA","admin":false,"key":null,"groups":[{"id":236,"name":"xavaarq","description":"A
        group containing only user Xavaar","created_at":"2018-06-20T10:48:13.000-07:00","updated_at":"2018-06-20T10:48:13.000-07:00"},{"id":1,"name":"admin","description":"These
        users can use administrative functions (make users, etc)","created_at":"2013-11-15T13:37:36.000-08:00","updated_at":"2013-11-15T13:37:36.000-08:00"}]}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 03:54:55 GMT']
      ETag: [W/"344959b2c49f900a046c8beee33974bc"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=7VJlr1PVWqJDDr7C%2FaFpoCt6xR4Bh%2Bp7HFbmKllw%2BhGZRCwpw97fL4MBrFbj3jDclCJBwWfbUIWotRJfExPNLg%3D%3D;
          path=/, _aquarium_NURSERY_production_session=eDRQeWx0cUxWRE5oQzk1dWFOQWNjK2tmQWphT0xLYTYxbldjakhvc2R1Q2RXTHZScEhvUmFHWjg5eHkzN0t3ZWhpdmhwWUx3eG4xYXg0cXdQMG9lVkk4NWhjMWdFMHBFbTREV3VySk54Rm15NStFdi9kTEZ4WEd0SjV1K2JmRDVxTmVOcFFtUmlyUkt2RTUzUk0wRVB0dWJvamNBVi9ZSWpUdzh4ci9BZUl3VDFmMTdTUUJEeEZkTlFXOFVzMVJFYXQwNWRYNHBzdFNuQkpUQlZlNk5TdHBlZGYwUTBDamZBMWRYa0NrTk1JekFtSjdaNkZhN2krWTZZeDV5YmxLaFVMNGFOS05ST2QrSVV6dW40UjR2TDd4bkFDbTBOV1VJenVSUE9XMXpEUFQ5MnBJTFYvWkRTRE1jSDErUnpvUEFCSzIrVDdiWnlCUGY1WHpldWxsd2NKVWtuQ2FYVE5Bb05uTXI4cS9aL29Zd0JkeVJNM0NkV1U5TUMwYldyKy9YcUFTRTZyTWRmeTFHRGdtb21qajdSK3JNcmV3cm4rK0x2dW5OM2l5c0RrWT0tLWh3UGR6cVZKRmFXQVhTMFVQRHhKMmc9PQ%3D%3D--247e1481c30e21e843dd6a8aaefeb0e820abb971;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [a8ef8352-fd3e-4e51-aa19-1c59742f0484]
      X-Runtime: ['0.007144']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "OperationType", "id": 1341}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['38']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=ryG1ZmPAVWInPDRxMMiijd8WFRCc6dCZpI3EGLbG%2FiXbN%2Fzg88vQ7%2BczJuUut%2FvxYE6Rz%2Fq1amcQbjBt%2FKXJGg%3D%3D;
          _aquarium_NURSERY_production_session=NWhyM201MVd3UnlRNUVwUGNCekhZS0I2S21oeUg5dUlpdmM5NFpxd3V4MUNGayt1aG40RHVIOGgxeWE2eTAwTjh6VW5Gc3ZwN2xGNHM2YmdaNHFGQnpjeGV5cHhpd1hGRzY2RVZQME96M2xqaS9SVjFtOWk3VThXeEx2ZDlsdnZyLzR3a3o0UFVkdnNHSG5hZ3lyTnZRRGJFRC9PQTFTcjdUTC9sdnpnUWRVcDdYSU9CbmZqVzJtVWdzUFVxTTM5SjM4WFlmSndHbElNRkZVWjNBMVlKTmVPS1ZKdTRadmd2cUIxUlJZcDNTQStmOVgxdTZEZ3dhaXhnUTBVVEU1aFVxcEdoRDlNV0ZGYkZuL29aU1pIOHYrRGlkR0FROERyTUdXMUNQbVhkRWd3UzBCS3hBWjY1bUdFZGxsOTI2b3U2SzFmNTNQbHFWMk9saE1KWitGNDdKcXNPcnBQSDVVTS8wT2FiZVRBRE1CRS9IaE5EMFhQQkR0UFB3dzMwODQyRi9PVkpoSDBYbE0rTUVlQTlpalRHN3BVUE9WbTZoNCt5Q2hDOVVSdmcwYz0tLWJ0T0hWVjNYTWtMOUZUeHB0aWdMNGc9PQ%3D%3D--ff37e8cc5987848eb7bd17e698cd41d8fd37c97e;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":1341,"name":"Xavaar - Gel Lesson","category":"SynBio4Beginners","deployed":true,"on_the_fly":null,"created_at":"2018-06-27T14:20:33.000-07:00","updated_at":"2018-06-30T21:59:13.000-07:00"}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 03:54:55 GMT']
      ETag: [W/"2f12332c270010f6b4f6ecdac97226b0"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=sQqTzG92NWJ5pQ1%2FlhnsKmTfDdiB3XMp2%2FDXc0UGAgbFHNpK%2F32w77mqH%2BuIZrVW24eJB%2BeByddvEyMGD2U1OQ%3D%3D;
          path=/, _aquarium_NURSERY_production_session=YXVOeHJkTWl3b3luZ0Y4NjNFTWp5NnJSUjd1U0pQUkdnNUpTMzNENURRaCtDWktCQ0F4bFVncUZwUU5HSFBrOW95b3BWZXBMSzdYQ1RnbzVkTUNOeGRsZVBVVEdVYmdsNVBEY3BYMVRJREtybVQ5em1yRnFxOTRNOXk1ZlpnSXV3N0pucU5oWGNIdEw4Z0RRL21pVjZCVWVtd2ZYVCtmajlrN2d5bXF2eGltMENDSGhKVlpDbFQ3Mi9nR0FOd1RiaWp6TGNPNW5mS2NLQjVGWjdwZ2U1U2VzTzUrSm8yZFR5aktjRERBUk5RYnFvWDdjT1RnUDhWODhhUTZ4OFVvTGQ2Y0xQc2pMQ1ZrbE5sS1BIOE0wbXhVZm1aSzB2bjE1VTN5TjZlK3VCalp4czVVaDdUMmZEMThpUG0wUENPdnNjVHVtWEJYQkxwM21lSUU2NFZmc09rbDh3OUg2QWdrMUEzSUZqbjRDNHpuaDF5Z1Nua055SjFsVTJGenFpL0gwSHlTUXN0Q3dOWVhqZno4YnRiZG1CRTQzUGpzUUxjRktldGlxa1VPNGFNQT0tLWpkbTN0SnE1eXlVTVJNdUg3bWErbmc9PQ%3D%3D--284758d8a2807a3fee89cadf28bb0b5705654556;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [7b8ab32a-0d3a-4e4c-b0fb-0bb8d08a22c7]
      X-Runtime: ['0.003396']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Code", "method": "where", "arguments": {}, "options": {"offset":
      -1, "limit": 1, "reverse": true}}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['109']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=m9BhqHNoC4CrrYM6rOWBMd%2BtXACVAC0WR8InH5P3MJd%2FQRO4OnNVo7VgwVLu7HbeRRGWbuzEDvt8J6SQ6h8SvQ%3D%3D;
          _aquarium_NURSERY_production_session=dkszMkZZSVBhc0JtUzVPb1p0aEpucmlQb3RYL2ZvektDQ0p6eU1rRHFqTW1oZloxOUs2d1hHQWtvMVlkS2hacUtaRTlzOEZpY2d1dTFwNEFGaDlXRGdCakJubGsxQkZvN2h5Q0lXSUd2N0lVb1BveUxnM3RhUk5zb2trVHVEQ21pMzEvK2FMenlsZ2kzUFZMQ255dS9QU24xenNzZVlmdEpkNW9LRlpKclJsbm4wNUYxb09HV0pEbUgvejZGaFQzcVJSNWxHYmJEWjhrRWIrT20zcmY5K2VQQUJGczM4bEJKL0M1UnYzcThrUFV0c2hMY3dFUDhtaTVQaWFLU2NWVkMveVk3T0x0aTNGVE4vL3MvMDlwMmNNQ3I1d24vejB6eHQwU2VPbm9CY1JESlBvaWp6NEZ2VFNzQktXOWNCc1loRlllc2w0NjdidGRqQi8xR1d4K1dudFR5bzMveStYbFZJVGhWdmdWNEdHUjhYMjE4VjFrcHNleHIrUjBYcUkrc2U2dzdBaDlXUTVNUFk4VThZZUs4N0xId01Wa1hyVmNjTW5ZWS9JdlVwdz0tLXM2MVpPdkdwcUhqc2UvMzEwKzBjUGc9PQ%3D%3D--7f8bb00f651e2efa18fdc6af3eab397d8182bf43;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: "[{\"id\":89429,\"name\":\"protocol\",\"content\":\"needs \\\"Cloning
        Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds 'Standard
        Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n    \\n
        \ # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # Add association from which item
        the 1ng/ul dilution came from\\n    ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].associate(:diluted_from,
        op.input(input).item.id) }\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1460,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T13:38:11.000-07:00\",\"updated_at\":\"2018-10-31T13:38:11.000-07:00\",\"user_id\":192}]"}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 03:57:21 GMT']
      ETag: [W/"1c9c3a3782770c01a7dd4af9f5cf70a0"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=JUoPwzRdWajszBDXOwlEmFytB4xvd2Jy701S52hnFp3B233TfUYHi%2FIBUr95ALN3xhHN4hazQZ%2FUqNFoEY80tw%3D%3D;
          path=/, _aquarium_NURSERY_production_session=QnlVYUY5a0w1ZUhUa205ZUQvNFQvQ3JpOVprZVkxbGY1eTJmdUxlUzZvSVhwVWwwK3lxWjBTVEc2QWdCY1piVkFJUEVlTWtvbFRwaW5iUGZHWWtHZlJDa2lUMzV5MmhFK1BOZ1YzeDRDSzJaQ0krZzFIMWZEWmdLTEp1NHpraUpvZDd4Ti9xdEQ2WVpRU2N5S2NNSjh4Z2JTOVJFb0hnaitYTjhtVURKSjgyakR5Mi9FNDRiZ3VMUkI1NEh2ZTZDU0NQN1NnVnc4dFJ1bDFLb2NVbDgvelJmMG1hMzgyMFdpMzk1QnFWYnFuMkNObld4Z1VqM2hDVGhYM211VzlGcllaOThtMkcrT09FZlV1aFB1WjdORWcweXFSdk14QWNMeDFEejlCZGNUelZXWlFjTDdWaU0rajRqQnRiTGhNUHVTK1JVSllrQjJFNVBSREs2dDYvaFcreUorZHdGMW9ZVHRkdi9ZT0YrdzJvUGdCVnoxS1VHTzNJQ00vaVlvTXNPQWRCZWpXeVBqcGZlTWU3d2NVVmZiL3RNZHhtbUVrODVBcXUzMWhVTUdyND0tLVJWL1dHRGpBR1pXcnNPeFVHZWpkSEE9PQ%3D%3D--1e68d11ea32102e79247c21f47cd18a9839c453e;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [f1bed1bf-02d4-4340-a45e-30d258159c56]
      X-Runtime: ['0.047886']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "User", "id": 192}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['28']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=m9BhqHNoC4CrrYM6rOWBMd%2BtXACVAC0WR8InH5P3MJd%2FQRO4OnNVo7VgwVLu7HbeRRGWbuzEDvt8J6SQ6h8SvQ%3D%3D;
          _aquarium_NURSERY_production_session=dkszMkZZSVBhc0JtUzVPb1p0aEpucmlQb3RYL2ZvektDQ0p6eU1rRHFqTW1oZloxOUs2d1hHQWtvMVlkS2hacUtaRTlzOEZpY2d1dTFwNEFGaDlXRGdCakJubGsxQkZvN2h5Q0lXSUd2N0lVb1BveUxnM3RhUk5zb2trVHVEQ21pMzEvK2FMenlsZ2kzUFZMQ255dS9QU24xenNzZVlmdEpkNW9LRlpKclJsbm4wNUYxb09HV0pEbUgvejZGaFQzcVJSNWxHYmJEWjhrRWIrT20zcmY5K2VQQUJGczM4bEJKL0M1UnYzcThrUFV0c2hMY3dFUDhtaTVQaWFLU2NWVkMveVk3T0x0aTNGVE4vL3MvMDlwMmNNQ3I1d24vejB6eHQwU2VPbm9CY1JESlBvaWp6NEZ2VFNzQktXOWNCc1loRlllc2w0NjdidGRqQi8xR1d4K1dudFR5bzMveStYbFZJVGhWdmdWNEdHUjhYMjE4VjFrcHNleHIrUjBYcUkrc2U2dzdBaDlXUTVNUFk4VThZZUs4N0xId01Wa1hyVmNjTW5ZWS9JdlVwdz0tLXM2MVpPdkdwcUhqc2UvMzEwKzBjUGc9PQ%3D%3D--7f8bb00f651e2efa18fdc6af3eab397d8182bf43;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":192,"name":"Eriberto Lopez","login":"elopez","created_at":"2017-07-20T09:19:54.000-07:00","updated_at":"2017-07-20T09:19:54.000-07:00","password_digest":"$2a$10$t6kG6oECRZz10YE15y5p0uKeCulXhzzh/.7zsCQNuXF5XqaEK7g6.","remember_token":"iRjxzS2KV2WZKFjr-sNWzA","admin":false,"key":null,"groups":[{"id":217,"name":"elopez","description":"A
        group containing only user Eriberto Lopez","created_at":"2017-07-20T09:19:54.000-07:00","updated_at":"2017-07-20T09:19:54.000-07:00"},{"id":1,"name":"admin","description":"These
        users can use administrative functions (make users, etc)","created_at":"2013-11-15T13:37:36.000-08:00","updated_at":"2013-11-15T13:37:36.000-08:00"}]}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 03:57:21 GMT']
      ETag: [W/"95bde8d34902e2a5863e5541fdd355d5"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=8pfPtr8PO9G71KFwA8ZAwYTMjUbiFQolKvLNoVzWqcgWBr2m9hRl8qUZ4xhBz7cuHnBHKJvRKcgRF04uJT6L4g%3D%3D;
          path=/, _aquarium_NURSERY_production_session=S0RiTTZnSHpmMGhuYUw0QVJqRFIzVkJWUG1UWVBkL1Jwd2RURitSSG9NK1hmRGdXaHpaNGQwdzV3UjVsanQ3REEreVVWM0F5NjdVRUpzeml0MHlubk1Pa21jNTFIYUlDZnNNMXlJSlVxMENnZEVDU245RDZiTUZNUjlyRWVBQjh5cWZWdnZWWVJLMVR1bm9rK2M5SkJjZzEyMHozRTB5SEl4SkMvVUMvaVVYVDBiM2pqYVhYSFc0eThaUDhvNWNFVHlHa25lRDllZTJmamgvaTRQVVlQdGUyODhxZ0JnQTV2MW0vcmt4eHFlRVFaVGZ6ZjFnbFFlbXVWS3AzeFM0TkxvY2pLTmRqOHRod0dPZlE4cGZIRU13R1dNZWpnUHAyTU9ZbytJeXh3TnpDdlEza2J0ellLcXpEMmJXSGx2Qmc4VnJ4RXd2ZkhDby83NFUwY09vcDJEeTZ5L0x1Y3YrdTFQc2d4Rkt0eGZaUlVtMHRuYzIveFduV0h1dnBTQXBGZy94UEJYN0ZtTGJoZFJYSmgyaTNqYlg0MmtFNTU5R2FuM0Zwc3pOYXNUQT0tLU0rZmFOdkptY0llMTlIc0dhR1cxYnc9PQ%3D%3D--3af48ad1a7ad201df0c458628a01e889fdb06bd4;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [9f87b071-af94-424d-9db6-8b9568828f77]
      X-Runtime: ['0.006683']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "OperationType", "id": 1460}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['38']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=m9BhqHNoC4CrrYM6rOWBMd%2BtXACVAC0WR8InH5P3MJd%2FQRO4OnNVo7VgwVLu7HbeRRGWbuzEDvt8J6SQ6h8SvQ%3D%3D;
          _aquarium_NURSERY_production_session=dkszMkZZSVBhc0JtUzVPb1p0aEpucmlQb3RYL2ZvektDQ0p6eU1rRHFqTW1oZloxOUs2d1hHQWtvMVlkS2hacUtaRTlzOEZpY2d1dTFwNEFGaDlXRGdCakJubGsxQkZvN2h5Q0lXSUd2N0lVb1BveUxnM3RhUk5zb2trVHVEQ21pMzEvK2FMenlsZ2kzUFZMQ255dS9QU24xenNzZVlmdEpkNW9LRlpKclJsbm4wNUYxb09HV0pEbUgvejZGaFQzcVJSNWxHYmJEWjhrRWIrT20zcmY5K2VQQUJGczM4bEJKL0M1UnYzcThrUFV0c2hMY3dFUDhtaTVQaWFLU2NWVkMveVk3T0x0aTNGVE4vL3MvMDlwMmNNQ3I1d24vejB6eHQwU2VPbm9CY1JESlBvaWp6NEZ2VFNzQktXOWNCc1loRlllc2w0NjdidGRqQi8xR1d4K1dudFR5bzMveStYbFZJVGhWdmdWNEdHUjhYMjE4VjFrcHNleHIrUjBYcUkrc2U2dzdBaDlXUTVNUFk4VThZZUs4N0xId01Wa1hyVmNjTW5ZWS9JdlVwdz0tLXM2MVpPdkdwcUhqc2UvMzEwKzBjUGc9PQ%3D%3D--7f8bb00f651e2efa18fdc6af3eab397d8182bf43;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":1460,"name":"Make PCR Fragment","category":"Cloning","deployed":true,"on_the_fly":false,"created_at":"2018-08-21T12:29:17.000-07:00","updated_at":"2018-08-21T12:30:10.000-07:00"}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 03:57:21 GMT']
      ETag: [W/"b7f32b42f3f909030581c05e03dc861c"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=Ek0CnBtZzsXW2t8mIaW1keKSAlwLM5esfHhAKIQ%2FTMT23HCMUkKQ5sgXnU5jrEJ%2BeC7IMnL3tEFHncOn%2Fddu7g%3D%3D;
          path=/, _aquarium_NURSERY_production_session=ek5MNkpmKzJvRFN6TTJaQlFwQ0NZK0ZvaW11ZTV2UjJ1OWE2Vkl5V0hWUFYrVlNqV3RxRVZVOUg4eE9FZlhTV1oxdWR4OEl6RWYxM2hySU41Qk9rU3lFTmptY1hrRjBodEx4M0xHdVlZTmFmWFlEeFl4ZTd0SFFjYXM3K21JRFVja1ZoaENBWnVJMGJzK0gya24weVdlcllORlgwMGR2MWNGUHY0R0JJRVpiQmswUWNCTjJMTTMwa2FWOEdkNzdycHVCYjI2N1gwUW5qaUIvVVRTZUZPcm8vaDlid2xFMVZnYVhtV1h1RXJiNjhEbmxneFhtMFNkSFNUWEYydDZnUkhPVERwMG90OS9HSXF2Qm9iQ0lTR2huM25GL1lYaWpyVDdxZjg2ejNqdG1CZlpOR2pCcFMvaDB1bWZHcUY2MEFwa1AyKzF5azhyU2dod2YzOWdxUXExejU5ZmpjWDZrd3VYUS94MzhwVnJpRWh4MzZjYWFDZ1VxS0JhcWVsSE0wWWU1bXVULyt2MVR6djVsNXJQVUcyYnU0WWo4YjhhZkl4aldURSttOTBMaz0tLXc0OSt6SGlrNXRqZGdkWWJrdE0yZEE9PQ%3D%3D--f31aad897df88ca9d07cef5d983cfbeb404ad36e;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [1c4887f5-c740-439b-a34e-73d10ad39d6c]
      X-Runtime: ['0.003193']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Code", "method": "where", "arguments": {}, "options": {"offset":
      -1, "limit": 1, "reverse": true}}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['109']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=jBrGDiu1OpVEhaFfs%2B1A5x3s2q8xFx7AhFAF33vWPuTMdiU3iwEOL5u14cGqrDH63GxvVLiJTa3hzdoDsNptmw%3D%3D;
          _aquarium_NURSERY_production_session=djVDcUNuZ2FaQ1VDV0RRUFYvc0Q2UHpreTdoOHJjdlh3NWQxNGxyeW04M0sxSVQ5d3hIbHZRWlJtbjFnUWF1VmRmejBsNUZLMTVVR3FITmtUTFd1eGRqZkRmdGVCVmFmMElQQUl1WFZEbk85UTRhem9qL2FId2JvR3lZTEk5VjJmYmJnQVVENkh1d2ZBTkkrb1NzUDF0V2F6d1VRc2xhZFVPRkpTY0xuTDk4V3I3cWF5R2loaHNCVm1sWW1IMkdUSXB0RWhVL0IvTTRkU1dNcW94MzFMZnIxSTRwY1lRd3ZJekV5L0Fpd0FXU1ZIZjZQU2ZjdUVxK1VmU1FEVyswM2JCUkdmTi8yN2Fuemg0Z1cyUTV5K2VOTFZCOWpIMFd3LzhRNW1nQkliRjB0M2QyYjNDanFXSDdiTFp6clBjRWpqcGdMM1VKVVBpdVl6VHdkSytONzFvZVNPNEFETTQxdEdXNG83dmcvREVRdmZxbjdqSzE2NHRLMldsZktGUVR0eHlkcjNCM2lDRUdNYjdQVG5zcWVRV1M3cGdWSU10QnVBTm04WURxcWc4WT0tLTRRU2dGM0VmVTVTTzZTbzJKc0FaOXc9PQ%3D%3D--6248b7b24b4e69c33ab6586d4476c2e8dc1a73a3;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: "[{\"id\":89429,\"name\":\"protocol\",\"content\":\"needs \\\"Cloning
        Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds 'Standard
        Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n    \\n
        \ # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # Add association from which item
        the 1ng/ul dilution came from\\n    ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].associate(:diluted_from,
        op.input(input).item.id) }\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1460,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T13:38:11.000-07:00\",\"updated_at\":\"2018-10-31T13:38:11.000-07:00\",\"user_id\":192}]"}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:05:19 GMT']
      ETag: [W/"1c9c3a3782770c01a7dd4af9f5cf70a0"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=dQ0NMmKYht8U5sL7LaMUz3j9xwt0IisBPHLLHyMPDCM1Ye4LwiyyZcvWgmU04mXSuX1y8P28eGxZ7xTD6ANfXA%3D%3D;
          path=/, _aquarium_NURSERY_production_session=MjlXWWVDb1NsWmtydmNpNjlKVXdoRU9RZGZNeHBadTJxS1JidjBZdVZDNkd2ZGd4RkEvRHVYUzN6R285RkxkOG5NY3RXU0t1VmxuKzMyM1RuVjVBTjQvWDNxVXRBZk9iaVJFN0VlRUpIak5YeDlZK1NYQjhBeWEwRUZPaFdKaFkrRVl1d1czSmY2cko2QkJvUXpxRFBETmI0Z2dVaVFMUEN1OWNGSXBySFdGVVp2RVh5d29YcFlkMFNTeHJuQmtXOUFmVU9HQ1ozTVRXNEtwMUdmVGRFZmMrWlhtWVgybUpVeVBIVDhHZG9ncWRuT2hBWmZEYlhnbnptQVBHWWYxVDhYU3N3aDhNQkYyaHhzcGdXaUg2eU5oNlJodXV1QldGVW9IZUdLbG0vb2FoaUs1V1ZYc1JmZ0EzMXlLa2Q0MGppNDNuNnFnMUxlcHVLd0VMaGdralhPZHNUb05CQjFNZDhLNm4zeWMxLzlsK2FDMkVUaExxZ0hjOGlEOWRvblpjKy8yc2kxZkFKTVptRU94V1MrQ1d1WXh5cFRybEk2cEtqcUhsQmdqSEc5RT0tLXh1M3FkMjRWSUtNc2FrRloxOEhBZGc9PQ%3D%3D--1308826718d250a12f55fe8a4779d4d808c1ba7a;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [26d2a3e9-7f22-4b0c-8653-6104484b3007]
      X-Runtime: ['0.048036']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Code", "method": "where", "arguments": {}, "options": {"offset":
      -1, "limit": 11, "reverse": true}}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['110']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=jBrGDiu1OpVEhaFfs%2B1A5x3s2q8xFx7AhFAF33vWPuTMdiU3iwEOL5u14cGqrDH63GxvVLiJTa3hzdoDsNptmw%3D%3D;
          _aquarium_NURSERY_production_session=djVDcUNuZ2FaQ1VDV0RRUFYvc0Q2UHpreTdoOHJjdlh3NWQxNGxyeW04M0sxSVQ5d3hIbHZRWlJtbjFnUWF1VmRmejBsNUZLMTVVR3FITmtUTFd1eGRqZkRmdGVCVmFmMElQQUl1WFZEbk85UTRhem9qL2FId2JvR3lZTEk5VjJmYmJnQVVENkh1d2ZBTkkrb1NzUDF0V2F6d1VRc2xhZFVPRkpTY0xuTDk4V3I3cWF5R2loaHNCVm1sWW1IMkdUSXB0RWhVL0IvTTRkU1dNcW94MzFMZnIxSTRwY1lRd3ZJekV5L0Fpd0FXU1ZIZjZQU2ZjdUVxK1VmU1FEVyswM2JCUkdmTi8yN2Fuemg0Z1cyUTV5K2VOTFZCOWpIMFd3LzhRNW1nQkliRjB0M2QyYjNDanFXSDdiTFp6clBjRWpqcGdMM1VKVVBpdVl6VHdkSytONzFvZVNPNEFETTQxdEdXNG83dmcvREVRdmZxbjdqSzE2NHRLMldsZktGUVR0eHlkcjNCM2lDRUdNYjdQVG5zcWVRV1M3cGdWSU10QnVBTm04WURxcWc4WT0tLTRRU2dGM0VmVTVTTzZTbzJKc0FaOXc9PQ%3D%3D--6248b7b24b4e69c33ab6586d4476c2e8dc1a73a3;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: "[{\"id\":89429,\"name\":\"protocol\",\"content\":\"needs \\\"Cloning
        Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds 'Standard
        Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n    \\n
        \ # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # Add association from which item
        the 1ng/ul dilution came from\\n    ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].associate(:diluted_from,
        op.input(input).item.id) }\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1460,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T13:38:11.000-07:00\",\"updated_at\":\"2018-10-31T13:38:11.000-07:00\",\"user_id\":192},{\"id\":89428,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # Add association from which item
        the 1ng/ul dilution came from\\n    ops_w_undiluted_template.map { |op| \\n
        \       op.temporary[:diluted_stock].associate(:diluted_from, op.input(input).item.id)\\n
        \   }\\n    \\n    \\n    \\n    # return input stocks\\n    release ops_w_undiluted_template.map
        { |op| op.input(input).item }, interactive: true, method: \\\"boxes\\\"\\n
        \   \\n    # retrieve the rest of the inputs\\n    operations.reject { |op|
        ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set diluted
        stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1460,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T13:37:06.000-07:00\",\"updated_at\":\"2018-10-31T13:37:06.000-07:00\",\"user_id\":192},{\"id\":89427,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # Add association from which item
        the 1ng/ul dilution came from\\n    show do\\n        ops_w_undiluted_template.map
        { |op| \\n            note \\\"#{op.temporary[:diluted_stock]} was diluted
        from #{op.input(input).item}\\\"\\n            \\n        }\\n    end\\n    \\n
        \   \\n    \\n    # return input stocks\\n    release ops_w_undiluted_template.map
        { |op| op.input(input).item }, interactive: true, method: \\\"boxes\\\"\\n
        \   \\n    # retrieve the rest of the inputs\\n    operations.reject { |op|
        ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set diluted
        stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1460,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T13:35:28.000-07:00\",\"updated_at\":\"2018-10-31T13:35:28.000-07:00\",\"user_id\":192},{\"id\":89426,\"name\":\"protocol\",\"content\":\"#
        Devin Strickland\\n# dvn.strcklnd@gmail.com\\n#\\n# makes 96-well Primer Plate
        collection item from IDT spreadsheet (saved as .csv)\\n\\nneeds \\\"Standard
        Libs/UploadHelper\\\"\\nneeds \\\"Standard Libs/Debug\\\"\\nneeds \\\"Standard
        Libs/MatrixTools\\\"\\nneeds \\\"Standard Libs/AssociationManagement\\\"\\nneeds
        \\\"Next Gen Prep/PrimerPlateHelper\\\"\\n\\nclass Protocol\\n\\n    include
        UploadHelper, Debug, MatrixTools, AssociationManagement\\n    include PrimerPlateHelper\\n\\n
        \   # I/O\\n    CONCENTRATION = \\\"Concentration\\\"\\n\\n    # upload stuff\\n
        \   DIRNAME = \\\"Unknown\\\"\\n    TRIES = 3\\n    NUM_FILES = 1\\n\\n    #
        IDT file format stuff\\n    NAME = \\\"Sequence Name\\\"\\n    POS = \\\"Well
        Position\\\"\\n    SEQ = \\\"Sequence\\\"\\n\\n    # Sample\\n    PROJECT
        = \\\"Primer plate\\\" # project description in Sample definition\\n    PRIMER
        = \\\"Primer\\\" # type of Sample\\n    PRIMER_PLATE = \\\"96-Well Primer
        Plate\\\"\\n\\n    MY_DEBUG = true\\n\\n    def main\\n        \\n        operations.each
        do |op|\\n            \\n            if debug \\u0026\\u0026 MY_DEBUG\\n                upload
        = nil\\n                vendor_description = CSV.parse(CSV_DEBUG)\\n            else\\n
        \               uploads = uploadData(DIRNAME, NUM_FILES, TRIES)\\n                upload
        = uploads.first\\n                vendor_description = CSV.read(open(upload.url))\\n
        \           end\\n            \\n            vendor_description = format_data(vendor_description)\\n
        \           \\n            find_or_create_primers(vendor_description)\\n            \\n
        \           primer_plate = Collection.new_collection(PRIMER_PLATE)\\n            \\n
        \           matrix = WellMatrix.create_empty(96, Collection::EMPTY)\\n            \\n
        \           vendor_description.each do |md|\\n                matrix.set(md[POS],
        md[\\\"Sample\\\"].id)\\n            end\\n            \\n            primer_plate.associate_matrix(matrix.to_array)\\n
        \           associate_data(primer_plate, 'vendor_description', upload)\\n
        \           associate_data(primer_plate, 'concentration', op.input(CONCENTRATION).val)\\n
        \           \\n            show {\\n                title \\\"Primer Plate
        Creation Successful!\\\"\\n                note \\\"Please label the #{PRIMER_PLATE}
        with Item ID #{primer_plate}.\\\"\\n            }\\n            \\n        end\\n
        \       \\n        operations.store\\n        \\n        return {}\\n\\n    end\\n\\n
        \   def find_or_create_primers(vendor_description)\\n        sample_type =
        SampleType.find_by_name(PRIMER)\\n            \\n        vendor_description.each
        do |md|\\n            sample = Sample.where(name: md[NAME], sample_type: sample_type).first\\n
        \           if sample\\n                found_sequence = sample.properties[\\\"Overhang
        Sequence\\\"].to_s + sample.properties[\\\"Anneal Sequence\\\"].to_s\\n                unless
        found_sequence =~ /^#{md[SEQ]}$/i\\n                    raise \\\"Aq entry
        found for #{md[NAME]}, but sequences do not match.\\\"\\n                end\\n
        \           else\\n                desc = \\\"Created automatically as part
        of Sales Order ##{md[\\\"Sales Order #\\\"]}.\\\"\\n                sample_attr
        = {\\n                    sample_type_id: sample_type.id,\\n                    description:
        desc,\\n                    name: md[NAME],\\n                    project:
        PROJECT,\\n                    field_values: [\\n                      { name:
        \\\"Anneal Sequence\\\", value: md[SEQ] },\\n                      { name:
        \\\"Overhang Sequence\\\", value: \\\"\\\" },\\n                      { name:
        \\\"T Anneal\\\", value: md[\\\"Tm\\\"] }\\n                    ]\\n                }\\n
        \               sample = Sample.creator(sample_attr, op.plan.user)\\n                inspect
        sample\\n                inspect sample.properties[\\\"Overhang Sequence\\\"].to_s\\n
        \               inspect sample.properties[\\\"Anneal Sequence\\\"].to_s\\n
        \               inspect sample.properties[\\\"T Anneal\\\"].to_s\\n            end\\n
        \           md[\\\"Sample\\\"] = sample\\n        end\\n    end\\n\\n    def
        format_data(vendor_description)\\n        headers = vendor_description.shift\\n
        \       formatted = []\\n        \\n        vendor_description.each do |row|\\n
        \           row = row.map do |cell|\\n                cell.gsub(\\\"\\\\\\\"\\\",\\\"\\\").gsub('\\\\xEF\\\\xBB\\\\xBF','').gsub(\\\"[\\\",\\\"\\\").gsub(\\\"]\\\",\\\"\\\").strip
        if cell.respond_to?(:strip)\\n            end\\n            row = Hash[headers.zip(row)]\\n
        \           \\n            if row['Sequence'].blank? || row[NAME].blank?\\n
        \               raise \\\"Name or Sequence Missing:\\\\n#{row}\\\"\\n            end\\n
        \           \\n            row['Sequence'] = row['Sequence'].gsub(/\\\\s+/,
        '')\\n            formatted.append(row)\\n        end\\n        \\n        formatted\\n
        \   end\\n\\nend\\n\",\"parent_id\":1320,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T10:59:20.000-07:00\",\"updated_at\":\"2018-10-31T10:59:20.000-07:00\",\"user_id\":185},{\"id\":89425,\"name\":\"protocol\",\"content\":\"#
        Devin Strickland\\n# dvn.strcklnd@gmail.com\\n#\\n# makes 96-well Primer Plate
        collection item from IDT spreadsheet (saved as .csv)\\n\\nneeds \\\"Standard
        Libs/UploadHelper\\\"\\nneeds \\\"Standard Libs/Debug\\\"\\nneeds \\\"Standard
        Libs/MatrixTools\\\"\\nneeds \\\"Standard Libs/AssociationManagement\\\"\\nneeds
        \\\"Next Gen Prep/PrimerPlateHelper\\\"\\n\\nclass Protocol\\n\\n    include
        UploadHelper, Debug, MatrixTools, AssociationManagement\\n    include PrimerPlateHelper\\n\\n
        \   # I/O\\n    CONCENTRATION = \\\"Concentration\\\"\\n\\n    # upload stuff\\n
        \   DIRNAME = \\\"Unknown\\\"\\n    TRIES = 3\\n    NUM_FILES = 1\\n\\n    #
        IDT file format stuff\\n    NAME = \\\"Sequence Name\\\"\\n    POS = \\\"Well
        Position\\\"\\n    SEQ = \\\"Sequence\\\"\\n\\n    # Sample\\n    PROJECT
        = \\\"Primer plate\\\" # project description in Sample definition\\n    PRIMER
        = \\\"Primer\\\" # type of Sample\\n    PRIMER_PLATE = \\\"96-Well Primer
        Plate\\\"\\n\\n    MY_DEBUG = true\\n\\n    def main\\n        \\n        operations.each
        do |op|\\n            \\n            if debug \\u0026\\u0026 MY_DEBUG\\n                upload
        = nil\\n                vendor_description = CSV.parse(CSV_DEBUG)\\n            else\\n
        \               uploads = uploadData(DIRNAME, NUM_FILES, TRIES)\\n                upload
        = uploads.first\\n                vendor_description = CSV.read(open(upload.url))\\n
        \           end\\n            \\n            vendor_description = format_data(vendor_description)\\n
        \           \\n            find_or_create_primers(vendor_description)\\n            \\n
        \           primer_plate = Collection.new_collection(PRIMER_PLATE)\\n            \\n
        \           matrix = WellMatrix.create_empty(96, Collection::EMPTY)\\n            \\n
        \           vendor_description.each do |md|\\n                matrix.set(md[POS],
        md[\\\"Sample\\\"].id)\\n            end\\n            \\n            primer_plate.associate_matrix(matrix.to_array)\\n
        \           associate_data(primer_plate, :vendor_description, upload)\\n            associate_data(primer_plate,
        :concentration, op.input(CONCENTRATION).val)\\n            \\n            show
        {\\n                title \\\"Primer Plate Creation Successful!\\\"\\n                note
        \\\"Please label the #{PRIMER_PLATE} with Item ID #{primer_plate}.\\\"\\n
        \           }\\n            \\n        end\\n        \\n        operations.store\\n
        \       \\n        return {}\\n\\n    end\\n\\n    def find_or_create_primers(vendor_description)\\n
        \       sample_type = SampleType.find_by_name(PRIMER)\\n            \\n        vendor_description.each
        do |md|\\n            sample = Sample.where(name: md[NAME], sample_type: sample_type).first\\n
        \           if sample\\n                found_sequence = sample.properties[\\\"Overhang
        Sequence\\\"].to_s + sample.properties[\\\"Anneal Sequence\\\"].to_s\\n                unless
        found_sequence =~ /^#{md[SEQ]}$/i\\n                    raise \\\"Aq entry
        found for #{md[NAME]}, but sequences do not match.\\\"\\n                end\\n
        \           else\\n                desc = \\\"Created automatically as part
        of Sales Order ##{md[\\\"Sales Order #\\\"]}.\\\"\\n                sample_attr
        = {\\n                    sample_type_id: sample_type.id,\\n                    description:
        desc,\\n                    name: md[NAME],\\n                    project:
        PROJECT,\\n                    field_values: [\\n                      { name:
        \\\"Anneal Sequence\\\", value: md[SEQ] },\\n                      { name:
        \\\"Overhang Sequence\\\", value: \\\"\\\" },\\n                      { name:
        \\\"T Anneal\\\", value: md[\\\"Tm\\\"] }\\n                    ]\\n                }\\n
        \               sample = Sample.creator(sample_attr, op.plan.user)\\n                inspect
        sample\\n                inspect sample.properties[\\\"Overhang Sequence\\\"].to_s\\n
        \               inspect sample.properties[\\\"Anneal Sequence\\\"].to_s\\n
        \               inspect sample.properties[\\\"T Anneal\\\"].to_s\\n            end\\n
        \           md[\\\"Sample\\\"] = sample\\n        end\\n    end\\n\\n    def
        format_data(vendor_description)\\n        headers = vendor_description.shift\\n
        \       formatted = []\\n        \\n        vendor_description.each do |row|\\n
        \           row = row.map do |cell|\\n                cell.gsub(\\\"\\\\\\\"\\\",\\\"\\\").gsub('\\\\xEF\\\\xBB\\\\xBF','').gsub(\\\"[\\\",\\\"\\\").gsub(\\\"]\\\",\\\"\\\").strip
        if cell.respond_to?(:strip)\\n            end\\n            row = Hash[headers.zip(row)]\\n
        \           \\n            if row['Sequence'].blank? || row[NAME].blank?\\n
        \               raise \\\"Name or Sequence Missing:\\\\n#{row}\\\"\\n            end\\n
        \           \\n            row['Sequence'] = row['Sequence'].gsub(/\\\\s+/,
        '')\\n            formatted.append(row)\\n        end\\n        \\n        formatted\\n
        \   end\\n\\nend\\n\",\"parent_id\":1320,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T10:46:12.000-07:00\",\"updated_at\":\"2018-10-31T10:46:12.000-07:00\",\"user_id\":185},{\"id\":89424,\"name\":\"protocol\",\"content\":\"#
        Devin Strickland\\n# dvn.strcklnd@gmail.com\\n#\\n# makes 96-well Primer Plate
        collection item from IDT spreadsheet (saved as .csv)\\n\\nneeds \\\"Standard
        Libs/UploadHelper\\\"\\nneeds \\\"Standard Libs/Debug\\\"\\nneeds \\\"Standard
        Libs/MatrixTools\\\"\\nneeds \\\"Next Gen Prep/PrimerPlateHelper\\\"\\n\\nclass
        Protocol\\n\\n    include UploadHelper, Debug, MatrixTools\\n    include PrimerPlateHelper\\n\\n
        \   # I/O\\n    CONCENTRATION = \\\"Concentration\\\"\\n\\n    # upload stuff\\n
        \   DIRNAME = \\\"Unknown\\\"\\n    TRIES = 3\\n    NUM_FILES = 1\\n\\n    #
        IDT file format stuff\\n    NAME = \\\"Sequence Name\\\"\\n    POS = \\\"Well
        Position\\\"\\n    SEQ = \\\"Sequence\\\"\\n\\n    # Sample\\n    PROJECT
        = \\\"Primer plate\\\" # project description in Sample definition\\n    PRIMER
        = \\\"Primer\\\" # type of Sample\\n    PRIMER_PLATE = \\\"96-Well Primer
        Plate\\\"\\n\\n    MY_DEBUG = true\\n\\n    def main\\n        \\n        operations.each
        do |op|\\n            \\n            if debug \\u0026\\u0026 MY_DEBUG\\n                uploads
        = [nil]\\n                mfr_description = CSV.parse(CSV_DEBUG)\\n            else\\n
        \               uploads = uploadData(DIRNAME, NUM_FILES, TRIES)\\n                mfr_description
        = CSV.read(open(uploads[0].url))\\n            end\\n            \\n            mfr_description
        = format_data(mfr_description)\\n            \\n            find_or_create_primers(mfr_description)\\n
        \           \\n            primer_plate = Collection.new_collection(PRIMER_PLATE)\\n
        \           \\n            matrix = WellMatrix.create_empty(96, Collection::EMPTY)\\n
        \           \\n            mfr_description.each do |md|\\n                matrix.set(md[POS],
        md[\\\"Sample\\\"].id)\\n            end\\n            \\n            primer_plate.associate_matrix(matrix.to_array)\\n
        \           \\n            primer_plate.associate(:upload, uploads[0])\\n
        \           primer_plate.associate(:concentration, op.input(CONCENTRATION).val)\\n
        \           \\n            show {\\n                title \\\"Primer Plate
        Creation Successful!\\\"\\n                note \\\"Please label the #{PRIMER_PLATE}
        with Item ID #{primer_plate}.\\\"\\n            }\\n            \\n        end\\n
        \       \\n        operations.store\\n        \\n        return {}\\n\\n    end\\n\\n
        \   def find_or_create_primers(mfr_description)\\n        sample_type = SampleType.find_by_name(PRIMER)\\n
        \           \\n        mfr_description.each do |md|\\n            sample =
        Sample.where(name: md[NAME], sample_type: sample_type).first\\n            if
        sample\\n                found_sequence = sample.properties[\\\"Overhang Sequence\\\"].to_s
        + sample.properties[\\\"Anneal Sequence\\\"].to_s\\n                unless
        found_sequence =~ /^#{md[SEQ]}$/i\\n                    raise \\\"Aq entry
        found for #{md[NAME]}, but sequences do not match.\\\"\\n                end\\n
        \           else\\n                desc = \\\"Created automatically as part
        of Sales Order ##{md[\\\"Sales Order #\\\"]}.\\\"\\n                sample_attr
        = {\\n                    sample_type_id: sample_type.id,\\n                    description:
        desc,\\n                    name: md[NAME],\\n                    project:
        PROJECT,\\n                    field_values: [\\n                      { name:
        \\\"Anneal Sequence\\\", value: md[SEQ] },\\n                      { name:
        \\\"Overhang Sequence\\\", value: \\\"\\\" },\\n                      { name:
        \\\"T Anneal\\\", value: md[\\\"Tm\\\"] }\\n                    ]\\n                }\\n
        \               sample = Sample.creator(sample_attr, op.plan.user)\\n                inspect
        sample\\n                inspect sample.properties[\\\"Overhang Sequence\\\"].to_s\\n
        \               inspect sample.properties[\\\"Anneal Sequence\\\"].to_s\\n
        \               inspect sample.properties[\\\"T Anneal\\\"].to_s\\n            end\\n
        \           md[\\\"Sample\\\"] = sample\\n        end\\n    end\\n\\n    def
        format_data(mfr_description)\\n        headers = mfr_description.shift\\n
        \       formatted = []\\n        \\n        mfr_description.each do |row|\\n
        \           row = row.map do |cell|\\n                cell.gsub(\\\"\\\\\\\"\\\",\\\"\\\").gsub('\\\\xEF\\\\xBB\\\\xBF','').gsub(\\\"[\\\",\\\"\\\").gsub(\\\"]\\\",\\\"\\\").strip
        if cell.respond_to?(:strip)\\n            end\\n            row = Hash[headers.zip(row)]\\n
        \           \\n            if row['Sequence'].blank? || row[NAME].blank?\\n
        \               raise \\\"Name or Sequence Missing:\\\\n#{row}\\\"\\n            end\\n
        \           \\n            row['Sequence'] = row['Sequence'].gsub(/\\\\s+/,
        '')\\n            formatted.append(row)\\n        end\\n        \\n        formatted\\n
        \   end\\n\\nend\\n\",\"parent_id\":1320,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T10:31:02.000-07:00\",\"updated_at\":\"2018-10-31T10:31:02.000-07:00\",\"user_id\":185},{\"id\":89423,\"name\":\"protocol\",\"content\":\"#
        Devin Strickland\\n# dvn.strcklnd@gmail.com\\n#\\n# makes 96-well Primer Plate
        collection item from IDT spreadsheet (saved as .csv)\\n\\nneeds \\\"Standard
        Libs/UploadHelper\\\"\\nneeds \\\"Standard Libs/Debug\\\"\\nneeds \\\"Standard
        Libs/MatrixTools\\\"\\nneeds \\\"Next Gen Prep/PrimerPlateHelper\\\"\\n\\nclass
        Protocol\\n\\n    include UploadHelper, Debug, MatrixTools\\n    include PrimerPlateHelper\\n\\n
        \   # I/O\\n    CONCENTRATION = \\\"Concentration\\\"\\n\\n    # upload stuff\\n
        \   DIRNAME = \\\"Unknown\\\"\\n    TRIES = 3\\n    NUM_FILES = 1\\n\\n    #
        IDT file format stuff\\n    NAME = \\\"Sequence Name\\\"\\n    POS = \\\"Well
        Position\\\"\\n    SEQ = \\\"Sequence\\\"\\n\\n    # Sample\\n    PROJECT
        = \\\"Primer plate\\\" # project description in Sample definition\\n    PRIMER
        = \\\"Primer\\\" # type of Sample\\n    PRIMER_PLATE = \\\"96-Well Primer
        Plate\\\"\\n\\n    MY_DEBUG = true\\n\\n    def main\\n        \\n        operations.each
        do |op|\\n            \\n            if debug \\u0026\\u0026 MY_DEBUG\\n                uploads
        = [nil]\\n                mfr_description = CSV.parse(CSV_DEBUG)\\n            else\\n
        \               uploads = uploadData(DIRNAME, NUM_FILES, TRIES)\\n                mfr_description
        = CSV.read(open(uploads[0].url))\\n            end\\n            \\n            mfr_description
        = format_data(mfr_description)\\n            \\n            find_or_create_primers(mfr_description)\\n
        \           \\n            primer_plate = Collection.new_collection(PRIMER_PLATE)\\n
        \           \\n            matrix = WellMatrix.create_empty(96, Collection::EMPTY)\\n
        \           \\n            mfr_description.each do |md|\\n                matrix.set(md[POS],
        md[\\\"Sample\\\"].id)\\n            end\\n            \\n            primer_plate.associate_matrix(matrix.to_array)\\n
        \           \\n            primer_plate.associate(:csv_upload, uploads[0])\\n
        \           primer_plate.associate(:concentration, op.input(CONCENTRATION).val)\\n
        \           \\n            show {\\n                title \\\"Primer Plate
        Creation Successful!\\\"\\n                note \\\"Please label the #{PRIMER_PLATE}
        with Item ID #{primer_plate}.\\\"\\n            }\\n            \\n        end\\n
        \       \\n        operations.store\\n        \\n        return {}\\n\\n    end\\n\\n
        \   def find_or_create_primers(mfr_description)\\n        sample_type = SampleType.find_by_name(PRIMER)\\n
        \           \\n        mfr_description.each do |md|\\n            sample =
        Sample.where(name: md[NAME], sample_type: sample_type).first\\n            if
        sample\\n                found_sequence = sample.properties[\\\"Overhang Sequence\\\"].to_s
        + sample.properties[\\\"Anneal Sequence\\\"].to_s\\n                unless
        found_sequence =~ /^#{md[SEQ]}$/i\\n                    raise \\\"Aq entry
        found for #{md[NAME]}, but sequences do not match.\\\"\\n                end\\n
        \           else\\n                desc = \\\"Created automatically as part
        of Sales Order ##{md[\\\"Sales Order #\\\"]}.\\\"\\n                sample_attr
        = {\\n                    sample_type_id: sample_type.id,\\n                    description:
        desc,\\n                    name: md[NAME],\\n                    project:
        PROJECT,\\n                    field_values: [\\n                      { name:
        \\\"Anneal Sequence\\\", value: md[SEQ] },\\n                      { name:
        \\\"Overhang Sequence\\\", value: \\\"\\\" },\\n                      { name:
        \\\"T Anneal\\\", value: md[\\\"Tm\\\"] }\\n                    ]\\n                }\\n
        \               sample = Sample.creator(sample_attr, op.plan.user)\\n                inspect
        sample\\n                inspect sample.properties[\\\"Overhang Sequence\\\"].to_s\\n
        \               inspect sample.properties[\\\"Anneal Sequence\\\"].to_s\\n
        \               inspect sample.properties[\\\"T Anneal\\\"].to_s\\n            end\\n
        \           md[\\\"Sample\\\"] = sample\\n        end\\n    end\\n\\n    def
        format_data(mfr_description)\\n        headers = mfr_description.shift\\n
        \       formatted = []\\n        \\n        mfr_description.each do |row|\\n
        \           row = row.map do |cell|\\n                cell.gsub(\\\"\\\\\\\"\\\",\\\"\\\").gsub('\\\\xEF\\\\xBB\\\\xBF','').gsub(\\\"[\\\",\\\"\\\").gsub(\\\"]\\\",\\\"\\\").strip
        if cell.respond_to?(:strip)\\n            end\\n            row = Hash[headers.zip(row)]\\n
        \           \\n            if row['Sequence'].blank? || row[NAME].blank?\\n
        \               raise \\\"Name or Sequence Missing:\\\\n#{row}\\\"\\n            end\\n
        \           \\n            row['Sequence'] = row['Sequence'].gsub(/\\\\s+/,
        '')\\n            formatted.append(row)\\n        end\\n        \\n        formatted\\n
        \   end\\n\\nend\\n\",\"parent_id\":1320,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T10:21:47.000-07:00\",\"updated_at\":\"2018-10-31T10:21:47.000-07:00\",\"user_id\":185},{\"id\":89422,\"name\":\"source\",\"content\":\"module
        Enrich_cDNA_Fragments\\n    include Units\\n    def library_type(collection)\\n
        \       # This may have an issue with distiguishing different sample types
        in the same collection\\n        sample_type = Sample.where({\\\"id\\\": collection.matrix.flatten.select
        {|s_id| s_id != -1}}).to_a.map {|s| s.sample_type.name }.uniq.first\\n        library_type
        = (sample_type == \\\"Yeast Strain\\\") ? \\\"cDNA\\\" : \\\"DNA\\\"\\n        return
        library_type\\n    end\\n\\n    def gather_defrost_amplification_materials(collections_to_defrost)\\n
        \       # Gather the frozen plate so that it is defrosted by the time all
        the reagents are prepped\\n        take collections_to_defrost, interactive:
        true\\n        \\n        num_ops = operations.length\\n        reagents_hash
        = {\\n            'PCR Master Mix (PMM)'=\\u003e '1-2 tube(s)',\\n            'PCR
        Primer Cocktail (PPC)'=\\u003e'1-2 tube(s)',\\n            'Resuspension Buffer
        (RSB)' =\\u003e'1-2 tube(s)',\\n            'Freshly prepared 80% Ethanol'=\\u003e
        reagent_vol_with_extra(num_ops, 400),\\n            'AMPure XP Beads'=\\u003e
        reagent_vol_with_extra(num_ops, 50)\\n        }\\n        show do\\n            title
        \\\"Gather the following materials:\\\"\\n            separator\\n            note
        \\\"Let the following reagents thaw at room temperature, then immediately
        place on ice\\\"\\n            reagents_hash.each {|k, v| (k.include? 'PCR')
        ? (check \\\"#{k}\\\") : nil}\\n            note \\\"\\\\n\\\"\\n            note
        \\\"Gather the following materials:\\\"\\n            etoh_vol = reagents_hash['Freshly
        prepared 80% Ethanol']\\n            check \\\"Make 80% EtOH =\\u003e #{etoh_vol
        * 0.8}#{MICROLITERS} of 100% EtOH + #{etoh_vol * 0.2}#{MICROLITERS} of MG
        H2O\\\"\\n            check \\\"\\u003cb\\u003e1\\u003c/b\\u003e - 96 Well
        PCR Plate(s)\\\"\\n            check \\\"\\u003cb\\u003e1\\u003c/b\\u003e
        - 96 Well MIDI 0.8mL Plate(s)\\\"\\n            check \\\"\\u003cb\\u003e3\\u003c/b\\u003e
        - Adhesive Seals\\\"\\n        end\\n    end\\n    \\n    def make_pcr_master_mix()\\n
        \       num_ops = operations.length\\n        pmm_vol = 25 * num_ops\\n        ppc_vol
        = 5 * num_ops\\n        master_mix_vol = pmm_vol + ppc_vol\\n        (master_mix_vol
        \\u003e 1501) ? tubes = 2 : tubes = 1\\n        (master_mix_vol \\u003e 1501)
        ? aliquot = [pmm_vol/2, ppc_vol/2] : aliquot = [pmm_vol, ppc_vol]\\n        show
        do \\n          title \\\"Create PCR Master Mix\\\"\\n          separator\\n
        \         check \\\"Ensure that #{'PCR Master Mix (PMM)'} \\u0026 #{'PCR Primer
        Cocktail (PPC)'} are defrosted\\\"\\n          check \\\"Gather \\u003cb\\u003e#{tubes}\\u003c/b\\u003e
        1.5mL microfuge tube(s) \\u0026 label: \\u003cb\\u003eMM\\u003c/b\\u003e.\\\"\\n
        \         check \\\"In each of the microfuge tube(s), aliquot \\u003cb\\u003e#{aliquot[0]}#{MICROLITERS}
        of PMM\\u003c/b\\u003e \\u0026 \\u003cb\\u003e#{aliquot[1]}#{MICROLITERS}
        of PPC\\u003c/b\\u003e\\\"\\n          bullet \\\"Mix throughly by pipetting,
        use a multichannel pipette where possible.\\\"\\n        end\\n    end\\n
        \   \\n    def add_pcr_master_mix(collection)\\n        library_type = library_type(collection)\\n
        \       if collection.get_non_empty.length \\u003e 18\\n            sw, sw_vol_mat,
        rc_list = multichannel_vol_stripwell(collection)\\n            show do\\n
        \               title \\\"Aliquot PCR Master Mix for Multichannel\\\"\\n                separator\\n
        \               note \\\"Follow the table to aliquot the PCR Master Mix into
        a stripwell for the next step:\\\"\\n                bullet \\\"The maximum
        volume in a stripwell well is 300#{MICROLITERS}\\\"\\n                table
        highlight_alpha_rc(sw, rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*30}#{MICROLITERS}\\\"}\\n
        \           end\\n            sw.mark_as_deleted\\n            sw.save\\n
        \       end\\n        show do\\n            title \\\"Aliquoting PCR MM to
        Indexed #{library_type} Libraries\\\"\\n            separator\\n            check
        \\\"Ensure samples in plate \\u003cb\\u003e#{collection}\\u003c/b\\u003e are
        thawed.\\\"\\n            note \\\"Follow the table to aliquot the PCR Master
        Mix to the appropriate wells:\\\"\\n            bullet \\\"Mix throughly by
        pipetting 5 times\\\"\\n            table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{30}#{MICROLITERS}\\\"}\\n            check \\\"Finally, seal plate and
        centrifuge briefly at 280 x g for 30 sec\\\"\\n        end\\n    end\\n\\n
        \   def incubate_enrich_pcr_plate(collection)\\n        show do\\n          title
        \\\"Incubate Enrichment PCR Plate #{collection}\\\"\\n          separator\\n
        \         note \\\"Place sealed plate on thermocycler \\u0026 Run: \\u003cb\\u003eEnrich\\u003c/b\\u003e\\\"\\n
        \         note \\\"Thermocycler Conditions:\\\"\\n          bullet \\\"Pre-heat
        lid to 100\xB0C\\\"\\n          bullet \\\"98\xB0C for 30 seconds\\\"\\n          note
        \\\"15 Cycles of:\\\"\\n          bullet \\\"98\xB0C for 10 seconds\\\"\\n
        \         bullet \\\"60\xB0C for 30 seconds\\\"\\n          bullet \\\"72\xB0C
        for 30 seconds\\\"\\n          bullet \\\"72\xB0C for 5 minutes\\\"\\n          note
        \\\"\\\"\\n          bullet \\\"Hold at 4\xB0C\\\"\\n        end\\n    end\\n
        \   def clean_up_enrich_pcr(collection)\\n        library_type = library_type(collection)\\n
        \       if collection.get_non_empty.length \\u003e 19\\n            sw, sw_vol_mat,
        rc_list = multichannel_vol_stripwell(collection)\\n            show do\\n
        \               title \\\"Aliquot AMPure XP Beads for Multichannel\\\"\\n
        \               separator\\n                check \\\"Vortex the AMPure Beads
        for at least 1 minute or until they are well dispersed.\\\"\\n                note
        \\\"Follow the table to aliquot the AMPure XP Beads into a stripwell for the
        next step:\\\"\\n                bullet \\\"The maximum volume in a stripwell
        well is 300#{MICROLITERS}\\\"\\n                table highlight_alpha_rc(sw,
        rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*47.5}#{MICROLITERS}\\\"}\\n            end\\n
        \           sw.mark_as_deleted\\n            sw.save\\n        end\\n        show
        do\\n            title \\\"Adding AMPure XP Beads to 96 Well MIDI Plate\\\"\\n
        \           separator\\n            check \\\"Gather a new, clean \\u003cb\\u003e96
        Well MIDI 0.8mL Plate\\u003c/b\\u003e and label: \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n
        \           note \\\"Follow the table below to aliquot the \\u003cb\\u003eAMPure
        Beads\\u003c/b\\u003e to the appropriate wells of the new plate:\\\"\\n            bullet
        \\\"Mix by pipetting up and down 10 times.\\\"\\n            table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{47.5}#{MICROLITERS}\\\"}\\n            note \\\"Continue on to the next
        step\\\"\\n        end\\n        show do\\n            title \\\"Transfering
        Enriched #{library_type} Libraries\\\"\\n            separator\\n            check
        \\\"Once the thermocycler has finished, transfer entire contents of plate
        \\u003cb\\u003e#{collection}\\u003c/b\\u003e to the correspoding well of the
        \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n            bullet
        \\\"Mix throughly by pipetting 10 times\\\"\\n            check \\\"Incubate
        plate at room temperature for 15 mins\\\"\\n            check \\\"Centrifuge
        plate at 280 x g for 1 min\\\"\\n            check \\\"Place plate on magnetic
        stand for 5 mins\\\"\\n        end\\n        show do\\n            title \\\"Clean
        Up Enriched #{library_type} Libraries\\\"\\n            separator\\n            warning
        \\\"WITH THE PLATE ON THE MAGNETIC STAND\\\"\\n            check \\\"Remove
        and discard 95#{MICROLITERS} of supernatant from each well of \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n
        \       end\\n        washes = 1\\n        (2).times do\\n            show
        do \\n                title \\\"Washing Enriched #{library_type} Libraries
        (#{washes}/2)\\\"\\n                separator\\n                note \\\"With
        the \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e on the magnetic stand,
        add \\u003cb\\u003e200#{MICROLITERS}\\u003c/b\\u003e of 80% EtOH\\\"\\n                warning
        \\\"DO NOT DISTURB THE BEADS!\\\"\\n                table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{200}#{MICROLITERS}\\\"}\\n                check \\\"Incubate for 30
        secs\\\"\\n            end\\n            show do \\n                title
        \\\"Washing Enriched #{library_type} Libraries\\\"\\n                separator\\n
        \               warning \\\"DO NOT DISTURB THE BEADS!\\\"\\n                check
        \\\"Remove and discard all of the supernatant from each well\\\"\\n            end\\n
        \           \\n            if washes == 2\\n                show do \\n                    title
        \\\"Drying Enriched #{library_type} Libraries\\\"\\n                    separator\\n
        \                   check \\\"Seal plate with a Aera Breathable seal\\\"\\n
        \                   check \\\"Let samples air-dry at room temperature for
        10 mins\\\"\\n                    bullet \\\"Place plate on plate rotator
        to expidite process and ensure drying\\\"\\n                end\\n            end\\n
        \           washes += 1\\n        end\\n        \\n        if collection.get_non_empty.length
        \\u003e 17\\n            sw, sw_vol_mat, rc_list = multichannel_vol_stripwell(collection)\\n
        \           show do\\n                title \\\"Aliquot Resuspension Buffer
        (RSB) for Multichannel\\\"\\n                separator\\n                note
        \\\"Follow the table to aliquot the Resuspension Buffer (RSB) into a stripwell
        for the next step:\\\"\\n                bullet \\\"The maximum volume in
        a stripwell well is 300#{MICROLITERS}\\\"\\n                table highlight_alpha_rc(sw,
        rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*32.5}#{MICROLITERS}\\\"}\\n            end\\n
        \           sw.mark_as_deleted\\n            sw.save\\n        end\\n        \\n
        \       show do\\n            title \\\"Eluting Indexed #{library_type} Libaries\\\"\\n
        \           separator\\n            check \\\"Remove \\u003c/b\\u003eCleanUp_#{collection}\\u003c/b\\u003e
        from magnetic plate.\\\"\\n            note \\\"Follow the table to aliquot
        Resuspension Buffer to the appropriate wells:\\\"\\n            bullet \\\"Mix
        throughly by pipetting until the beads are dispersed!\\\"\\n            table
        highlight_alpha_non_empty(collection){|r,c| \\\"#{32.5}#{MICROLITERS}\\\"}\\n
        \           check \\\"Seal plate \\u0026 incubate at room temperature for
        2 mins\\\"\\n            check \\\"Next, place plate on magnetic stand and
        incubate for 5 mins\\\"\\n            note \\\"Continue to next step while
        incubating.\\\"\\n        end\\n    end\\n    \\n    def transfer_clean_cDNA(collection)\\n
        \       library_type = library_type(collection)\\n        show do\\n            title
        \\\"Transfer clean #{library_type}\\\"\\n            separator\\n            check
        \\\"Gather a new, clean \\u003cb\\u003e96 Well PCR Plate\\u003c/b\\u003e and
        label: \\u003cb\\u003e#{collection}\\u003c/b\\u003e\\\"\\n            warning
        \\\"WITH THE PLATE ON THE MAGNETIC STAND\\\"\\n            check \\\"Transfer
        \\u003cb\\u003e30#{MICROLITERS}\\u003c/b\\u003e from each well of \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e
        to the corresponding  well of the new \\u003cb\\u003e#{collection}\\u003c/b\\u003e\\\"\\n
        \       end\\n        collection.location = \\\"-20\xB0C NGSeq Section\\\"\\n
        \       collection.save\\n    end\\n    \\nend # Module Enrich_cDNA_Fragments\\n\",\"parent_id\":201,\"parent_class\":\"Library\",\"created_at\":\"2018-10-30T21:44:14.000-07:00\",\"updated_at\":\"2018-10-30T21:44:14.000-07:00\",\"user_id\":192},{\"id\":89421,\"name\":\"source\",\"content\":\"module
        Enrich_cDNA_Fragments\\n    include Units\\n    def library_type(collection)\\n
        \       # This may have an issue with distiguishing different sample types
        in the same collection\\n        sample_type = Sample.where({\\\"id\\\": collection.matrix.flatten.select
        {|s_id| s_id != -1}}).to_a.map {|s| s.sample_type.name }.uniq.first\\n        library_type
        = (sample_type == \\\"Yeast Strain\\\") ? \\\"cDNA\\\" : \\\"DNA\\\"\\n        return
        library_type\\n    end\\n\\n    def gather_defrost_amplification_materials(collections_to_defrost)\\n
        \       # Gather the frozen plate so that it is defrosted by the time all
        the reagents are prepped\\n        take collections_to_defrost, interactive:
        true\\n        \\n        num_ops = operations.length\\n        reagents_hash
        = {\\n            'PCR Master Mix (PMM)'=\\u003e '1-2 tube(s)',\\n            'PCR
        Primer Cocktail (PPC)'=\\u003e'1-2 tube(s)',\\n            'Resuspension Buffer
        (RSB)' =\\u003e'1-2 tube(s)',\\n            'Freshly prepared 80% Ethanol'=\\u003e
        reagent_vol_with_extra(num_ops, 400),\\n            'AMPure XP Beads'=\\u003e
        reagent_vol_with_extra(num_ops, 50)\\n        }\\n        show do\\n            title
        \\\"Gather the following materials:\\\"\\n            separator\\n            note
        \\\"Let the following reagents thaw at room temperature, then immediately
        place on ice\\\"\\n            reagents_hash.each {|k, v| (k.include? 'PCR')
        ? (check \\\"#{k}\\\") : nil}\\n            note \\\"\\\\n\\\"\\n            note
        \\\"Gather the following materials:\\\"\\n            etoh_vol = reagents_hash['Freshly
        prepared 80% Ethanol']\\n            check \\\"Make 80% EtOH =\\u003e #{etoh_vol
        * 0.8}#{MICROLITERS} of 100% EtOH + #{etoh_vol * 0.2}#{MICROLITERS} of MG
        H2O\\\"\\n            check \\\"\\u003cb\\u003e1\\u003c/b\\u003e - 96 Well
        PCR Plate(s)\\\"\\n            check \\\"\\u003cb\\u003e1\\u003c/b\\u003e
        - 96 Well MIDI 0.8mL Plate(s)\\\"\\n            check \\\"\\u003cb\\u003e3\\u003c/b\\u003e
        - Adhesive Seals\\\"\\n        end\\n    end\\n    \\n    def make_pcr_master_mix()\\n
        \       num_ops = operations.length\\n        pmm_vol = 25 * num_ops\\n        ppc_vol
        = 5 * num_ops\\n        master_mix_vol = pmm_vol + ppc_vol\\n        (master_mix_vol
        \\u003e 1501) ? tubes = 2 : tubes = 1\\n        (master_mix_vol \\u003e 1501)
        ? aliquot = [pmm_vol/2, ppc_vol/2] : aliquot = [pmm_vol, ppc_vol]\\n        show
        do \\n          title \\\"Create PCR Master Mix\\\"\\n          separator\\n
        \         check \\\"Ensure that #{'PCR Master Mix (PMM)'} \\u0026 #{'PCR Primer
        Cocktail (PPC)'} are defrosted\\\"\\n          check \\\"Gather \\u003cb\\u003e#{tubes}\\u003c/b\\u003e
        1.5mL microfuge tube(s) \\u0026 label: \\u003cb\\u003eMM\\u003c/b\\u003e.\\\"\\n
        \         check \\\"In each of the microfuge tube(s), aliquot \\u003cb\\u003e#{aliquot[0]}#{MICROLITERS}
        of PMM\\u003c/b\\u003e \\u0026 \\u003cb\\u003e#{aliquot[1]}#{MICROLITERS}
        of PPC\\u003c/b\\u003e\\\"\\n          bullet \\\"Mix throughly by pipetting,
        use a multichannel pipette where possible.\\\"\\n        end\\n    end\\n
        \   \\n    def add_pcr_master_mix(collection)\\n        library_type = library_type(collection)\\n
        \       if collection.get_non_empty.length \\u003e 18\\n            sw, sw_vol_mat,
        rc_list = multichannel_vol_stripwell(collection)\\n            show do\\n
        \               title \\\"Aliquot PCR Master Mix for Multichannel\\\"\\n                separator\\n
        \               note \\\"Follow the table to aliquot the PCR Master Mix into
        a stripwell for the next step:\\\"\\n                bullet \\\"The maximum
        volume in a stripwell well is 300#{MICROLITERS}\\\"\\n                table
        highlight_alpha_rc(sw, rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*30}#{MICROLITERS}\\\"}\\n
        \           end\\n            sw.mark_as_deleted\\n            sw.save\\n
        \       end\\n        show do\\n            title \\\"Aliquoting PCR MM to
        Indexed #{library_type} Libraries\\\"\\n            separator\\n            check
        \\\"Ensure samples in plate \\u003cb\\u003e#{collection}\\u003c/b\\u003e are
        thawed.\\\"\\n            note \\\"Follow the table to aliquot the PCR Master
        Mix to the appropriate wells:\\\"\\n            bullet \\\"Mix throughly by
        pipetting 5 times\\\"\\n            table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{30}#{MICROLITERS}\\\"}\\n            check \\\"Finally, seal plate and
        centrifuge briefly at 280 x g for 30 sec\\\"\\n        end\\n    end\\n\\n
        \   def incubate_enrich_pcr_plate(collection)\\n        show do\\n          title
        \\\"Incubate Enrichment PCR Plate #{collection}\\\"\\n          separator\\n
        \         note \\\"Place sealed plate on thermocycler \\u0026 Run: \\u003cb\\u003eEnrich\\u003c/b\\u003e\\\"\\n
        \         note \\\"Thermocycler Conditions:\\\"\\n          bullet \\\"Pre-heat
        lid to 100\xB0C\\\"\\n          bullet \\\"98\xB0C for 30 seconds\\\"\\n          note
        \\\"15 Cycles of:\\\"\\n          bullet \\\"98\xB0C for 10 seconds\\\"\\n
        \         bullet \\\"60\xB0C for 30 seconds\\\"\\n          bullet \\\"72\xB0C
        for 30 seconds\\\"\\n          bullet \\\"72\xB0C for 5 minutes\\\"\\n          note
        \\\"\\\"\\n          bullet \\\"Hold at 4\xB0C\\\"\\n        end\\n    end\\n
        \   def clean_up_enrich_pcr(collection)\\n        library_type = library_type(collection)\\n
        \       if collection.get_non_empty.length \\u003e 19\\n            sw, sw_vol_mat,
        rc_list = multichannel_vol_stripwell(collection)\\n            show do\\n
        \               title \\\"Aliquot AMPure XP Beads for Multichannel\\\"\\n
        \               separator\\n                check \\\"Vortex the AMPure Beads
        for at least 1 minute or until they are well dispersed.\\\"\\n                note
        \\\"Follow the table to aliquot the AMPure XP Beads into a stripwell for the
        next step:\\\"\\n                bullet \\\"The maximum volume in a stripwell
        well is 300#{MICROLITERS}\\\"\\n                table highlight_alpha_rc(sw,
        rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*47.5}#{MICROLITERS}\\\"}\\n            end\\n
        \           sw.mark_as_deleted\\n            sw.save\\n        end\\n        show
        do\\n            title \\\"Adding AMPure XP Beads to 96 Well MIDI Plate\\\"\\n
        \           separator\\n            check \\\"Gather a new, clean \\u003cb\\u003e96
        Well MIDI 0.8mL Plate\\u003c/b\\u003e and label: \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n
        \           note \\\"Follow the table below to aliquot the \\u003cb\\u003eAMPure
        Beads\\u003c/b\\u003e to the appropriate wells of the new plate:\\\"\\n            bullet
        \\\"Mix by pipetting up and down 10 times.\\\"\\n            table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{47.5}#{MICROLITERS}\\\"}\\n            note \\\"Continue on to the next
        step\\\"\\n        end\\n        show do\\n            title \\\"Transfering
        Enriched #{library_type} Libraries\\\"\\n            separator\\n            check
        \\\"Once the thermocycler has finished, transfer entire contents of plate
        \\u003cb\\u003e#{collection}\\u003c/b\\u003e to the correspoding well of the
        \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n            bullet
        \\\"Mix throughly by pipetting 10 times\\\"\\n            check \\\"Incubate
        plate at room temperature for 15 mins\\\"\\n            check \\\"Centrifuge
        plate at 280 x g for 1 min\\\"\\n            check \\\"Place plate on magnetic
        stand for 5 mins\\\"\\n        end\\n        show do\\n            title \\\"Clean
        Up Enriched #{library_type} Libraries\\\"\\n            separator\\n            warning
        \\\"WITH THE PLATE ON THE MAGNETIC STAND\\\"\\n            check \\\"Remove
        and discard 95#{MICROLITERS} of supernatant from each well of \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n
        \       end\\n        washes = 1\\n        (2).times do\\n            show
        do \\n                title \\\"Washing Enriched #{library_type} Libraries
        (#{washes}/2)\\\"\\n                separator\\n                note \\\"With
        the \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e on the magnetic stand,
        add \\u003cb\\u003e200#{MICROLITERS}\\u003c/b\\u003e of 80% EtOH\\\"\\n                warning
        \\\"DO NOT DISTURB THE BEADS!\\\"\\n                table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{200}#{MICROLITERS}\\\"}\\n                check \\\"Incubate for 30
        secs\\\"\\n            end\\n            show do \\n                title
        \\\"Washing Enriched #{library_type} Libraries\\\"\\n                separator\\n
        \               warning \\\"DO NOT DISTURB THE BEADS!\\\"\\n                check
        \\\"Remove and discard all of the supernatant from each well\\\"\\n            end\\n
        \           \\n            if washes == 2\\n                show do \\n                    title
        \\\"Drying Enriched #{library_type} Libraries\\\"\\n                    separator\\n
        \                   check \\\"Seal plate with a Aera Breathable seal\\\"\\n
        \                   check \\\"Let samples air-dry at room temperature for
        10 mins\\\"\\n                    bullet \\\"Place plate on plate rotator
        to expidite process and ensure drying\\\"\\n                end\\n            end\\n
        \           washes += 1\\n        end\\n        \\n        if collection.get_non_empty.length
        \\u003e 19\\n            sw, sw_vol_mat, rc_list = multichannel_vol_stripwell(collection)\\n
        \           show do\\n                title \\\"Aliquot Resuspension Buffer
        (RSB) for Multichannel\\\"\\n                separator\\n                note
        \\\"Follow the table to aliquot the Resuspension Buffer (RSB) into a stripwell
        for the next step:\\\"\\n                bullet \\\"The maximum volume in
        a stripwell well is 300#{MICROLITERS}\\\"\\n                table highlight_alpha_rc(sw,
        rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*32.5}#{MICROLITERS}\\\"}\\n            end\\n
        \           sw.mark_as_deleted\\n            sw.save\\n        end\\n        \\n
        \       show do\\n            title \\\"Eluting Indexed #{library_type} Libaries\\\"\\n
        \           separator\\n            check \\\"Remove \\u003c/b\\u003eCleanUp_#{collection}\\u003c/b\\u003e
        from magnetic plate.\\\"\\n            note \\\"Follow the table to aliquot
        Resuspension Buffer to the appropriate wells:\\\"\\n            bullet \\\"Mix
        throughly by pipetting until the beads are dispersed!\\\"\\n            table
        highlight_alpha_non_empty(collection){|r,c| \\\"#{32.5}#{MICROLITERS}\\\"}\\n
        \           check \\\"Seal plate \\u0026 incubate at room temperature for
        2 mins\\\"\\n            check \\\"Next, place plate on magnetic stand and
        incubate for 5 mins\\\"\\n            note \\\"Continue to next step while
        incubating.\\\"\\n        end\\n    end\\n    \\n    def transfer_clean_cDNA(collection)\\n
        \       library_type = library_type(collection)\\n        show do\\n            title
        \\\"Transfer clean #{library_type}\\\"\\n            separator\\n            check
        \\\"Gather a new, clean \\u003cb\\u003e96 Well PCR Plate\\u003c/b\\u003e and
        label: \\u003cb\\u003e#{collection}\\u003c/b\\u003e\\\"\\n            warning
        \\\"WITH THE PLATE ON THE MAGNETIC STAND\\\"\\n            check \\\"Transfer
        \\u003cb\\u003e30#{MICROLITERS}\\u003c/b\\u003e from each well of \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e
        to the corresponding  well of the new \\u003cb\\u003e#{collection}\\u003c/b\\u003e\\\"\\n
        \       end\\n        collection.location = \\\"-20\xB0C NGSeq Section\\\"\\n
        \       collection.save\\n    end\\n    \\nend # Module Enrich_cDNA_Fragments\\n\",\"parent_id\":201,\"parent_class\":\"Library\",\"created_at\":\"2018-10-30T21:43:27.000-07:00\",\"updated_at\":\"2018-10-30T21:43:27.000-07:00\",\"user_id\":192},{\"id\":89420,\"name\":\"source\",\"content\":\"module
        Enrich_cDNA_Fragments\\n    include Units\\n    def library_type(collection)\\n
        \       # This may have an issue with distiguishing different sample types
        in the same collection\\n        sample_type = Sample.where({\\\"id\\\": collection.matrix.flatten.select
        {|s_id| s_id != -1}}).to_a.map {|s| s.sample_type.name }.uniq.first\\n        library_type
        = (sample_type == \\\"Yeast Strain\\\") ? \\\"cDNA\\\" : \\\"DNA\\\"\\n        return
        library_type\\n    end\\n\\n    def gather_defrost_amplification_materials(collections_to_defrost)\\n
        \       # Gather the frozen plate so that it is defrosted by the time all
        the reagents are prepped\\n        take collections_to_defrost, interactive:
        true\\n        \\n        num_ops = operations.length\\n        reagents_hash
        = {\\n            'PCR Master Mix (PMM)'=\\u003e '1-2 tube(s)',\\n            'PCR
        Primer Cocktail (PPC)'=\\u003e'1-2 tube(s)',\\n            'Resuspension Buffer
        (RSB)' =\\u003e'1-2 tube(s)',\\n            'Freshly prepared 80% Ethanol'=\\u003e
        reagent_vol_with_extra(num_ops, 400),\\n            'AMPure XP Beads'=\\u003e
        reagent_vol_with_extra(num_ops, 50)\\n            \\n        }\\n        show
        do\\n            title \\\"Gather the following materials:\\\"\\n            separator\\n
        \           note \\\"Let the following reagents thaw at room temperature,
        then immediately place on ice\\\"\\n            reagents_hash.each {|k, v|
        (k.include? 'PCR') ? (check \\\"#{k}\\\") : nil}\\n            note \\\"\\\\n\\\"\\n
        \           note \\\"Gather the following materials:\\\"\\n            etoh_vol
        = reagents_hash['Freshly prepared 80% Ethanol']\\n            check \\\"Make
        80% EtOH =\\u003e #{etoh_vol * 0.8}#{MICROLITERS} of 100% EtOH + #{etoh_vol
        * 0.2}#{MICROLITERS} of MG H2O\\\"\\n            check \\\"\\u003cb\\u003e1\\u003c/b\\u003e
        - 96 Well PCR Plate(s)\\\"\\n            check \\\"\\u003cb\\u003e1\\u003c/b\\u003e
        - 96 Well MIDI 0.8mL Plate(s)\\\"\\n            check \\\"\\u003cb\\u003e3\\u003c/b\\u003e
        - Adhesive Seals\\\"\\n        end\\n    end\\n    \\n    def make_pcr_master_mix()\\n
        \       num_ops = operations.length\\n        pmm_vol = 25 * num_ops\\n        ppc_vol
        = 5 * num_ops\\n        master_mix_vol = pmm_vol + ppc_vol\\n        (master_mix_vol
        \\u003e 1501) ? tubes = 2 : tubes = 1\\n        (master_mix_vol \\u003e 1501)
        ? aliquot = [pmm_vol/2, ppc_vol/2] : aliquot = [pmm_vol, ppc_vol]\\n        show
        do \\n          title \\\"Create PCR Master Mix\\\"\\n          separator\\n
        \         check \\\"Ensure that #{'PCR Master Mix (PMM)'} \\u0026 #{'PCR Primer
        Cocktail (PPC)'} are defrosted\\\"\\n          check \\\"Gather \\u003cb\\u003e#{tubes}\\u003c/b\\u003e
        1.5mL microfuge tube(s) \\u0026 label: \\u003cb\\u003eMM\\u003c/b\\u003e.\\\"\\n
        \         check \\\"In each of the microfuge tube(s), aliquot \\u003cb\\u003e#{aliquot[0]}#{MICROLITERS}
        of PMM\\u003c/b\\u003e \\u0026 \\u003cb\\u003e#{aliquot[1]}#{MICROLITERS}
        of PPC\\u003c/b\\u003e\\\"\\n          bullet \\\"Mix throughly by pipetting,
        use a multichannel pipette where possible.\\\"\\n        end\\n    end\\n
        \   \\n    def add_pcr_master_mix(collection)\\n        library_type = library_type(collection)\\n
        \       if collection.get_non_empty.length \\u003e 18\\n            sw, sw_vol_mat,
        rc_list = multichannel_vol_stripwell(collection)\\n            show do\\n
        \               title \\\"Aliquot PCR Master Mix for Multichannel\\\"\\n                separator\\n
        \               note \\\"Follow the table to aliquot the PCR Master Mix into
        a stripwell for the next step:\\\"\\n                bullet \\\"The maximum
        volume in a stripwell well is 300#{MICROLITERS}\\\"\\n                table
        highlight_alpha_rc(sw, rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*30}#{MICROLITERS}\\\"}\\n
        \           end\\n            sw.mark_as_deleted\\n            sw.save\\n
        \       end\\n        show do\\n            title \\\"Aliquoting PCR MM to
        Indexed #{library_type} Libraries\\\"\\n            separator\\n            check
        \\\"Ensure samples in plate \\u003cb\\u003e#{collection}\\u003c/b\\u003e are
        thawed.\\\"\\n            note \\\"Follow the table to aliquot the PCR Master
        Mix to the appropriate wells:\\\"\\n            bullet \\\"Mix throughly by
        pipetting 5 times\\\"\\n            table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{30}#{MICROLITERS}\\\"}\\n            check \\\"Finally, seal plate and
        centrifuge briefly at 280 x g for 30 sec\\\"\\n        end\\n    end\\n\\n
        \   def incubate_enrich_pcr_plate(collection)\\n        show do\\n          title
        \\\"Incubate Enrichment PCR Plate #{collection}\\\"\\n          separator\\n
        \         note \\\"Place sealed plate on thermocycler \\u0026 Run: \\u003cb\\u003eEnrich\\u003c/b\\u003e\\\"\\n
        \         note \\\"Thermocycler Conditions:\\\"\\n          bullet \\\"Pre-heat
        lid to 100\xB0C\\\"\\n          bullet \\\"98\xB0C for 30 seconds\\\"\\n          note
        \\\"15 Cycles of:\\\"\\n          bullet \\\"98\xB0C for 10 seconds\\\"\\n
        \         bullet \\\"60\xB0C for 30 seconds\\\"\\n          bullet \\\"72\xB0C
        for 30 seconds\\\"\\n          bullet \\\"72\xB0C for 5 minutes\\\"\\n          note
        \\\"\\\"\\n          bullet \\\"Hold at 4\xB0C\\\"\\n        end\\n    end\\n
        \   def clean_up_enrich_pcr(collection)\\n        library_type = library_type(collection)\\n
        \       if collection.get_non_empty.length \\u003e 19\\n            sw, sw_vol_mat,
        rc_list = multichannel_vol_stripwell(collection)\\n            show do\\n
        \               title \\\"Aliquot AMPure XP Beads for Multichannel\\\"\\n
        \               separator\\n                check \\\"Vortex the AMPure Beads
        for at least 1 minute or until they are well dispersed.\\\"\\n                note
        \\\"Follow the table to aliquot the AMPure XP Beads into a stripwell for the
        next step:\\\"\\n                bullet \\\"The maximum volume in a stripwell
        well is 300#{MICROLITERS}\\\"\\n                table highlight_alpha_rc(sw,
        rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*47.5}#{MICROLITERS}\\\"}\\n            end\\n
        \           sw.mark_as_deleted\\n            sw.save\\n        end\\n        show
        do\\n            title \\\"Adding AMPure XP Beads to 96 Well MIDI Plate\\\"\\n
        \           separator\\n            check \\\"Gather a new, clean \\u003cb\\u003e96
        Well MIDI 0.8mL Plate\\u003c/b\\u003e and label: \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n
        \           note \\\"Follow the table below to aliquot the \\u003cb\\u003eAMPure
        Beads\\u003c/b\\u003e to the appropriate wells of the new plate:\\\"\\n            bullet
        \\\"Mix by pipetting up and down 10 times.\\\"\\n            table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{47.5}#{MICROLITERS}\\\"}\\n            note \\\"Continue on to the next
        step\\\"\\n        end\\n        show do\\n            title \\\"Transfering
        Enriched #{library_type} Libraries\\\"\\n            separator\\n            check
        \\\"Once the thermocycler has finished, transfer entire contents of plate
        \\u003cb\\u003e#{collection}\\u003c/b\\u003e to the correspoding well of the
        \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n            bullet
        \\\"Mix throughly by pipetting 10 times\\\"\\n            check \\\"Incubate
        plate at room temperature for 15 mins\\\"\\n            check \\\"Centrifuge
        plate at 280 x g for 1 min\\\"\\n            check \\\"Place plate on magnetic
        stand for 5 mins\\\"\\n        end\\n        show do\\n            title \\\"Clean
        Up Enriched #{library_type} Libraries\\\"\\n            separator\\n            warning
        \\\"WITH THE PLATE ON THE MAGNETIC STAND\\\"\\n            check \\\"Remove
        and discard 95#{MICROLITERS} of supernatant from each well of \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n
        \       end\\n        washes = 1\\n        (2).times do\\n            show
        do \\n                title \\\"Washing Enriched #{library_type} Libraries
        (#{washes}/2)\\\"\\n                separator\\n                note \\\"With
        the \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e on the magnetic stand,
        add \\u003cb\\u003e200#{MICROLITERS}\\u003c/b\\u003e of 80% EtOH\\\"\\n                warning
        \\\"DO NOT DISTURB THE BEADS!\\\"\\n                table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{200}#{MICROLITERS}\\\"}\\n                check \\\"Incubate for 30
        secs\\\"\\n            end\\n            show do \\n                title
        \\\"Washing Enriched #{library_type} Libraries\\\"\\n                separator\\n
        \               warning \\\"DO NOT DISTURB THE BEADS!\\\"\\n                check
        \\\"Remove and discard all of the supernatant from each well\\\"\\n            end\\n
        \           \\n            if washes == 2\\n                show do \\n                    title
        \\\"Drying Enriched #{library_type} Libraries\\\"\\n                    separator\\n
        \                   check \\\"Seal plate with a Aera Breathable seal\\\"\\n
        \                   check \\\"Let samples air-dry at room temperature for
        10 mins\\\"\\n                    bullet \\\"Place plate on plate rotator
        to expidite process and ensure drying\\\"\\n                end\\n            end\\n
        \           washes += 1\\n        end\\n        \\n        if collection.get_non_empty.length
        \\u003e 19\\n            sw, sw_vol_mat, rc_list = multichannel_vol_stripwell(collection)\\n
        \           show do\\n                title \\\"Aliquot Resuspension Buffer
        (RSB) for Multichannel\\\"\\n                separator\\n                note
        \\\"Follow the table to aliquot the Resuspension Buffer (RSB) into a stripwell
        for the next step:\\\"\\n                bullet \\\"The maximum volume in
        a stripwell well is 300#{MICROLITERS}\\\"\\n                table highlight_alpha_rc(sw,
        rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*32.5}#{MICROLITERS}\\\"}\\n            end\\n
        \           sw.mark_as_deleted\\n            sw.save\\n        end\\n        \\n
        \       show do\\n            title \\\"Eluting Indexed #{library_type} Libaries\\\"\\n
        \           separator\\n            check \\\"Remove \\u003c/b\\u003eCleanUp_#{collection}\\u003c/b\\u003e
        from magnetic plate.\\\"\\n            note \\\"Follow the table to aliquot
        Resuspension Buffer to the appropriate wells:\\\"\\n            bullet \\\"Mix
        throughly by pipetting until the beads are dispersed!\\\"\\n            table
        highlight_alpha_non_empty(collection){|r,c| \\\"#{32.5}#{MICROLITERS}\\\"}\\n
        \           check \\\"Seal plate \\u0026 incubate at room temperature for
        2 mins\\\"\\n            check \\\"Next, place plate on magnetic stand and
        incubate for 5 mins\\\"\\n            note \\\"Continue to next step while
        incubating.\\\"\\n        end\\n    end\\n    \\n    def transfer_clean_cDNA(collection)\\n
        \       library_type = library_type(collection)\\n        show do\\n            title
        \\\"Transfer clean #{library_type}\\\"\\n            separator\\n            check
        \\\"Gather a new, clean \\u003cb\\u003e96 Well PCR Plate\\u003c/b\\u003e and
        label: \\u003cb\\u003e#{collection}\\u003c/b\\u003e\\\"\\n            warning
        \\\"WITH THE PLATE ON THE MAGNETIC STAND\\\"\\n            check \\\"Transfer
        \\u003cb\\u003e30#{MICROLITERS}\\u003c/b\\u003e from each well of \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e
        to the corresponding  well of the new \\u003cb\\u003e#{collection}\\u003c/b\\u003e\\\"\\n
        \       end\\n        collection.location = \\\"-20\xB0C NGSeq Section\\\"\\n
        \       collection.save\\n    end\\n    \\nend # Module Enrich_cDNA_Fragments\\n\",\"parent_id\":201,\"parent_class\":\"Library\",\"created_at\":\"2018-10-30T21:37:41.000-07:00\",\"updated_at\":\"2018-10-30T21:37:41.000-07:00\",\"user_id\":192},{\"id\":89419,\"name\":\"source\",\"content\":\"module
        Enrich_cDNA_Fragments\\n    include Units\\n    def library_type(collection)\\n
        \       # This may have an issue with distiguishing different sample types
        in the same collection\\n        sample_type = Sample.where({\\\"id\\\": collection.matrix.flatten.select
        {|s_id| s_id != -1}}).to_a.map {|s| s.sample_type.name }.uniq.first\\n        library_type
        = (sample_type == \\\"Yeast Strain\\\") ? \\\"cDNA\\\" : \\\"DNA\\\"\\n        return
        library_type\\n    end\\n\\n    def gather_defrost_amplification_materials(collections_to_defrost)\\n
        \       # Gather the frozen plate so that it is defrosted by the time all
        the reagents are prepped\\n        take collections_to_defrost, interactive:
        true\\n        \\n        num_ops = operations.length\\n        reagents_hash
        = {\\n            'PCR Master Mix (PMM)'=\\u003e '1-2 tube(s)',\\n            'PCR
        Primer Cocktail (PPC)'=\\u003e'1-2 tube(s)',\\n            'Resuspension Buffer
        (RSB)' =\\u003e'1-2 tube(s)',\\n            'Freshly prepared 80% Ethanol'=\\u003e
        reagent_vol_with_extra(num_ops, 400),\\n            'AMPure XP Beads'=\\u003e
        reagent_vol_with_extra(num_ops, 50)\\n            \\n        }\\n        show
        do\\n            title \\\"Gather the following materials:\\\"\\n            separator\\n
        \           note \\\"Let the following reagents thaw at room temperature,
        then immediately place on ice\\\"\\n            reagents_hash.each {|k, v|
        (k.include? 'PCR') ? (check \\\"#{k}\\\") : nil}\\n            note \\\"\\\\n\\\"\\n
        \           note \\\"Gather the following materials:\\\"\\n            etoh_vol
        = reagents_hash['Freshly prepared 80% Ethanol']\\n            check \\\"Make
        80% EtOH =\\u003e #{etoh_vol * 0.8}#{MICROLITERS} of 100% EtOH + #{etoh_vol
        * 0.2}#{MICROLITERS} of MG H2O\\\"\\n            check \\\"\\u003cb\\u003e1\\u003c/b\\u003e
        - 96 Well PCR Plate(s)\\\"\\n            check \\\"\\u003cb\\u003e1\\u003c/b\\u003e
        - 96 Well MIDI 0.8mL Plate(s)\\\"\\n            check \\\"\\u003cb\\u003e3\\u003c/b\\u003e
        - Adhesive Seals\\\"\\n        end\\n    end\\n    \\n    def make_pcr_master_mix()\\n
        \       num_ops = operations.length\\n        pmm_vol = 25 * num_ops\\n        ppc_vol
        = 5 * num_ops\\n        master_mix_vol = pmm_vol + ppc_vol\\n        (master_mix_vol
        \\u003e 1501) ? tubes = 2 : tubes = 1\\n        (master_mix_vol \\u003e 1501)
        ? aliquot = [pmm_vol/2, ppc_vol/2] : aliquot = [pmm_vol, ppc_vol]\\n        show
        do \\n          title \\\"Create PCR Master Mix\\\"\\n          separator\\n
        \         check \\\"Ensure that #{'PCR Master Mix (PMM)'} \\u0026 #{'PCR Primer
        Cocktail (PPC)'} are defrosted\\\"\\n          check \\\"Gather \\u003cb\\u003e#{tubes}\\u003c/b\\u003e
        1.5mL microfuge tube(s) \\u0026 label: \\u003cb\\u003eMM\\u003c/b\\u003e.\\\"\\n
        \         check \\\"In each of the microfuge tube(s), aliquot \\u003cb\\u003e#{aliquot[0]}#{MICROLITERS}
        of PMM\\u003c/b\\u003e \\u0026 \\u003cb\\u003e#{aliquot[1]}#{MICROLITERS}
        of PPC\\u003c/b\\u003e\\\"\\n          bullet \\\"Mix throughly by pipetting.\\\"\\n
        \       end\\n    end\\n    \\n    def add_pcr_master_mix(collection)\\n        library_type
        = library_type(collection)\\n        if collection.get_non_empty.length \\u003e
        18\\n            sw, sw_vol_mat, rc_list = multichannel_vol_stripwell(collection)\\n
        \           show do\\n                title \\\"Aliquot PCR Master Mix for
        Multichannel\\\"\\n                separator\\n                note \\\"Follow
        the table to aliquot the PCR Master Mix into a stripwell for the next step:\\\"\\n
        \               bullet \\\"The maximum volume in a stripwell well is 300#{MICROLITERS}\\\"\\n
        \               table highlight_alpha_rc(sw, rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*30}#{MICROLITERS}\\\"}\\n
        \           end\\n            sw.mark_as_deleted\\n            sw.save\\n
        \       end\\n        show do\\n            title \\\"Aliquoting PCR MM to
        Indexed #{library_type} Libraries\\\"\\n            separator\\n            check
        \\\"Ensure samples in plate \\u003cb\\u003e#{collection}\\u003c/b\\u003e are
        thawed.\\\"\\n            note \\\"Follow the table to aliquot the PCR Master
        Mix to the appropriate wells:\\\"\\n            bullet \\\"Mix throughly by
        pipetting 5 times\\\"\\n            table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{30}#{MICROLITERS}\\\"}\\n            check \\\"Finally, seal plate and
        centrifuge briefly at 280 x g for 30 sec\\\"\\n        end\\n    end\\n\\n
        \   def incubate_enrich_pcr_plate(collection)\\n        show do\\n          title
        \\\"Incubate Enrichment PCR Plate #{collection}\\\"\\n          separator\\n
        \         note \\\"Place sealed plate on thermocycler \\u0026 Run: \\u003cb\\u003eEnrich\\u003c/b\\u003e\\\"\\n
        \         note \\\"Thermocycler Conditions:\\\"\\n          bullet \\\"Pre-heat
        lid to 100\xB0C\\\"\\n          bullet \\\"98\xB0C for 30 seconds\\\"\\n          note
        \\\"15 Cycles of:\\\"\\n          bullet \\\"98\xB0C for 10 seconds\\\"\\n
        \         bullet \\\"60\xB0C for 30 seconds\\\"\\n          bullet \\\"72\xB0C
        for 30 seconds\\\"\\n          bullet \\\"72\xB0C for 5 minutes\\\"\\n          note
        \\\"\\\"\\n          bullet \\\"Hold at 4\xB0C\\\"\\n        end\\n    end\\n
        \   def clean_up_enrich_pcr(collection)\\n        library_type = library_type(collection)\\n
        \       if collection.get_non_empty.length \\u003e 19\\n            sw, sw_vol_mat,
        rc_list = multichannel_vol_stripwell(collection)\\n            show do\\n
        \               title \\\"Aliquot AMPure XP Beads for Multichannel\\\"\\n
        \               separator\\n                check \\\"Vortex the AMPure Beads
        for at least 1 minute or until they are well dispersed.\\\"\\n                note
        \\\"Follow the table to aliquot the AMPure XP Beads into a stripwell for the
        next step:\\\"\\n                bullet \\\"The maximum volume in a stripwell
        well is 300#{MICROLITERS}\\\"\\n                table highlight_alpha_rc(sw,
        rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*47.5}#{MICROLITERS}\\\"}\\n            end\\n
        \           sw.mark_as_deleted\\n            sw.save\\n        end\\n        show
        do\\n            title \\\"Adding AMPure XP Beads to 96 Well MIDI Plate\\\"\\n
        \           separator\\n            check \\\"Gather a new, clean \\u003cb\\u003e96
        Well MIDI 0.8mL Plate\\u003c/b\\u003e and label: \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n
        \           note \\\"Follow the table below to aliquot the \\u003cb\\u003eAMPure
        Beads\\u003c/b\\u003e to the appropriate wells of the new plate:\\\"\\n            bullet
        \\\"Mix by pipetting up and down 10 times.\\\"\\n            table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{47.5}#{MICROLITERS}\\\"}\\n            note \\\"Continue on to the next
        step\\\"\\n        end\\n        show do\\n            title \\\"Transfering
        Enriched #{library_type} Libraries\\\"\\n            separator\\n            check
        \\\"Once the thermocycler has finished, transfer entire contents of plate
        \\u003cb\\u003e#{collection}\\u003c/b\\u003e to the correspoding well of the
        \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n            bullet
        \\\"Mix throughly by pipetting 10 times\\\"\\n            check \\\"Incubate
        plate at room temperature for 15 mins\\\"\\n            check \\\"Centrifuge
        plate at 280 x g for 1 min\\\"\\n            check \\\"Place plate on magnetic
        stand for 5 mins\\\"\\n        end\\n        show do\\n            title \\\"Clean
        Up Enriched #{library_type} Libraries\\\"\\n            separator\\n            warning
        \\\"WITH THE PLATE ON THE MAGNETIC STAND\\\"\\n            check \\\"Remove
        and discard 95#{MICROLITERS} of supernatant from each well of \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e\\\"\\n
        \       end\\n        washes = 1\\n        (2).times do\\n            show
        do \\n                title \\\"Washing Enriched #{library_type} Libraries
        (#{washes}/2)\\\"\\n                separator\\n                note \\\"With
        the \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e on the magnetic stand,
        add \\u003cb\\u003e200#{MICROLITERS}\\u003c/b\\u003e of 80% EtOH\\\"\\n                warning
        \\\"DO NOT DISTURB THE BEADS!\\\"\\n                table highlight_alpha_non_empty(collection){|r,c|
        \\\"#{200}#{MICROLITERS}\\\"}\\n                check \\\"Incubate for 30
        secs\\\"\\n            end\\n            show do \\n                title
        \\\"Washing Enriched #{library_type} Libraries\\\"\\n                separator\\n
        \               warning \\\"DO NOT DISTURB THE BEADS!\\\"\\n                check
        \\\"Remove and discard all of the supernatant from each well\\\"\\n            end\\n
        \           \\n            if washes == 2\\n                show do \\n                    title
        \\\"Drying Enriched #{library_type} Libraries\\\"\\n                    separator\\n
        \                   check \\\"Seal plate with a Aera Breathable seal\\\"\\n
        \                   check \\\"Let samples air-dry at room temperature for
        10 mins\\\"\\n                    bullet \\\"Place plate on plate rotator
        to expidite process and ensure drying\\\"\\n                end\\n            end\\n
        \           washes += 1\\n        end\\n        \\n        if collection.get_non_empty.length
        \\u003e 19\\n            sw, sw_vol_mat, rc_list = multichannel_vol_stripwell(collection)\\n
        \           show do\\n                title \\\"Aliquot Resuspension Buffer
        (RSB) for Multichannel\\\"\\n                separator\\n                note
        \\\"Follow the table to aliquot the Resuspension Buffer (RSB) into a stripwell
        for the next step:\\\"\\n                bullet \\\"The maximum volume in
        a stripwell well is 300#{MICROLITERS}\\\"\\n                table highlight_alpha_rc(sw,
        rc_list){|r,c| \\\"#{sw_vol_mat[r][c]*32.5}#{MICROLITERS}\\\"}\\n            end\\n
        \           sw.mark_as_deleted\\n            sw.save\\n        end\\n        \\n
        \       show do\\n            title \\\"Eluting Indexed #{library_type} Libaries\\\"\\n
        \           separator\\n            check \\\"Remove \\u003c/b\\u003eCleanUp_#{collection}\\u003c/b\\u003e
        from magnetic plate.\\\"\\n            note \\\"Follow the table to aliquot
        Resuspension Buffer to the appropriate wells:\\\"\\n            bullet \\\"Mix
        throughly by pipetting until the beads are dispersed!\\\"\\n            table
        highlight_alpha_non_empty(collection){|r,c| \\\"#{32.5}#{MICROLITERS}\\\"}\\n
        \           check \\\"Seal plate \\u0026 incubate at room temperature for
        2 mins\\\"\\n            check \\\"Next, place plate on magnetic stand and
        incubate for 5 mins\\\"\\n            note \\\"Continue to next step while
        incubating.\\\"\\n        end\\n    end\\n    \\n    def transfer_clean_cDNA(collection)\\n
        \       library_type = library_type(collection)\\n        show do\\n            title
        \\\"Transfer clean #{library_type}\\\"\\n            separator\\n            check
        \\\"Gather a new, clean \\u003cb\\u003e96 Well PCR Plate\\u003c/b\\u003e and
        label: \\u003cb\\u003e#{collection}\\u003c/b\\u003e\\\"\\n            warning
        \\\"WITH THE PLATE ON THE MAGNETIC STAND\\\"\\n            check \\\"Transfer
        \\u003cb\\u003e30#{MICROLITERS}\\u003c/b\\u003e from each well of \\u003cb\\u003eCleanUp_#{collection}\\u003c/b\\u003e
        to the corresponding  well of the new \\u003cb\\u003e#{collection}\\u003c/b\\u003e\\\"\\n
        \       end\\n        collection.location = \\\"-20\xB0C NGSeq Section\\\"\\n
        \       collection.save\\n    end\\n    \\nend # Module Enrich_cDNA_Fragments\\n\",\"parent_id\":201,\"parent_class\":\"Library\",\"created_at\":\"2018-10-30T21:32:17.000-07:00\",\"updated_at\":\"2018-10-30T21:32:17.000-07:00\",\"user_id\":192}]"}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:05:19 GMT']
      ETag: [W/"098f6102b144a254b6e49d30bb88bfc1"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=%2FPDK%2F%2FCpQpQd4uUNWWhI247lQ%2BQKwrs59qqsDS4oT1a8nCnGUB12LsLSpZNAKTnGT2X2H4Nc6FSTN3PR5SQcKQ%3D%3D;
          path=/, _aquarium_NURSERY_production_session=aitscHJnN2MrWEp0RTBXazZFTTQ5b0tiOS9xRCsxYmZoMkF6NlJWbFhHNGdBNmUxSmxCc1VBZ0hORUFMQktKb3pFRllYUjNldUsxc1plRmhUNG9ZaCtZTWhhb3lYWlN0QVkxdFBGQURXazNqa2lqV3lBanJXZFY1TUNLZFBVamN2ME83NStzdEdiQ3ZQWDdPN1M4MklHUWdmcWlzQ2lXRG0xSzY0NzJNQkFjeXM5UmFsdzZRNGg4Uk9FM3hZMjI3TGJ0eDZQWUFKNVRzTkJyUjEycjlPQUIvV0RlTWNmdW5yNnU1NS9DV3lnRTVkcTVmZmJGRDRYMXBzWWZOQjFESWxWdEkwUUp4Y3oxeWM3WFJWdXk4VFhwTFVuS3dLay9BL1NSSWJtZ0FZMUV5RzlhYSt3dnFPR2piS2tJdUUweWV4a1pvRDJLOXFQRS90Z1k4QmIzbUt0SGJqUGp5TWNXbmdnWnhWTVlVd2RGZkRUWUNGRENGM3YrZlBhQ20rK2dPckV3RHhHSXk3ekwrdy8wN1k5WGNqMGlBWGJpVkhVTzVaN04rN2gyS1lITT0tLWZGT1IrbktzK2Joa2xGWTgrZHpRdWc9PQ%3D%3D--47b63ba8fb27d211c21ae8652d079cb7ffde672e;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [7a8d7c49-95ae-43fc-919f-8b537840ed69]
      X-Runtime: ['0.060632']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Library", "id": 201}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['31']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=jBrGDiu1OpVEhaFfs%2B1A5x3s2q8xFx7AhFAF33vWPuTMdiU3iwEOL5u14cGqrDH63GxvVLiJTa3hzdoDsNptmw%3D%3D;
          _aquarium_NURSERY_production_session=djVDcUNuZ2FaQ1VDV0RRUFYvc0Q2UHpreTdoOHJjdlh3NWQxNGxyeW04M0sxSVQ5d3hIbHZRWlJtbjFnUWF1VmRmejBsNUZLMTVVR3FITmtUTFd1eGRqZkRmdGVCVmFmMElQQUl1WFZEbk85UTRhem9qL2FId2JvR3lZTEk5VjJmYmJnQVVENkh1d2ZBTkkrb1NzUDF0V2F6d1VRc2xhZFVPRkpTY0xuTDk4V3I3cWF5R2loaHNCVm1sWW1IMkdUSXB0RWhVL0IvTTRkU1dNcW94MzFMZnIxSTRwY1lRd3ZJekV5L0Fpd0FXU1ZIZjZQU2ZjdUVxK1VmU1FEVyswM2JCUkdmTi8yN2Fuemg0Z1cyUTV5K2VOTFZCOWpIMFd3LzhRNW1nQkliRjB0M2QyYjNDanFXSDdiTFp6clBjRWpqcGdMM1VKVVBpdVl6VHdkSytONzFvZVNPNEFETTQxdEdXNG83dmcvREVRdmZxbjdqSzE2NHRLMldsZktGUVR0eHlkcjNCM2lDRUdNYjdQVG5zcWVRV1M3cGdWSU10QnVBTm04WURxcWc4WT0tLTRRU2dGM0VmVTVTTzZTbzJKc0FaOXc9PQ%3D%3D--6248b7b24b4e69c33ab6586d4476c2e8dc1a73a3;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":201,"name":"Enrich_cDNA_Fragments","category":"Illumina
        NGS Libs","created_at":"2018-09-28T10:27:59.000-07:00","updated_at":"2018-09-28T10:28:13.000-07:00"}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:05:19 GMT']
      ETag: [W/"2457128173bf7ed36564ab13d4b632c2"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=cN9VoZmAbKJW5r4jq9Pn%2BtOR0ZCH3%2FogIiJZfatWRxcws7aYOTRYGInW%2Fr2ykpbnEhFkaw5BqU1Hv4ahYFoUaA%3D%3D;
          path=/, _aquarium_NURSERY_production_session=ZDhaVHI1WjNKMFg0ZVFsd0V0VTdsZmJGdzQ5WkpnenJDTXRVZEJnelVWWVhLSXVUT01CNnh2bjJ0NVZDMVV5QUVWck1pNEg5T0dlK3RqL1hMblk1Q1RnRi9ZTzJlcVA2UFpwVjg5eTd0UlFDSnRTc1lVR3ZaR1VSV1JieWN3WU85TERITHl6YUFhYTFBUlc5dklFYkIwcnorY3JXaVIwU1lJK0VnT1g3dmVwMDdqdnZydDlFT1RlWi9NbG8wVXVJT2hVbU50MElVZlJXdkNKcTFtL0w2VU9VSUhDZEhFMW9WR3ovcWt5dHE5aUlLQkNSUXpQNWhteXl6SnFZTVptL2FhdUsxU3kzVHBVTW45S3R0eVFOellKMnkraHRtN1lVSkRGaU9ZM010NHowa1dicXc5cS9WT1RyS1kzczUybXJkUVVmMUlYeG5uR1pDUUovRmVqbEJ3OENUVG9RM0hsVlNqTFN4aXBsS1A5REpLV0k4VHI1U3lPYnZOUGUyZjFtWm9QVGNvQnJMSFNnSE4wVmJQdHp0bzhCMWtlR3ltUkFiODZoK3E4bUh2VT0tLVVUNUcwQ0J4ekl2b01vTjFEcWRUMGc9PQ%3D%3D--80d9dcb17eda71afab2227553aa27f1d4244e538;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [8f951c8c-fede-4da6-b53a-9dadaf8f2cc0]
      X-Runtime: ['0.003361']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Library", "id": 201}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['31']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=jBrGDiu1OpVEhaFfs%2B1A5x3s2q8xFx7AhFAF33vWPuTMdiU3iwEOL5u14cGqrDH63GxvVLiJTa3hzdoDsNptmw%3D%3D;
          _aquarium_NURSERY_production_session=djVDcUNuZ2FaQ1VDV0RRUFYvc0Q2UHpreTdoOHJjdlh3NWQxNGxyeW04M0sxSVQ5d3hIbHZRWlJtbjFnUWF1VmRmejBsNUZLMTVVR3FITmtUTFd1eGRqZkRmdGVCVmFmMElQQUl1WFZEbk85UTRhem9qL2FId2JvR3lZTEk5VjJmYmJnQVVENkh1d2ZBTkkrb1NzUDF0V2F6d1VRc2xhZFVPRkpTY0xuTDk4V3I3cWF5R2loaHNCVm1sWW1IMkdUSXB0RWhVL0IvTTRkU1dNcW94MzFMZnIxSTRwY1lRd3ZJekV5L0Fpd0FXU1ZIZjZQU2ZjdUVxK1VmU1FEVyswM2JCUkdmTi8yN2Fuemg0Z1cyUTV5K2VOTFZCOWpIMFd3LzhRNW1nQkliRjB0M2QyYjNDanFXSDdiTFp6clBjRWpqcGdMM1VKVVBpdVl6VHdkSytONzFvZVNPNEFETTQxdEdXNG83dmcvREVRdmZxbjdqSzE2NHRLMldsZktGUVR0eHlkcjNCM2lDRUdNYjdQVG5zcWVRV1M3cGdWSU10QnVBTm04WURxcWc4WT0tLTRRU2dGM0VmVTVTTzZTbzJKc0FaOXc9PQ%3D%3D--6248b7b24b4e69c33ab6586d4476c2e8dc1a73a3;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":201,"name":"Enrich_cDNA_Fragments","category":"Illumina
        NGS Libs","created_at":"2018-09-28T10:27:59.000-07:00","updated_at":"2018-09-28T10:28:13.000-07:00"}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:05:20 GMT']
      ETag: [W/"2457128173bf7ed36564ab13d4b632c2"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=Z%2BDqJhdiy%2FyjM07yItGPoAh1hxu6LgU%2BRz63%2Blxd3XAnjAkft9b%2FRnwDDmw7kP69yfUy4DOwVlMio2gml1GODw%3D%3D;
          path=/, _aquarium_NURSERY_production_session=SHV2UUlqTUltbzZYQ250ZVRlTFNVdWV4U2taNU1lZzhKWnc2dXhMZVZxMEI2OHJhcSs1WEU2RUlEeWFZMDJRRTZKczhvNmlTNmtGWGxleEppRFlKd2M4L1pTMFJyZjBLVmFBZE1lTzlwVXRqU3FsUnZxUzV4aDJxcDZWdVFYeWJXQ0hFL20rcHdpTXNOZnNGY2poMGk2TXVCanR6eVorVEhadTQzc09KdXFtM0Z0T2RvclFkQ0ZwUVdEbStObU5HMno2WFFjNXpEblp6OUdBb3pZbWFnMEw1djhta2pMSVo1ZWRNQm1hNm45K2FuTjhPN0p2VHkzVmF0a29jVVJPcGRXVnVkRk13TW1TKzBRMTIxejB6Rno5cGF6NUY0MGxrQUtPVHFhVkhwQ2djWE9XZmMyT2tOZWNic0IxQlpoTWc2WlVweUVOK2phYkFMQnhvUURrbXErZ0s2U1JaeDNURnRIVlhaRGhNa2ZYU2diaDA1am15c0ZoSkFXLzB3NEtRTHJsc21wUVNZOUdXUzBYc3lpQmFTdEdGSTk0K21TcjIxNU5VaWtXQndzbz0tLVlra2RDNWxKajFSNE5JREFCTVArdHc9PQ%3D%3D--721d6fb90b1263d3dbab80019515df51820f28f5;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [6138a384-fed9-487e-a877-3a906897a5b3]
      X-Runtime: ['0.003572']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Code", "method": "where", "arguments": {}, "options": {"offset":
      -1, "limit": 1, "reverse": true}}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['109']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=2QNtO1N0bl%2B3yxjyfU1ld0Fnm1YIhnAjaMIwMNKH4TPUTUi%2BWWIYOYLG4Uf8%2BqXWn4ZXv87DBOMjxRpbqE2gXw%3D%3D;
          _aquarium_NURSERY_production_session=SFAvRjNUS3MrZ0hrYkx2ZnRSTkRzbXVsa3NBOW1FRlF5WEplYUJDRHdtdWU0Q042RUtNdVJ6K1ZMZUJrSGNtazJkMk5BSEQ2ZDNKY2lSRTNObWgyY3Rpa3c1SlltYUV3cXZFWGN4eEtXWU9oVGU0enJST1grQk03elFCbE1NcFErNDdVSXNSNXFXcFVYai95YWZQb3cyaXZhUlFwTFpDZ2FlaEZ5WCtLNHVSQndTRDRtVnpFQmNRWERSVHh2a2ZFYnFabTVlM3NTaTh5RVhjMHduT3JkdU9OcFgyRlp5emlPZTNpTEt3U2w4bEkzV3pwRDNkemh0aE9FZVBreHdRT1A5OHpJLzQ5Uzl0N0VoTGVjbGY2QjYvQmFlYzg2KzE3Ui9FdjdHV012REhQUlJSZ0NaNmgwcUpRV1VNL2k5ZGlJUTk2bWt5dDNZdUgyMEpodjlud1M1WWtxZEZsWUxVNjk0RG9zcGF5b014cXdqakl2ZlRSTWVPeElSS1I3akRSMmtKVWx5ZmF2aE5ub1JWZ3J6T1RSSlJMakN0M3BKaDBEMlV1SXJ4Nll2RT0tLU1HUlhYaVhRZXM2OFJKVHFVQTBkbGc9PQ%3D%3D--20cb56d069c12bf7e639948514c5af354bf4dd7d;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: "[{\"id\":89429,\"name\":\"protocol\",\"content\":\"needs \\\"Cloning
        Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds 'Standard
        Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n    \\n
        \ # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # Add association from which item
        the 1ng/ul dilution came from\\n    ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].associate(:diluted_from,
        op.input(input).item.id) }\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1460,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T13:38:11.000-07:00\",\"updated_at\":\"2018-10-31T13:38:11.000-07:00\",\"user_id\":192}]"}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:09:13 GMT']
      ETag: [W/"1c9c3a3782770c01a7dd4af9f5cf70a0"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=d1smzZ5Lv%2B7QX8im8UL1hztKvdj8%2FZors8le1se7BE56FQNIlF3JiOVSMRNw9TUm5atxMTq47uv4znS9vXFFIg%3D%3D;
          path=/, _aquarium_NURSERY_production_session=b3h3R2Q3REZraEp6WmZhckdCUUZwTVBZV2FiV1N5VXkwK2dlRXlXekFHbkhQV2FRdVg1aUlhWUtBb1NmWENZdThSYU5PZUFmNzdBNmtUTWNJc0tTWTJPOUJOaWhjaHZpVW1rS3BHd25jM0ZOVXFPZTFRTDVORlNxMWRuRDRseWpkdFdTSkRHd2NpdHJRWCsybzVkRlJ5U3pGY1ljbmdIQVhpbkpDV1V2ZDNyYkxWK0J4T0c1bjZyVmxjeE5iR2psVzR1N25nV2JISzJJWmY2c1IrNTI2RFpYR0xvNS9vVkd2Y3ZuVXc1dU83aXhhT2NBUElEeDdxeHBDbEhNSlJJZU42VkZGRHpERklRQWJSY3IxQjJRU254U1NtY3NLTmV5SlVXS0J0T2VzcVZxR1c1TElGVjVSYlNINCtqUm1CZ3RmSlpud0JTb1Z5b21iZWF4a2VsMHlLNTZ2MUVoUkVtRGdBRkhCLyt3SzFqWWVUQm9TUkxoTTJKYWxuRFBHN0tGWUM3cGpmOGxhbUxhSW40MzdWKzR2aG1qRVlRV2cvWHVHOVozWHNQUUNkMD0tLTAzV0NDNDZTY0dsOFduWEphRmovUGc9PQ%3D%3D--e6f325edfe2389389c0e64c28422cedafe005bf7;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [9812e0de-8119-4c29-bfbd-95b7ea1e7d64]
      X-Runtime: ['0.051261']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Library", "id": 201}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['31']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=2QNtO1N0bl%2B3yxjyfU1ld0Fnm1YIhnAjaMIwMNKH4TPUTUi%2BWWIYOYLG4Uf8%2BqXWn4ZXv87DBOMjxRpbqE2gXw%3D%3D;
          _aquarium_NURSERY_production_session=SFAvRjNUS3MrZ0hrYkx2ZnRSTkRzbXVsa3NBOW1FRlF5WEplYUJDRHdtdWU0Q042RUtNdVJ6K1ZMZUJrSGNtazJkMk5BSEQ2ZDNKY2lSRTNObWgyY3Rpa3c1SlltYUV3cXZFWGN4eEtXWU9oVGU0enJST1grQk03elFCbE1NcFErNDdVSXNSNXFXcFVYai95YWZQb3cyaXZhUlFwTFpDZ2FlaEZ5WCtLNHVSQndTRDRtVnpFQmNRWERSVHh2a2ZFYnFabTVlM3NTaTh5RVhjMHduT3JkdU9OcFgyRlp5emlPZTNpTEt3U2w4bEkzV3pwRDNkemh0aE9FZVBreHdRT1A5OHpJLzQ5Uzl0N0VoTGVjbGY2QjYvQmFlYzg2KzE3Ui9FdjdHV012REhQUlJSZ0NaNmgwcUpRV1VNL2k5ZGlJUTk2bWt5dDNZdUgyMEpodjlud1M1WWtxZEZsWUxVNjk0RG9zcGF5b014cXdqakl2ZlRSTWVPeElSS1I3akRSMmtKVWx5ZmF2aE5ub1JWZ3J6T1RSSlJMakN0M3BKaDBEMlV1SXJ4Nll2RT0tLU1HUlhYaVhRZXM2OFJKVHFVQTBkbGc9PQ%3D%3D--20cb56d069c12bf7e639948514c5af354bf4dd7d;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":201,"name":"Enrich_cDNA_Fragments","category":"Illumina
        NGS Libs","created_at":"2018-09-28T10:27:59.000-07:00","updated_at":"2018-09-28T10:28:13.000-07:00"}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:09:13 GMT']
      ETag: [W/"2457128173bf7ed36564ab13d4b632c2"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=VwfZEa1XozEgUrjLmDof6RNUA3UBMnwDaOeE%2BkwWq79aSfyUp0HVVxVfQX4Zjd9IzbXPnMd3CMMj4K6RNtzq0w%3D%3D;
          path=/, _aquarium_NURSERY_production_session=RFd5bStjWnhtTk51VWJnTitkb1ZSNG9kWVpQZk5WYU5MUUdnR1RLSHRodE4rUzZzUFduYm1pVzVNMW9ob3J3RzNzcUI0V1NmaFFOZGx1eU1KUFY0WDBQZE43MVhpTVdzWjM1NU8rcHdiMkNSTlQ0SkpsRkMyN2xnanZQZXZ3QU5uZmQxUVVxemNXYUI4TlArSFVJQnBhbEJMQ2g5aG5ubkthTG9GUkQ4MUVnRVpkVHlWWnVJUU1Td2pGNnYyeGJoNUVkQnNBb0d3Y1pERi9nMUNhVFhXK1ZUcWZnaEY0ekEyMkQ4M05RYTdGRk9DUXVTZGhObnUrU28zN2NDdUlZdVhZbWtXMXBRaUFVMkF2ZXpQZ29yeHJPT2crV2NSUllqbDRHcml6T3F6YnlCbS9SemorV29iN0xVOU41di90K1FsUDRpY2xURVpGVE9vcXYyK1l3WUR6bmc5K0JSWkZRWFp2eEM2cWc5cHZWekJNSGFaN3JFMi8xYW5yYlZCcjdzM2VVWWdDSWVzUmQyMWVWV0l3UUdJTk5TVDFvZmFBL3pXQk9tcXRiKzE0OD0tLVRsV0FKYTdoeXNHdHBHeHliZVlycVE9PQ%3D%3D--4973564cb849efc7b190a8dcf3d8513767aa2443;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [9489406a-419e-4f26-87fa-aa211401af37]
      X-Runtime: ['0.003521']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Library", "id": 201}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['31']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=Jdij%2BU18FjbrS2a85aXtaiwfgwp8072hLFBkCK1J5d5vnQ1AA7GlrwBS9Tf0gt20W9siBuyvIeK56DqLvyNcYA%3D%3D;
          _aquarium_NURSERY_production_session=eW1IYjUvK0hSRVk4QXE1UlNKdWRVNkRSdzhJdW8yclpoUmtDL0s4VnRWTmZsZk9XQzV3Z1A1U2dISWY5K3NQRnZ1MUNZSi93VUlrblcxbUVlTk5vQ0l2NGZsU2pjYnNoOFVTenJHTlIya05ZMlpwVzZiR0E4YWYxYnpBRitIWHp0b25qdWdETzhsM0RIcCtybDNOOEgweWhkcGJpUW5QTHJja3BsMjhjOGY2ZW15ZWthbWlRUlZIeEcrWUF0WUlUUGFhY3lPS3BnNVk1aU4xZTU2RTJtN1cza2VYOUdVM0dyNVRPemFRY3BYQVpvZkl0Z2prUkh3UmNTOFRPYXEyOXdGZWVXcHNFbGVCL0FwUU0yVE9xSUNUY281cW9la2FxWjJ3cFE1Z1dVc01ROVZLaitabXpOUUVQZXBDcjN3MHdZRHJlVWJwd2diYlRVWEJQZUFSeVl2OUx6YkVOL1U3WTlQSnY5Z1hscUYrRE1tMUNPWDRwL0VqcmkyM2JDNTJkQzJXVThoY0hSV3MwczNSTFl5anNUaXlIN3Foa1drdi9GeGtwdkM2MGdQcz0tLUx1VWtSb3JINnJqSkkrQ045MEpwVHc9PQ%3D%3D--9055fdd117e8df8157539c9afee2faf5e0b5d9d2;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":201,"name":"Enrich_cDNA_Fragments","category":"Illumina
        NGS Libs","created_at":"2018-09-28T10:27:59.000-07:00","updated_at":"2018-09-28T10:28:13.000-07:00"}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:09:33 GMT']
      ETag: [W/"2457128173bf7ed36564ab13d4b632c2"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=nzDP4UGJA67ZH1UguANuCFfaidaTSd5s3ceAPGr9OkPVdWFYD0SwNzIGxqupJF7WIB4o2gM1Qi9If96%2FeJeD%2FQ%3D%3D;
          path=/, _aquarium_NURSERY_production_session=WEQvWWFyamV2Q0R4OGh6VXFGNm0ramxWTGc2Q0toUkt5L2xWY0x4cmxhcVUrTnJWb1ZqYnQ2bUZRalYzYmMrRTBFQ0Irb3IwWTZ1RVBOdTgzTktQMXNOdXZXcGR5Mk9uRGFmT1FFbGVXWHVoRHNEVHR3ZkN1REJzZ01MdHBhNW1CeWIwR2NvMUMwYmZXVWJua000U2Zpek0yWnJoVXowWjczQnV5aFlyd3hmTFVvdUtUV0lrN1k5anQ1REFGa1YvSDViVncvekdrMWwrWFdXTThiOC9UaytRcEJCQWkwbytaR3FWRkNMcEVpZFA4Z1hUN05HNnQrZnZmR1lxUkRHUEFub1EvVzN5ODZZQUtkKzhUc3BySy9FdlUwZ0VmMDU4NGR5ME01bGdhSzg0eXdRampNSGw3ZDlMSU01Vng3WEFhd3o4ckFkcnVkK0k1RGNYZDFsTHF3VTlCL2N2bERyRy85Sk81VXN2YnZmWEsvOEM1VEJ5Q0o5NCtUQkxQbXlwTGdTNkM4eEZHeXJKY3ZVd2Y5M1lHL09BN3BFTGJTQzJFdG9RcFpUNzdnUT0tLUNCMGhxeDFaek5mUWg2QjF6RHFEYnc9PQ%3D%3D--a54fbcff54ec91a88c37a6be447b4ebfa3dfd13b;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [738255a6-0d80-4e52-ba9e-f31a5a808d7f]
      X-Runtime: ['0.004183']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
version: 1
