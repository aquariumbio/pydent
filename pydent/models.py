"""Aquarium models

This module contains a set of classes for various various Aquarium objects.
Trident models inherit the ModelBase class and have a model schema
(generated by ``@add_schema``) that handles the JSON loading and dumping.

By default, Trident models capture ALL JSON attribute/values and sets
the attributes of the resultant object.

. code-block:: python

    u = User.load({"id": 1, "login": "John"})
    u.login    # => "John"
    u.id       # => 1

Fields and field options are added as class variables in the model class
definition.
The various field options and their default values are listed below.

. code-block:: python

        load_all = True     # load all data attributes defined for a model
        strict = True       # throw error during marshalling
        include = {}        # fields to include for serialization
        additional = ()     # explicit fields for serialization
        ignore = ()         # fields to filter during deserialization.
        load_only = ()      # fields to include during serialization
        dump_only = ()      # fields to include during deserialization

Trident models can also have nested relationships (for example, a Sample may
possess a single SampleType while a SampleType may possess several Samples).
These relationships can be specified in the class definition along with the
field options above, as in:

. code-block:: python

    @add_schema
    class SampleType(Base):
        samples = fields.Nested("Sample", many=True)

In many cases, the model contains only a reference to the nested relationship,
in this case, special fields One and Many may be used to define this
relationship.
When called as an attribute, Trident will automatically use the session
connection with Aquarium to retrieve the given model.

For example, the following will define that SampleType has many Samples.
When .samples is called on a SampleType instance, Trident will use the database
to retrieve all samples that have a sample_type_id equal to the id of the
SampleType:

. code-block:: python

    @add_schema
    class SampleType(Base):
        samples = Many("Sample",
            callback_args={"sample_type_id": lambda self: self.id})
"""

import json
import os
import shutil

import requests

from itertools import zip_longest

from pydent.base import ModelBase
from pydent.exceptions import AquariumModelError
from pydent.marshaller import add_schema
from pydent.relationships import (Raw, Function, JSON, One, Many, HasOne, HasMany,
                                  HasManyThrough, HasManyGeneric,
                                  HasOneFromMany, fields)
from pydent.utils import filter_list
from pydent.utils.async_requests import make_async

__all__ = [
    "Account",
    "AllowableFieldType",
    "Budget",
    "Code",
    "Collection",
    "DataAssociation",
    "FieldType",
    "FieldValue",
    "Group",
    "Invoice",
    "Item",
    "Job",
    "JobAssociation",
    "Library",
    "Membership",
    "ObjectType",
    "Operation",
    "OperationType",
    "PartAssociation",
    "Plan",
    "PlanAssociation",
    "Sample",
    "SampleType",
    "Upload",
    "User",
    "UserBudgetAssociation",
    "Wire"
]


class FieldMixin:
    """
    Mixin for finding FieldType and FieldValue relationships
    """

    def find_field_parent(self, model_name, model_id):
        """
        Callback for finding operation_type or sample_type.
        If parent_class does not match the expected nested model name
        (OperationType or SampleType), callback will return None
        """
        if model_name == self.parent_class:
            # weird, but helps with refactoring this mixin
            fxn_name = ModelBase.find_callback.__name__
            fxn = getattr(self, fxn_name)
            return fxn(model_name, model_id)


class FieldTypeInterface(object):

    def field_type(self, name, role):
        if self.field_types:
            fts = filter_list(self.field_types, role=role, name=name)
            if len(fts) > 0:
                return fts[0]


class FieldValueInterface(object):
    """A common interface for things (i.e. Operations and Samples) that have FieldValues and FieldTypes"""

    def new_field_value_from_field_type(self, field_type, values=None):
        assert field_type in self.get_field_types()
        self.new_field_value(field_type.name, field_type.role, values=values)

    def new_field_value(self, name, role=None, values=None):
        # retrieve the field_type from the meta_type
        metatype = self.get_metatype()
        ft = metatype.field_type(name, role=role)

        # initialize the field_value
        fv = ft.initialize_field_value(parent=self)
        if values:
            fv.set_value(**values)
        # add new field_value to list of field_values
        if self.field_values is None:
            self.field_values = []

        self.field_values.append(fv)
        return fv

    def get_metatype(self):
        metatype = getattr(self, self.METATYPE)
        assert issubclass(type(metatype), FieldTypeInterface)
        return metatype

    def get_field_value(self, name, role=None):
        fv_array = self.get_field_value_array(name, role=role)
        if fv_array:
            return fv_array[0]

    def get_field_value_array(self, name, role=None):
        return [fv for fv in self.field_values if fv.name == name and fv.role == role]

    def get_field_types(self):
        return self.get_metatype().field_types

    def _field_value_dictionary(self, ft_func, fv_func):
        data = {}
        ft_dict = {ft.id: ft for ft in self.get_field_types()}

        for ft in ft_dict.values():
            if ft.array:
                val = []
            else:
                val = None
            data[ft_func(ft)] = val

        for fv in self.field_values:
            ft = ft_dict[fv.field_type_id]
            val = fv_func(fv)
            if ft.array:
                data[ft_func(ft)].append(val)
            else:
                data[ft_func(ft)] = val

        return data

    def set_field_value(self, name, role, values):
        fv = self.get_field_value(name, role)
        fv.set_value(**values)
        return self

    def set_field_value_array(self, name, role, values_array):
        fvs = self.get_field_value_array(name, role)
        to_be_removed = []
        for fv, val in zip_longest(fvs, values_array):
            if fv and val:
                fv.set_value(val)
            elif fv and not val:
                to_be_removed.append(fv)
            elif not fv and val:
                self.new_field_value(name, role, val)
        for fv in to_be_removed:
            self.field_values.remove(fv)
        return self

    def get_routing(self):
        return self._field_value_dictionary(
            lambda ft: ft.routing,
            lambda fv: fv.sid
        )


class DataAssociatorMixin:
    """
    Mixin for handling data associations
    """

    def associate(self, key, value, upload=None):
        """
        Adds a data association with the key and value to this object.
        """
        return self.session.utils.create_data_association(
            self, key, value, upload=upload)

    def associate_file(self, key, value, file, job_id=None):
        """
        Associate a file

        :param key: association key
        :type key: str or json
        :param value: association value
        :type value: str or json
        :param file: file to create :class:`Upload`
        :type file: file object
        :param job_id: optional job_id to associate the :class:`Upload`
        :type job_id: int
        :return: new data association
        :rtype: :class:`DataAssociation`
        """
        u = self.session.Upload.new(job_id=job_id, file=file)
        u.save()
        return self.associate(key, value, upload=u)

    def associate_file_from_path(self, key, value, filepath, job_id=None):
        """
        Associate a file from a filepath

        :param key: association key
        :type key: str or json
        :param value: association value
        :type value: str or json
        :param filepath: path to file to create :class:`Upload`
        :type filepath: str
        :param job_id: optional job_id to associate the :class:`Upload`
        :type job_id: int
        :return: new data association
        :rtype: :class:`DataAssociation`
        """
        with open(filepath, 'rb') as f:
            return self.associate_file(key, value, f, job_id=job_id)

    def get_data_associations(self, key):
        das = []
        for da in self.data_associations:
            if da.key == key:
                das.append(da)
        return das

    # TODO: DataAssociation - do we really want to have this return either a list or single value? How are people using this?
    def get(self, key):
        val = []
        for da in self.get_data_associations(key):
            val.append(da.value)
        if len(val) == 1:
            return val[0]
        elif len(val) == 0:
            return None
        return val


@add_schema
class Account(ModelBase):
    """An Account model"""


@add_schema
class AllowableFieldType(ModelBase):
    """A AllowableFieldType model"""
    fields = dict(
        field_type=HasOne("FieldType"),
        object_type=HasOne("ObjectType"),
        sample_type=HasOne("SampleType")
    )

    def __init__(self, field_type=None, object_type=None, sample_type=None):
        super().__init__(
            field_type_id=None,
            sample_type_id=None,
            object_type_id=None,
            field_type=field_type,
            object_type=object_type,
            sample_type=sample_type
        )

    def __str__(self):
        return self._to_str('sample_type', 'object_type')


@add_schema
class Budget(ModelBase):
    """A Budget model"""
    fields = dict(
        user_budget_associations=HasMany("UserBudgetAssociation", "Budget")
    )


@add_schema
class Code(ModelBase):
    """A Code model"""
    fields = dict(
        user=HasOne("User"),
        operation_type=One(
            "OperationType", callback="get_parent", callback_args=None),
        library=One("Library", callback="get_parent", callback_args=None)
    )

    def get_parent(self, parent_class, *args):
        if parent_class != self.parent_class:
            return None
        return self.session.model_interface(
            self.parent_class).find(self.parent_id)

    def update(self):
        # since they may not always be tied to specific parent
        # controllers
        self.session.utils.update_code(self)


@add_schema
class Collection(DataAssociatorMixin, ModelBase):  # pylint: disable=too-few-public-methods
    """A Collection model"""
    fields = dict(
        object_type=HasOne("ObjectType"),
        data_associations=HasManyGeneric("DataAssociation", additional_args={
            "parent_class": "Collection"
        }),
        part_associations=HasMany("PartAssociation", "Collection"),
        parts=HasManyThrough("Item", "PartAssociation", ref="part_id")
    )
    methods = ["dimensions"]

    @property
    def matrix(self):
        """
        Returns the matrix of Samples for this Collection.

        (Consider using samples of parts directly.)
        """
        num_row, num_col = self.dimensions
        sample_matrix = list()
        for row in range(num_row):
            row_list = list()
            for col in range(num_col):
                sample_id = None
                part = self.part(row, col)
                if part:
                    sample_id = part.sample.id
                row_list.append(sample_id)
            sample_matrix.append(row_list)
        return sample_matrix

    def part(self, row, col):
        """
        Returns the part Item at (row, col) of this Collection (zero-based).
        """
        parts = [assoc.part for assoc in self.part_associations
                 if assoc.row == row and assoc.column == col]

        if not parts:
            return None

        return next(iter(parts))

    def as_item(self):
        """
        Returns the Item object with the ID of this Collection
        """
        return self.session.Item.find(self.id)


@add_schema
class DataAssociation(ModelBase):
    """A DataAssociation model"""
    fields = dict(
        object=JSON(),
        upload=HasOne("Upload")
    )

    @property
    def value(self):
        return self.object.get(self.key, None)

    def delete(self):
        return self.session.utils.delete_data_association(self)

    def __str__(self):
        return self._to_str("id", "object")


@add_schema
class FieldType(FieldMixin, ModelBase):
    """A FieldType model"""
    fields = dict(
        allowable_field_types=HasMany("AllowableFieldType", "FieldType"),
        operation_type=HasOne(
            "OperationType", callback="find_field_parent", ref="parent_id"),
        sample_type=HasOne(
            "SampleType", callback="find_field_parent", ref="parent_id"),
        field_values=HasMany("FieldValue", "FieldType")
    )

    def __init__(self, name=None, ftype=None, array=None, choices=None,
                 operation_type=None, preferred_field_type_id=None,
                 preferred_operation_type_id=None, required=None, routing=None,
                 role=None, parent_class=None, parent_id=None,
                 sample_type=None, aft_stype_and_objtype=(),
                 allowable_field_types=None):
        if operation_type and sample_type:
            raise Exception("Cannot instantiate a FieldType for both a OperationType and SampleType.")
        if operation_type:
            parent_class = "OperationType"
        if sample_type:
            parent_class = "SampleType"
        super().__init__(
            name=name,
            ftype=ftype,
            array=array,
            choices=choices,
            role=role,
            preferred_field_type_id=preferred_field_type_id,
            preferred_operation_type_id=preferred_operation_type_id,
            required=required,
            routing=routing,
            parent_class=parent_class,
            parent_id=parent_id,
            sample_type=sample_type,
            operation_type=operation_type,
            allowable_field_types=allowable_field_types
        )

        if allowable_field_types is None:
            if aft_stype_and_objtype is not None:
                for smple_type, obj_type in aft_stype_and_objtype:
                    self.create_allowable_field_type(smple_type, obj_type)

    def get_choices(self):
        if self.choices == '':
            return None
        if self.choices is not None:
            return self.choices.split(',')

    @property
    def is_parameter(self):
        return self.ftype != "sample"

    def get_allowable_field_types(self):
        afts = self.allowable_field_types
        if afts is None or afts == []:
            self.allowable_field_types = None
            afts = self.allowable_field_types
        return afts

    def create_allowable_field_type(self, sample_type=None, object_type=None):
        afts = []
        if self.allowable_field_types:
            afts = self.allowable_field_types
        field_type = self.session.AllowableFieldType.new(
            field_type=self, sample_type=sample_type, object_type=object_type)
        afts.append(field_type)
        self.allowable_field_types = afts
        return field_type

    def initialize_field_value(self, field_value=None, parent=None):
        """
        Updates or initializes a new :class:`FieldValue` from this FieldType

        :param field_value: optional FieldValue to update with this FieldType
        :type field_value: FieldValue
        :return: updated FieldValue
        :rtype: FieldValue
        """

        if not field_value:
            field_value = self.session.FieldValue.new(name=self.name, role=self.role, field_type=self)
        if self.allowable_field_types:
            field_value.allowable_field_type_id = self.allowable_field_types[0].id
            field_value.allowable_field_type = self.allowable_field_types[0]
        if parent:
            field_value.set_parent(parent)
        return field_value


@add_schema
class FieldValue(FieldMixin, ModelBase):
    """
    A FieldValue model. One of the more complex models.
    """
    fields = dict(
        # FieldValue relationships
        field_type=HasOne("FieldType"),
        allowable_field_type=HasOne("AllowableFieldType"),
        array=fields.Field(),
        # array=Function(lambda fv: fv.array, callback_args=(fields.Callback.SELF,)),
        item=HasOne("Item", ref="child_item_id"),
        sample=HasOne("Sample", ref="child_sample_id"),
        object_type_id=Raw(),
        object_type=HasOne("ObjectType"),
        operation=HasOne(
            "Operation", callback="find_field_parent", ref="parent_id"),
        parent_sample=HasOne(
            "Sample", callback="find_field_parent", ref="parent_id"),
        wires_as_source=HasMany("Wire", ref="from_id"),
        wires_as_dest=HasMany("Wire", ref="to_id"),
        outgoing_wires=fields.Alias("wires_as_source"),
        incoming_wires=fields.Alias("wires_as_dest"),

        sid=Function('get_sid'),
        child_sample_name=Function(lambda fv: fv.sid, callback_args=(fields.Callback.SELF,)),
        # allowable_child_types=Function('get_allowable_child_types'),
    )

    def __init__(self, name=None, role=None, parent_class=None, parent_id=None,
                 field_type=None, sample=None, value=None, item=None, container=None):
        """

        :param value:
        :type value:
        :param sample:
        :type sample:
        :param container:
        :type container:
        :param item:
        :type item:
        """
        super().__init__(
            name=name,
            role=role,
            parent_class=parent_class,
            parent_id=parent_id,
            field_type_id=None,
            field_type=field_type,
            child_sample_id=None,
            sample=sample,
            value=value,
            child_item_id=None,
            item=item,
            object_type=container,
            allowable_field_type_id=None,
            allowable_field_type=None,
            column=None,
            row=None,
        )

        if field_type is not None:
            self.set_field_type(field_type)

        if any([value, sample, item, container]):
            self._set_helper(value=value, sample=sample,
                             item=item, container=container)

    def get_sid(self):
        """The FieldValues sample identifier."""
        if self.sample is not None:
            return self.sample.identifier

    def get_outgoing_wires(self, destination=None):
        """
        Get the outgoing wires. Optionally, if provided with a destination FieldValue, will get
        all of the outgoing wires coming from the destination FieldValue

        :param destination: the optional destination FieldValue
        :type destination: FieldValue
        :return: array of wires
        :rtype: array
        """
        if not self.outgoing_wires:
            self.outgoing_wires = []
            return self.outgoing_wires
        wires = self.outgoing_wires
        if destination:
            return [w for w in wires if w.does_wire(self, destination)]
        else:
            return wires

    def get_incoming_wires(self, source=None):
        """
        Get the incoming wires. Optionally, if provided with a source FieldValue, will get
        all of the incoming wires coming from the source FieldValue

        :param source: the optional source FieldValue
        :type source: FieldValue
        :return: array of wires
        :rtype: array
        """
        if not self.incoming_wires:
            self.incoming_wires = []
            return self.incoming_wires
        wires = self.incoming_wires
        if source:
            return [w for w in wires if w.does_wire(source, self)]
        else:
            return wires

    def wire_to(self, destination):
        """
        Creates a new wire from this FieldValue to to a destination FieldValue. The
        new wire is returned.

        If the wire exists (determined by their unique instance rids), then the first
        existing wire is returned instead.

        :param destination: destination FieldValue to create a wire to.
        :type destination: FieldValue
        :return: the wire
        :rtype: Wire
        """
        existing_wires = self.get_outgoing_wires(destination)
        if existing_wires:
            wire = existing_wires[0]
        else:
            wire = Wire(source=self, destination=destination)
        self.add_outgoing_wire(wire)
        destination.add_incoming_wire(wire)
        return wire

    def wire_from(self, source):
        """
        Creates a new wire from this FieldValue to to a destination FieldValue. The
        new wire is returned.

        If the wire exists (determined by their unique instance rids), then the first
        existing wire is returned instead.

        :param source: destination FieldValue to create a wire to.
        :type source: FieldValue
        :return: the wire
        :rtype: Wire
        """
        existing_wires = self.get_incoming_wires(source)
        if existing_wires:
            wire = existing_wires[0]
        else:
            wire = Wire(source=source, destination=self)
        source.add_outgoing_wire(wire)
        self.add_incoming_wire(wire)
        return wire

    def add_incoming_wire(self, wire):
        """Adds a wire to the list of this FieldValues incoming wires."""

        if not wire.destination.rid == self.rid:
            raise AquariumModelError("Cannot add wire {} to {}. The wire's destination Fieldvalue" \
                                     " does not match this FieldValue".format(wire, self))
        wires = self.incoming_wires
        if wires is None:
            wires = []
        wires.append(wire)
        self.incoming_wires = [w for w in wires if w.destination.rid == self.rid]
        return wire

    def add_outgoing_wire(self, wire):
        """Adds a wire to the list of this FieldValues outgoing wires."""

        if not wire.source.rid == self.rid:
            raise AquariumModelError("Cannot add wire {} to {}. The wire's source Fieldvalue" \
                                     " does not match this FieldValue".format(wire, self))

        wires = self.outgoing_wires
        if wires is None:
            wires = []
        wires.append(wire)
        self.outgoing_wires = [w for w in wires if w.destination.rid == self.rid]
        return wire

    @property
    def successors(self):
        if self.outgoing_wires:
            return [x.destination for x in self.outgoing_wires]
        return []

    @property
    def predecessors(self):
        if self.incoming_wires:
            return [x.source for x in self.incoming_wires]
        return []

    def show(self, pre=""):
        if self.sample:
            if self.child_item_id:
                item = " item: {}".format(self.child_item_id) + \
                       " in {}".format(self.item.object_type.name)
            else:
                item = ""
            print('{}{}.{}:{}{}'.format(pre, self.role,
                                        self.name, self.sample.name, item))
        elif self.value:
            print('{}{}.{}:{}'.format(pre, self.role, self.name, self.value))

    def reset(self):
        """Resets the inputs of the field_value"""
        self.value = None
        self.allowable_field_type_id = None
        self.allowable_field_type = None
        self.child_item_id = None
        self.item = None
        self.child_sample_id = None
        self.sample = None
        self.row = None
        self.column = None

    # TODO: have field_value resolve the ids when it is dumped? Or how does this work?
    def _set_helper(self, value=None, sample=None, container=None, item=None, row=None, column=None):
        if row is not None:
            if not self.field_type.part:
                raise AquariumModelError(
                    "Cannot set row of a non-part for {} {}".format(self.role, self.name))
            self.row = row
        if column is not None:
            if not self.field_type.part:
                raise AquariumModelError(
                    "Cannot set column of a non-part for {} {}".format(self.role, self.name))
            self.column = column
        if item and container and item.object_type_id != container.id:
            raise AquariumModelError(
                "Item {} is not in container {}".format(
                    item.id, str(container)))
        if value is not None:
            choices = self.field_type.get_choices()
            if choices is not None:
                if value not in choices and str(value) not in choices:
                    raise AquariumModelError("Value \'{}\' not in list of field "
                                             "type choices \'{}\'".format(value, choices))
            self.value = value
        if item is not None:
            self.item = item
            if hasattr(item, 'id'):
                self.child_item_id = item.id
            self.object_type = item.object_type
            if not sample:
                sample = item.sample
        if sample is not None:
            self.sample = sample
            if hasattr(sample, 'id'):
                self.child_sample_id = sample.id
        if container is not None:
            self.object_type = container

    def set_value(self, value=None, sample=None, container=None, item=None, row=None, column=None):
        self._set_helper(value=value, sample=sample,
                         container=container, item=item, row=row, column=column)
        """Sets the value of a """
        if any([sample, container, item]):
            afts = self.field_type.allowable_field_types
            if self.sample is not None:
                afts = filter_list(
                    afts, sample_type_id=self.sample.sample_type_id)
            if self.object_type is not None:
                afts = filter_list(afts, object_type_id=self.object_type.id)
            if len(afts) == 0:
                aft_list = []
                for aft in self.field_type.allowable_field_types:
                    st = "none"
                    ot = "none"
                    if aft.object_type is not None:
                        ot = aft.object_type.name
                    if aft.sample_type is not None:
                        st = aft.sample_type.name
                    aft_list.append("{}:{}".format(st, ot))
                sid = "none"
                if self.sample is not None:
                    sid = self.sample.sample_type.name
                oid = "none"
                if self.object_type is not None:
                    oid = self.object_type.name
                msg = "No allowable field types found for {} {} using {} {}."
                msg += " Available afts: {}"
                raise AquariumModelError(msg.format(
                    self.role, self.name, sid, oid, ', '.join(aft_list)))
            if len(afts) > 1:
                self.set_allowable_field_type(afts[0])
            elif len(afts) == 1:
                self.set_allowable_field_type(afts[0])
            else:
                msg = "No allowable field type found for {} '{}'"
                raise AquariumModelError(
                    msg.format(self.role, self.name))
        return self


    def set_parent(self, model):
        self.parent_id = model.id
        self.parent_class = model.__class__.__name__
        return self

    # TODO: rename set_operation, or re-implement?
    def set_as_operation_field_value(self, operation):
        self.parent_class = "Operation"
        if hasattr(operation, 'id'):
            self.parent_id = operation.id
        self.operation = operation

    # TODO: rename set_sample, or re-implement?
    def set_as_sample_field_value(self, sample):
        self.parent_class = "Sample"
        if hasattr(sample, 'id'):
            self.parent_id = sample.id
        self.sample = sample

    def set_field_type(self, field_type):
        """
        Sets properties from a field_type
        """

        self.field_type = field_type
        self.field_type_id = field_type.id

        if field_type.name:
            self.name = field_type.name
        if field_type.parent_class:
            self.parent_class = field_type.parent_class
        if field_type.role:
            self.role = field_type.role

    def set_allowable_field_type(self, allowable_field_type):
        self.allowable_field_type = allowable_field_type
        self.allowable_field_type_id = allowable_field_type.id

    def choose_item(self, first=True):
        """Set the item associated with the field value"""
        index = 0
        if not first:
            index = -1
        items = self.compatible_items()
        if items is not None and len(items) > 0:
            item = items[index]
            self.set_value(item=item)
            return item
        return None

    def compatible_items(self):
        """Find items compatible with the field value"""
        return self.session.utils.compatible_items(
            self.sample.id,
            self.allowable_field_type.object_type_id)


@add_schema
class Group(ModelBase):
    """A Group model"""
    pass


@add_schema
class Invoice(ModelBase):
    """A Invoice model"""
    pass


@add_schema
class Item(DataAssociatorMixin, ModelBase):
    """
    Defines a proxy object for an Item model in Aquarium.
    An Item is a physical object in the lab.
    """
    fields = dict(
        sample=HasOne("Sample"),
        object_type=HasOne("ObjectType"),
        data_associations=HasManyGeneric("DataAssociation", additional_args={
            "parent_class": "Item"
        }),
        data=Raw(),
        ignore=("locator_id",),
        part_associations=HasMany("PartAssociation", ref="part_id"),  # TODO: add to change log
        collections=HasManyThrough("Collection", "PartAssociation"),  # TODO: add to change log
        # provedance fields
        # TODO: add new relationships to change log
        field_values_as_outputs=HasMany("FieldValue", ref="child_item_id", additional_args={
            "role": "output",
            "parent_class": "Operation"
        }),
        field_values_as_inputs=HasMany("FieldValue", ref="child_item_id", additional_args={
            "role": "input",
            "parent_class": "Operation"
        }),
        operations_as_outputs=HasManyThrough("Operation", "FieldValuesAsOutput", ref="parent_id"),
        operations_as_inputs=HasManyThrough("Operation", "FieldValuesAsInput", ref="parent_id"),
    )
    methods = ['is_part']

    def __init__(self=None, sample_id=None, sample=None, object_type=None, object_type_id=None):
        super().__init__(
            object_type_id=object_type_id,
            object_type=object_type,
            sample_id=sample_id,
            sample=sample,
        )

    def make(self):
        """Makes the Item on the Aquarium server. Requires
        this Item to be connected to a session."""
        result = self.session.utils.create_items([self])
        return self.reload(result[0]["item"])

    def save(self):
        """A synonym for `make`"""
        return self.make()

    def is_deleted(self):
        return self.location == 'deleted'

    @property
    def containing_collection(self):
        """
        Returns the collection of which this Item is a part.

        Returns the collection object if the Item is a part, otherwise
        returns None.
        """
        if not self.is_part:
            return None

        # TODO: to be tested
        assoc_list = self.session.PartAssociation.where({'part_id': self.id})
        if not assoc_list:
            return

        if len(assoc_list) != 1:
            return None

        part_assoc = next(iter(assoc_list))
        if not part_assoc:
            return None

        return self.session.Collection.find(part_assoc.collection_id)

    def as_collection(self):
        """
        Returns the Collection object with the ID of this Item, which must be a
        collection.

        Returns None if this Item is not a collection.
        """
        if not self.is_collection:
            return None

        return self.session.Collection.find(self.id)

    @property
    def is_collection(self):
        """
        Returns True if this Item is a collection in a PartAssociation.

        Note: this is not how Aquarium does this test in the `collection?` method.
        """
        assoc_list = self.session.PartAssociation.where({'collection_id': self.id})
        return bool(assoc_list)

    # TODO: add to change log
    @property
    def collection(self):
        return self.collections[0]

    # TODO: add to change log
    @property
    def part_association(self):
        return self.part_associations[0]


@add_schema
class Job(ModelBase):
    """A Job model"""
    fields = dict(
        job_associations=HasMany("JobAssociation", "Job"),
        operations=HasManyThrough("Operation", "JobAssociation"),
        state=JSON()
    )

    @property
    def is_complete(self):
        return self.pc == -2

    @property
    def uploads(self):
        http = self.session._AqSession__aqhttp
        return http.get("krill/uploads?job={}".format(self.id))['uploads']

    @property
    def start_time(self):
        return self.state[0]['time']

    @property
    def end_time(self):
        return self.state[-2]['time']


@add_schema
class JobAssociation(ModelBase):
    """A JobAssociation model"""
    fields = dict(
        job=HasOne("Job"),
        operation=HasOne("Operation")
    )


@add_schema
class Library(ModelBase):
    """A Library model"""
    fields = dict(
        codes=HasManyGeneric("Code"),
        source=HasOneFromMany("Code", ref="parent_id",
                              additional_args={
                                  "parent_class": "Library",
                                  "name": "source"
                              }),
    )

    def code(self, accessor):
        """Reminant from previous API"""
        # raise DeprecationWarning("This method is depreciated. Use '.source' directly")
        if accessor == "source":
            return self.source
        return None


@add_schema
class Membership(ModelBase):
    fields = dict(
        user=HasOne("User"),
        group=HasOne("Group")
    )


@add_schema
class ObjectType(ModelBase):
    """A ObjectType model"""

    def save(self):
        """Saves the Object Type to the Aquarium server. Requires
        this Object Type to be connected to a session."""
        return self.reload(self.session.utils.create_object_type(self))

    def __str__(self):
        return self._to_str('id', 'name')


# TODO: field_values should recognize parent_class (maybe where should ignore None field_values..)
@add_schema
class Operation(FieldValueInterface, DataAssociatorMixin, ModelBase):
    """A Operation model"""
    # TODO: add 'inputs' and 'outputs' as bone-fide properties
    fields = dict(
        field_values=HasMany("FieldValue",
                             ref="parent_id",
                             additional_args={"parent_class": "Operation"}),
        data_associations=HasManyGeneric("DataAssociation", additional_args={
            'parent_class': 'Operation'
        }),
        operation_type=HasOne("OperationType"),
        job_associations=HasMany("JobAssociation", "Operation"),
        jobs=HasManyThrough("Job", "JobAssociation"),
        plan_associations=HasMany("PlanAssociation", "Operation"),
        plans=HasManyThrough("Plan", "PlanAssociation"),
        status=Raw(default='planning'),
        routing=Function('get_routing'),
    )

    METATYPE = "operation_type"

    def __init__(self, operation_type_id=None, operation_type=None, status=None, x=0, y=0):
        super().__init__(
            operation_type_id=None,
            operation_type=operation_type,
            status=status,
            field_values=None,
            x=x,
            y=y
        )

    def get_routing(self):
        routing_dict = {}
        fvs = self.field_values
        ot = self.operation_type
        if ot is None:
            return routing_dict
        for ft in ot.field_types:
            if ft.routing is not None:
                routing_dict[ft.routing] = None
        if fvs is not None:
            for fv in self.field_values:
                ft = fv.field_type
                if ft.routing is not None:
                    routing_dict[ft.routing] = fv.sid
        return routing_dict

    @property
    def successors(self):
        successors = []
        if self.outputs:
            for output in self.outputs:
                for s in output.successors:
                    successors.append(s.operation)
        return successors

    @property
    def predecessors(self):
        predecessors = []
        if self.inputs:
            for inputs in self.inputs:
                for s in inputs.predecessors:
                    predecessors.append(s.operation)
        return predecessors

    def init_field_values(self):
        """
        Initialize the :class:`FieldValue` from the :class:`FieldType` of the
        parent :class:`Operation` type.
        """
        self.field_values = []
        for field_type in self.get_metatype().field_types:
            if not field_type.array:
                self.new_field_value_from_field_type(field_type)
        return self

    def field_value_array(self, name, role):
        """Returns :class:`FieldValue` array with name and role."""
        return filter_list(self.get_field_value_array(name, role))

    def field_value(self, name, role):
        """
        Returns :class:`FieldValue` with name and role.
        Return None if not found.
        """
        if self.field_values:
            fvs = self.field_value_array(name, role)

            if len(fvs) == 0:
                return None

            if len(fvs) == 1:
                return fvs[0]

            msg = "More than one FieldValue found for the field value"
            msg += " of operation {}.(id={}).{}.{}. Are you sure you didn't mean to call 'field_value_array'?"
            raise AquariumModelError(
                msg.format(self.operation_type, self.id, role, name))

    @property
    def plan(self):
        return self.plans[0]

    def input(self, name):
        """Returns the input :class:`FieldValue` by name"""
        return self.field_value(name, 'input')

    def output(self, name):
        """Returns the output :class:`FieldValue` by name"""
        return self.field_value(name, 'output')

    def add_to_input_array(self, name, sample=None, item=None, value=None,
                           container=None):
        """
        Creates and adds a new input :class:`FieldValue`.
        When setting values to items/samples/containers, the
        item/sample/container must be saved.

        :param name: name of the FieldType/FieldValue
        :type name: string
        :param sample: an existing Sample
        :type sample: Sample
        :param item: an existing Item
        :type item: Item
        :param value: a string or number value
        :type value: string|integer
        :param container: an existing ObjectType
        :type container: ObjectType
        :return: the newly created FieldValue
        :rtype: FieldValue
        """
        return self.new_field_value(name, "input",
                                             dict(sample=sample,
                                             item=item,
                                             value=value,
                                             container=container))

    def add_to_output_array(self, name, sample=None, item=None, value=None,
                            container=None):
        """
        Creates and adds a new output :class:`FieldValue`.
        When setting values to items/samples/containers, the
        item/sample/container must be saved.

        :param name: name of the FieldType/FieldValue
        :type name: string
        :param sample: an existing Sample
        :type sample: Sample
        :param item: an existing Item
        :type item: Item
        :param value: a string or number value
        :type value: string|integer
        :param container: an existing ObjectType
        :type container: ObjectType
        :return: the newly created FieldValue
        :rtype: FieldValue
        """
        return self.new_field_value(name, "output",
                                             dict(sample=sample,
                                             item=item,
                                             value=value,
                                             container=container))

    @property
    def inputs(self):
        """Return a list of all input :class:`FieldValues`"""
        return [fv for fv in self.field_values if fv.role == 'input']

    @property
    def outputs(self):
        """Return a list of all output :class:`FieldValues`"""
        return [fv for fv in self.field_values if fv.role == 'output']

    def set_input(self, name, sample=None, item=None, value=None,
                  container=None):
        """
        Sets a input :class:`FieldValue` to a value. When setting values to
        items/samples/containers, the item/sample/container must be saved.

        :param name: name of the FieldValue/FieldType
        :type name: string
        :param sample: an existing Sample
        :type sample: Sample
        :param item: an existing Item
        :type item: Item
        :param value: a string or number value
        :type value: string|integer
        :param container: an existing ObjectType
        :type container: ObjectType
        :return: the existing FieldValue modified
        :rtype: FieldValue
        """
        return self.set_field_value(name, 'input', sample=sample, item=item, value=value, container=container)

    def set_output(self, name, sample=None, item=None, value=None,
                   container=None):
        """
        Sets a output :class:`FieldValue` to a value. When setting values to
        items/samples/containers, the item/sample/container must be saved.

        :param name: name of the FieldValue/FieldType
        :type name: string
        :param sample: an existing Sample
        :type sample: Sample
        :param item: an existing Item
        :type item: Item
        :param value: a string or number value
        :type value: string|integer
        :param container: an existing ObjectType
        :type container: ObjectType
        :return: the existing FieldValue modified
        :rtype: FieldValue
        """
        return self.set_field_value(name, 'output', sample=sample, item=item, value=value, container=container)

    def set_input_array(self, name, values):
        """
        Sets input :class:`FieldValue` array using values.
        Values should be a list of dictionaries containing sample, item,
        container, or values keys.
        When setting values to items/samples/containers, the
        item/sample/container must be saved.

        :param name: name of the FieldType/FieldValues being modified
        :type name: string
        :param values: list of dictionary of values to set
                (e.g. [{"sample": mysample}, {"item": myitem}])
        :type values: list
        :return: the list of modified FieldValues
        :rtype: list
        """
        return self.set_field_value_array(name, "input", values)

    def set_output_array(self, name, values):
        """
        Sets output :class:`FieldValue` array using values.
        Values should be a list of dictionaries containing sample, item,
        container, or values keys.
        When setting values to items/samples/containers, the
        item/sample/container must be saved.

        :param name: name of the FieldType/FieldValues being modified
        :type name: string
        :param values: list of dictionary of values to set
                (e.g. [{"sample": mysample}, {"item": myitem}])
        :type values: list
        :return: the list of modified FieldValues
        :rtype: list
        """
        return self.set_field_value_array(name, "output", values)

    def show(self, pre=""):
        """
        Print the operation nicely
        """
        print(pre + self.operation_type.name + " " + str(self.cost))
        for field_value in self.field_values:
            field_value.show(pre=pre + "  ")


# TODO: Refactor OperationType and Library code relationships to use ONE
@add_schema
class OperationType(FieldTypeInterface, ModelBase):
    """
    Represents an OperationType, which is the definition of a protocol in
    Aquarium.
    """
    fields = dict(
        operations=HasMany("Operation", "OperationType"),
        field_types=HasMany("FieldType", ref="parent_id", additional_args={"parent_class": "OperationType"}),
        codes=HasManyGeneric("Code"),
        cost_model=HasOneFromMany("Code", ref="parent_id",
                                  additional_args={
                                      "parent_class": "OperationType",
                                      "name": "cost_model"
                                  }),
        documentation=HasOneFromMany("Code", ref="parent_id",
                                     additional_args={
                                         "parent_class": "OperationType",
                                         "name": "documentation"
                                     }),
        precondition=HasOneFromMany("Code", ref="parent_id",
                                    additional_args={
                                        "parent_class": "OperationType",
                                        "name": "precondition"
                                    }),
        protocol=HasOneFromMany("Code", ref="parent_id",
                                additional_args={
                                    "parent_class": "OperationType",
                                    "name": "protocol"
                                })
    )

    def code(self, accessor):
        # raise DeprecationWarning("This method is depreciated. Call code directly using 'protocol', 'cost_model',"
        #                          " 'documentation', or 'precondition'.")
        if accessor in ["protocol", 'precondition', 'documentation', 'cost_model']:
            return getattr(self, accessor)
        return None

    def instance(self, xpos=0, ypos=0):
        operation = self.session.Operation.new(operation_type_id=self.id,
                                               status='planning', x=xpos, y=ypos)
        operation.operation_type = self
        operation.init_field_values()
        return operation

    def field_type(self, name, role):
        if self.field_types:
            fts = filter_list(self.field_types, role=role, name=name)
            if len(fts) > 0:
                return fts[0]

    def output(self, name):
        return self.field_type(name, "output")

    def input(self, name):
        return self.field_type(name, "input")

    def save(self):
        """Saves the Operation Type to the Aquarium server. Requires
        this Operation Type to be connected to a session."""
        return self.reload(self.session.utils.create_operation_type(self))

    def __str__(self):
        return self._to_str('id', 'name', 'category')


@add_schema
class PartAssociation(ModelBase):
    """
    Represents a PartAssociation linking a part to a collection.

    Aquarium definition has the collection as an Item. Not sure why this isn't a Collection.
    """
    fields = dict(
        part=HasOne('Item', ref="part_id"),
        collection=HasOne('Collection')
    )

    def __init__(self, part_id=None, collection_id=None, row=None, column=None):
        super().__init__(
            part_id=part_id,
            collection_id=collection_id,
            row=row,
            column=column
        )

# TODO: API_CHANGE: Plan.copy() no longer reroutes to replan
@add_schema
class Plan(DataAssociatorMixin, ModelBase):
    """
    A Plan model
    """
    fields = dict(
        data_associations=HasManyGeneric("DataAssociation", additional_args={
            "parent_class": "Plan"
        }),
        plan_associations=HasMany("PlanAssociation", "Plan"),
        operations=HasManyThrough("Operation", "PlanAssociation"),
        wires=Many("Wire", callback="_get_wires"),
        layout=JSON(),
        status=Raw(default="planning")
    )

    def __init__(self, name="MyPlan", status="planning"):
        super().__init__(
            name=name,
            status=status,
            data_associations=None,
            plan_associations=None,
            layout={
                "id": 0,
                "children": [],
                "documentation": "No documentation of this module",
                "height": 60,
                "input": [],
                "output": [],
                "name": "no_name",
                "parent_id": -1,
                "width": 160,
                "wires": []
            }
        )

    def add_operation(self, operation):
        """
        Adds an operation to the Plan

        :param operation: Operation to add
        :type operation: Operation
        :return: None
        :rtype: None
        """
        self.append_to_many('operations', operation)

    def add_operations(self, operations):
        """
        Adds multiple operations to the Plan

        :param operations: list of Operations
        :type operations: list
        :return: None
        :rtype: None
        """
        for operation in operations:
            self.add_operation(operation)

    def has_operation(self, op):
        return self.operations and op.rid in [_op.rid for _op in self.operations]

    def find_wires(self, src, dest):
        """
        Retrieves the wire between a source and destination FieldValues

        :param src: source FieldValue
        :type src: FieldValue
        :param dest: destination FieldValue
        :type dest: FieldValue
        :return: array of wires between src and dest FieldValues (determined by rid)
        :rtype: array of wires
        """

        found = []
        for wire in self.wires:
            if src.rid == wire.source.rid and dest.rid == wire.destination.rid:
                found.append(wire)
        return found

    def wire(self, src, dest):
        """
        Creates a new wire between src and dest FieldValues. Returns the new wire
        if it does not exist in the plan. If the wire already exists and
        error_if_exists is True, then the existing wire is returned. Else an exception is raised.

        :param src: source field value (the input of the wire)
        :type src: FieldValue
        :param dest: destination field value (the output of the wire)
        :type dest: FieldValue
        :param error_if_exists: Raise an error if the Wire already exists in the plan.
        :type error_if_exists: boolean
        :return: Newly created wire or existing wire (if exists and error_if_exists == False)
        :rtype: Wire
        """

        if not self.has_operation(src.operation):
            raise AquariumModelError("Cannot wire because the wire's source FieldValue does not exist in the Plan.")
        if not self.has_operation(dest.operation):
            raise AquariumModelError("Cannot wire because the wire's destination FieldValue does not exist in the Plan.")

        return src.wire_to(dest)

    # TODO: assert incoming and outgoing wires are the same
    def _collect_wires(self):
        incoming_wires = []
        outgoing_wires = []
        if self.operations:
            for operation in self.operations:
                if operation.field_values:
                    for field_value in operation.field_values:
                        if field_value.outgoing_wires:
                            outgoing_wires += field_value.outgoing_wires
                        if field_value.incoming_wires:
                            incoming_wires += field_value.incoming_wires
        return incoming_wires, outgoing_wires

    def _get_wire_dict(self, wires):
        """Return all wires in the plan grouped by the wire identifier"""
        wire_dict = {}
        for w in wires:
            wire_dict.setdefault(w.identifier, list())
            if w not in wire_dict[w.identifier]:
                wire_dict[w.identifier].append(w)
        return wire_dict

    # TODO: BOOKMARK: fix _get_wires upon plan loading; implement rewire_to and rewire_from; implement _merge_wires after __init__?
    def _get_wires(self, *args):
        incoming_wires, outgoing_wires = self._collect_wires()

        iwiredict = self._get_wire_dict(incoming_wires)
        owiredict = self._get_wire_dict(outgoing_wires)

        for warr in iwiredict.values():
            if len(warr) > 1:
                raise AquariumModelError("There are duplicate wires in the plan")

        for warr in owiredict.values():
            if len(warr) > 1:
                raise AquariumModelError("There are duplicate wires in the plan")

        assert len(iwiredict) == len(owiredict)

        return sorted(incoming_wires, key=lambda w: w.id)

    # TODO: plan.create should be implicit in 'save'
    def create(self):
        """
        Creates the Plan on the Aquarium server.

        :return: Submitted Plan (self)
        :rtype: Plan
        """
        return self.session.utils.create_plan(self)

    def submit(self, user, budget):
        """
        Submits the Plan to the Aquarium server.

        :param user: User to submit the Plan
        :type user: User
        :param budget: Budget to use for the Plan
        :type budget: Budget
        :return: JSON
        :rtype: dict
        """
        result = self.session.utils.submit_plan(self, user, budget)
        return result

    def all_data_associations(self):
        das = self.data_associations
        for operation in self.operations:
            das += operation.data_associations
            for field_value in operation.field_values:
                if field_value.item:
                    das += field_value.item.data_associations
        return das

    @classmethod
    def interface(cls, session):
        # get model interface from Base class
        model_interface = super(Plan, cls).interface(session)

        # make a special find method for plans, as generic method is too minimal.
        def new_find(model_id): return model_interface.get(
            'plans/{}.json'.format(model_id))

        # override the old find method
        model_interface.find = new_find

        return model_interface

    def validate(self, raise_error=True):
        """
        Validates the plan.

        :param raise_error: If True, raises an AquariumModelException. If false, returns the error messages.
        :type raise_error: boolean
        :return: list of error messages
        :rtype: array
        """
        errors = []

        field_values = []
        for op in self.operations:
            for fv in op.field_values:
                field_values.append(fv)
        fv_rids = [fv.rid for fv in field_values]

        for wire in self.wires:
            for _fvtype in ['source', 'destination']:
                field_value = getattr(wire, _fvtype)
                if field_value.rid not in fv_rids:
                    msg = "The FieldValue of a wire Wire(rid={}).{} is missing from the list" \
                          " of FieldValues in the plan. Did you forget to add an operation to "\
                          " the plan?".format(
                        wire.rid, _fvtype,
                    )
                    errors.append(msg)
        if raise_error and errors:
            msg = '\n'.join(["({}) - {}".format(i, e) for i, e in  enumerate(errors)])
            raise AquariumModelError("Plan {} had the following errors:\n{}".format(msg))
        return errors

    def to_save_json(self):
        """
        Returns the json representation of the plan for saving and creating
        Plans on the Aquarium server.

        :return: JSON
        :rtype: dict
        """
        self.validate(raise_error=True)

        json_data = self.dump(include={
            'operations': {
                'field_values': {},
            }
        })

        # remove redundant wires
        wire_dict = {}
        for wire in self.wires:
            wire_data = wire.to_save_json()
            attributes = [
                wire_data['from_id'],
                wire_data['from']['rid'],
                wire_data['to_id'],
                wire_data['to']['rid']
            ]
            wire_hash = "*&".join([str(a) for a in attributes])
            wire_dict[wire_hash] = wire_data
        json_data['wires'] = list(wire_dict.values())

        # validate
        fv_rids = []
        for op in json_data['operations']:
            for fv in op['field_values']:
                fv_rids.append(fv['rid'])

        warnings = []
        for wire_data in json_data['wires']:
            if not wire_data['from']['rid'] in fv_rids:
                warnings.append('rid {} is missing!'.format(wire_data['from']['rid']))
            if not wire_data['to']['rid'] in fv_rids:

                warnings.append('rid {} is missing!'.format(wire_data['to']['rid']))
        if warnings:
            print(warnings)

        if json_data['layout'] is not None:
            json_data['layout'] = json.loads(json_data['layout'])
        else:
            del json_data['layout']

        return json_data

    def estimate_cost(self):
        """
        Estimates the cost of the plan on the Aquarium server.
        This is necessary before plan submission.

        :return: cost
        :rtype: dict
        """
        return self.session.utils.estimate_plan_cost(self)

    def field_values(self):
        raise NotImplementedError()

    def step(self):
        """Steps a plan"""
        return self.session.utils.step_plan(self.id)

    def show(self):
        """Print the plan nicely"""
        print(self.name + " id: " + str(self.id))
        for operation in self.operations:
            operation.show(pre="  ")
        for wire in self.wires:
            wire.show(pre="  ")

    def save(self):
        """
        Updates/patches the plan on the Aquarium server

        :return: updated Plan (self)
        :rtype: Plan
        """
        return self.session.utils.save_plan(self)

    def delete(self):
        """
        Deletes the plan on the Aquarium server

        :return: None
        :rtype: None
        """
        return self.session.utils.delete_plan(self)

    def replan(self):
        """Copies or replans the plan. Returns a plan copy"""
        return self.session.utils.replan(self.id)

    def download_files(self, outdir=None, overwrite=True):
        """
        Downloads all uploads associated with the plan. Downloads happen
        ansynchrounously.

        :param outdir: output directory for downloaded files
        :param overwrite: whether to overwrite files if they exist
        :return: None
        """
        uploads = []
        for da in self.data_associations:
            if da.upload is not None:
                uploads.append(da.upload)
        return Upload.async_download(uploads, outdir, overwrite)


@add_schema
class PlanAssociation(ModelBase):
    """A PlanAssociation model"""
    fields = dict(
        plan=HasOne("Plan"),
        operation=HasOne("Operation")
    )

    def __init__(self, plan_id=None, operation_id=None):
        super().__init__(
            plan_id=plan_id,
            operation_id=operation_id
        )


@add_schema
class Sample(FieldValueInterface, ModelBase):
    """A Sample model"""
    fields = dict(
        # sample relationships
        sample_type=HasOne("SampleType"),
        items=HasMany("Item", ref="sample_id"),
        field_values=HasMany("FieldValue",
                             ref="parent_id",
                             additional_args={"parent_class": "Sample"}),

        # TODO: add new sample relationships to change log
        field_values_as_properties=HasMany("FieldValue",
                                         ref="child_sample_id",
                                         additional_args={
                                             "parent_class": "Sample"
                                         }),
        field_values_as_outputs=HasMany("FieldValue",
                                       ref="child_sample_id",
                                       additional_args={
                                           "parent_class": "Operation",
                                           "role": "output"
                                       }
                                       ),
        field_values_as_inputs=HasMany("FieldValue",
                                      ref="child_sample_id",
                                      additional_args={
                                          "parent_class": "Operation",
                                          "role": "input"
                                      }
                                      ),
        operations_as_outputs=HasManyThrough("Operation", "FieldValuesAsOutput"),
        operations_as_inputs=HasManyThrough("Operation", "FieldValuesAsInput"),
        parent_samples=HasManyThrough("Sample", "FieldValuesAsProperty")
    )

    METATYPE = "sample_type"

    def __init__(self, name=None, project=None, description=None, sample_type=None, sample_type_id=None,
                 properties=None):
        """

        :param name:
        :type name:
        :param project:
        :type project:
        :param description:
        :type description:
        :param sample_type_id:
        :type sample_type_id:
        :param properties:
        :type properties:
        """
        super().__init__(
            name=name,
            project=project,
            description=description,
            sample_type_id=sample_type_id,
            sample_type=sample_type,
            field_values=None,
            items=None,
        )
        if properties is not None:
            self.update_properties(properties)

    @property
    def identifier(self):
        """Return the identifier used by Aquarium in autocompletes"""
        return "{}: {}".format(self.id, self.name)

    def field_value(self, name):
        """
        Returns the :class:`FieldValue` associated with the sample by its name. If the there is more than one FieldValue
        with the same name (as in field_value arrays), it will return the first FieldValue.
        See the :method:`Sample.field_value_array` method.

        :param name: name of the field value
        :type name: str
        :return: the field value
        :rtype: FieldValue
        """
        return self.get_field_value(name, None)

    def field_value_array(self, name):
        return self.get_field_value_array(name, None)

    @staticmethod
    def _property_accessor(fv):
        if fv.ftype == 'sample':
            return fv.sample
        else:
            return fv.value

    @property
    def properties(self):
        return self._field_value_dictionary(
            lambda ft: ft.name,
            self._property_accessor
        )

    def update_properties(self, prop_dict):
        """
        Update the FieldValues properties for this sample.

        :param prop_dict: values to update
        :type prop_dict: dict
        :return: self
        :rtype: Sample
        """
        pass

    def save(self):
        """Saves the Sample to the Aquarium server. Requires
        this Sample to be connected to a session."""
        self.session.utils.create_samples([self])
        return self

    def update(self):
        self.session.utils.update_sample(self)
        return self

    def available_items(self, object_type_name=None, object_type_id=None):
        query = {"name": object_type_name, "id": object_type_id}
        query = {k: v for k, v in query.items() if v is not None}
        if query == {}:
            return [i for i in self.items if i.location != 'deleted']
        else:
            object_types = self.session.ObjectType.where(query)
            object_type = object_types[0]
            return [i for i in self.items if i.location != 'deleted' and
                    i.object_type_id == object_type.id]

    def copy(self):
        """Return a copy of this sample."""
        copied = super().copy()
        copied.anonymize()
        return copied

    def __str__(self):
        return self._to_str('id', 'name', 'sample_type')


@add_schema
class SampleType(FieldTypeInterface, ModelBase):
    """A SampleType model"""
    fields = dict(
        samples=HasMany("Sample", "SampleType"),
        field_types=HasMany("FieldType", ref="parent_id", additional_args={"parent_class": "SampleType"}),

        # TODO: operation_type_afts
        # TODO: property_afts
        # TODO: add relationships description
    )

    @property
    def properties(self):
        props = {}
        for ft in self.field_types:
            if ft.ftype == 'sample':
                props[ft.name] = [str(aft) for aft in ft.allowable_field_types]
            else:
                props[ft.name] = ft.ftype
        return props

    def new_sample(self, name, description, project, properties=None):
        if properties is None:
            properties = dict()
        sample = self.session.Sample.new(
            name=name,
            sample_type=self,
            description=description,
            project=project,
            properties=properties
        )
        return sample

    def save(self):
        """Saves the Sample Type to the Aquarium server. Requires
        this Sample Type to be connected to a session."""
        return self.reload(self.session.utils.create_sample_type(self))

    def __str__(self):
        return self._to_str('id', 'name')


# TODO: expiring_url is never updated..
@add_schema
class Upload(ModelBase):
    """
    An Upload model
    """
    fields = dict(
        job=HasOne("Job")
    )

    def __init__(self, job_id=None, file=None):
        """
        Create a new upload

        :param job_id: job id to associate the upload to
        :type job_id: int
        :param file: file to upload
        :type file: file object
        """
        super().__init__(
            job_id=job_id,
        )
        self.file = file

    # def _get_uploads_from_job_id(self, job_id):

    def _get_uploads_from_job(self):
        http = self.session._AqSession__aqhttp
        return http.get("krill/uploads?job={}".format(self.job_id))['uploads']

    def temp_url(self):
        data = self.session.Upload.where(
            {"id": self.id}, methods=["expiring_url"])[0].raw
        return data['expiring_url']

    @staticmethod
    def _download_file_from_url(url, outpath):
        """
        Downloads a file from a url

        :param url: url of file
        :type url: str
        :param outpath: filepath of out file
        :type outpath: str
        :return: http response
        :rtype: str
        """
        response = requests.get(url, stream=True)
        with open(outpath, 'wb') as out_file:
            shutil.copyfileobj(response.raw, out_file)
        return response.raw

    @staticmethod
    @make_async(1)
    def async_download(uploads, outdir=None, overwrite=True):
        """
        Asynchronously downloads from list of :class:`Upload` models.

        :param uploads: list of Uploads
        :type uploads: list
        :param outdir: path to output directory to save downloaded files
        :type outdir: str
        :param overwrite: if True, will overwrite existing files
        :type overwrite: bool
        :return: list of filepaths
        :rtype: list
        """
        return Upload._download_files(uploads, outdir, overwrite)

    @staticmethod
    def _download_files(uploads, outdir, overwrite):
        """
        Downloads uploaded file from list of :class:`Upload` models.

        :param uploads: list of Uploads
        :type uploads: list
        :param outdir: path to output directory to save downloaded files (defaults to current directory)
        :type outdir: str
        :param overwrite: if True, will overwrite existing files (default: True)
        :type overwrite: bool
        :return: list of filepaths
        :rtype: list
        """
        filepaths = []
        for upload in uploads:
            filepath = upload.download(outdir=outdir, overwrite=overwrite)
            filepaths.append(filepath)
        return filepaths

    def download(self, outdir=None, filename=None, overwrite=True):
        """
        Downloads the uploaded file to the specified output directory. If
        no output directory is specified, the file will be downloaded to the
        current directory.

        :param outdir: path of directory of output file (default is current directory)
        :param outfile: filename of output file (defaults to upload_filename)
        :param overwrite: whether to overwrite file if it already exists
        :return: None
        """
        if outdir is None:
            outdir = '.'
        if filename is None:
            filename = "{}_{}".format(self.id, self.upload_file_name)
        filepath = os.path.join(outdir, filename)
        if not os.path.exists(filepath) or overwrite:
            self._download_file_from_url(self.temp_url(), filepath)
        return filepath

    @property
    def data(self):
        """Return the data associated with the upload."""
        result = requests.get(self.temp_url())
        return result.content

    def save(self):
        """Save the upload to the server."""
        return self.session.utils.create_upload(self)


@add_schema
class User(ModelBase):
    """A User model"""
    fields = dict(
        groups=HasMany("Group", "User"),
        user_budget_associations=HasMany("UserBudgetAssociation", "User"),
        budgets=HasManyThrough("Budget", "UserBudgetAssociation"),
        additional=("name", "id", "login"),
        ignore=("password_digest", "remember_token", "key")
    )

    def __init__(self):
        pass


@add_schema
class UserBudgetAssociation(ModelBase):
    """An association model between a User and a Budget"""
    fields = dict(
        budget=HasOne("Budget"),
        user=HasOne("User")
    )

    def __init__(self):
        pass


@add_schema
class Wire(ModelBase):
    """A Wire model"""
    fields = {
        "from": HasOne("FieldValue", ref="from_id"),
        "to": HasOne("FieldValue", ref="to_id"),
        "source": fields.Alias("from"),
        "destination": fields.Alias("to")
    }

    WIRABLE_PARENT_CLASSES = ['Operation']

    def __init__(self, source=None, destination=None):

        self._validate_field_values(source, destination)

        if hasattr(source, 'id'):
            from_id = source.id
        else:
            from_id = None

        if hasattr(destination, 'id'):
            to_id = destination.id
        else:
            to_id = None

        super().__init__(**{
            "from": source,
            "from_id": from_id,
            "to": destination,
            "to_id": to_id
        }, active=True)

    @property
    def identifier(self):

        if not self.source:
            source_id = self.from_id
        else:
            source_id = 'r' + str(self.source.rid)

        if not self.destination:
            destination_id = self.to_id
        else:
            destination_id = 'r' + str(self.destination.rid)
        return '{}_{}'.format(source_id, destination_id)

    @classmethod
    def _validate_field_values(cls, src, dest):
        if src:
            cls._validate_field_value(src, 'source')
        if dest:
            cls._validate_field_value(dest, 'destination')

        if src and dest and src.rid == dest.rid:
            raise AquariumModelError("Cannot create wire because source and destination are the same instance.")

    @classmethod
    def _validate_field_value(cls, fv, name):
        if not issubclass(type(fv), FieldValue):
            raise AquariumModelError("Cannot create wire because {} FieldValue is {}.".format(name, fv.__class__.__name__))

        if fv.parent_class not in cls.WIRABLE_PARENT_CLASSES:
            raise AquariumModelError("Cannot create wire because the {} FieldValue is has a {} parent class" \
                                     "Only {} parent classes are wirable".format(name, fv.parent_class, self.WIRABLE_PARENT_CLASSES))

    def validate(self):
        self._validate_field_values(self.source, self.destination)

    def to_save_json(self):
        save_json = {
            "id": self.id,
            "from_id": self.source.id,
            "to_id": self.destination.id,
            "from": {"rid": self.source.rid},
            "to": {"rid": self.destination.rid},
            "active": self.active
        }
        return save_json

    def delete(self):
        """
        Permanently deletes the wire instance on the Aquarium server.
        :return:
        :rtype:
        """
        return self.session.utils.delete_wire(self)

    def show(self, pre=""):
        """Show the wire nicely"""
        source = self.source
        dest = self.destination

        from_op_type_name = 'None'
        from_name = 'None'
        if source:
            from_op_type_name = self.source.operation.operation_type.name
            from_name = source.name

        to_op_type_name = 'None'
        to_name = 'None'
        if dest:
            to_op_type_name = self.destination.operation.operation_type.name
            to_name = dest.name

        print(pre + from_op_type_name +
              ":" + from_name +
              " --> " + to_op_type_name +
              ":" + to_name)

    def does_wire(self, source, destination):
        """Checks whether this Wire is a wire between the source and destination FieldValues.

        If any of the source or destination FieldValues are None, returns False."""
        if source and destination and self.source and self.destination:
            return source.rid == self.source.rid and destination.rid == self.destination.rid
        return False

    def __eq__(self, other):
        """Checks whether this Wire is wired to the same FieldValue instances of another Wire.

        see `does_wire` method."""
        return self.does_wire(other.source, other.destination)