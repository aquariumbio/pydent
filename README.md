# Developer Notes

# Trident Request Pipeline

### AqHTTP (makes raw requests)

AqHTTP contains methods for logging into aquarium and making generic http requests.
Since AqHTTP can make generic requests that could be potentially damaging or reveal
sensitive information, Trident users should never have direct access to AqHTTP.

### Sessions (holds AqHTTP instances)

A "Session" ties a particular login/password/server to an AqHTTP instance. Sessions are able to
create several SessionInterfaces, which define a particular way to use AqHTTP.

### SessionInterface (uses AqHTTP to make requests)

A SessionInterface exposes several methods for interacting with Aquarium via AqHTTP.
SessionInterfaces are creates from sessions by calling attributes:

```python
mysession = AqSession(username, password, aquarium_url)

mysession.Sample
# => ModelInterface using model "Sample"

mysession.SampleType
# => ModelInterface using model "SampleType"

mysession.create
# => CreateInterface for creating things

mysession.update
# => UpdateInterface for updating things
```

For example, creating a session and using it to find models
```python
mysession = AqSession(username, password, aquarium_url)

mysession.Sample
# => a ModelInterface tied to the "Sample" model

mysession.Sample.find(1)
# => <Sample(id=1, ...)>
```

# Models

## Schema

Schemas define how objects are serialized and deserialized. Schemas are dynamically
generated by adding the `add_schema` decorator to the model class. Field options for
serializing and deserializing are defined in the `class Fields:` within the model
class definition (see below).

## Models

Models inherit the base class and should have an `@add_schema` decorator. Optionally, models
may have a `class Fields:` if relationships or other fields are defined for that model.

Below is the bare minimum for defining a model:

```python
@add_schema
class Account(Base):
    pass
```

If the model requires a more definite initializer, the initalizer *always* requires a
'data' argument, which is used to load the model from JSON data. The data that is received,
is captured by the model instance as attributes.
```python
@add_schema
class Account(Base):
    def __init__(*args, data=None, **kwargs):
        super().__init__(data=data)
        # do stuff with args and kwargs
```

## Serialization/Deserialization

The `load` method uses the model's schema to create an instance of the model from a JSON

```python
u = User.load(json_data)
# => <User>

s = Sample.load(json_data)
# => <Sample>
```

The `dump` method uses the model's schema to dump the instance to a JSON

```python
u.dump()
# => {"id": 1, "name": "John", ...}
```

Dump and load methods can take arguments:

```python
u.dump(only=("id",))
# => {"id": 1}
```

## Fields

The fields class contains several optional arguments for defining how that object is serialized
and deserialized. By default, models capture all attributes passed by 'data.' However, if some
information that is returned in a http request to Aquarium is sensitive, for example, you may
ignore that information by adding the `ignore` attribute to the `Fields` class with the keys
you wish to ignore. Many other options exist (see example below).

```python
@add_schema
class SampleType(Base):

    class Fields:
        # define relationships here
        samples = HasMany("Sample")

        # field options
        load_all = True  # load missing data attributes not explicitly defined during serialization
        strict = True  # throw error during marshalling instead of storing error
        include = {}  # fields to include for serialization/deserialization. Grouped with fields defined in model class
        additional = () # explicitly defined fields for serialization/deserialization.
        ignore = ()  # fields to filter during deserialization. These fields will be filtered from the JSON.
        load_only = ()  # fields to ignore during serialization
        dump_only = ()  # fields to ignore during deserialization

    # optional
    def __init__(..., data=None, ...):
        super().__init__(data=data)
        ...

    # optional model specific methods
    def foo(self):
        ...
```

## Relationships

Models can possess heirarchical relationships with other models, which map
the underlying Aquairum database.

#### Single Relationships

##### generic - One
`One("Sample", params=lambda self: self.parent_id)`: use session to find sample as in
`session.Sample.find(self.parent_id)`

##### implied - HasOne

`HasOne("Sample")`: use session to find as in
`session.Sample.find(self.sample_id)`

#### Many Relationships

##### generic - Many

`Many("Sample", params=lambda self: {"parent_id": self.id})`: use session to find sample as in
`session.Sample.where({"parent_id": self.id})`

##### implied - HasMany

`HasMany("Sample")`: use session to find as in
`session.Sample.where({"sample_id": self.id})`

```
    ...
    @property
    def sample(self):
        self.session.Sample.where({"sample_id": self.id})
```