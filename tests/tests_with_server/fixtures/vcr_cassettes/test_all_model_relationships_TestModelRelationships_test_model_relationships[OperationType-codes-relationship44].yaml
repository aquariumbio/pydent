interactions:
- request:
    body: '{"model": "OperationType", "method": "where", "arguments": {}, "options":
      {"offset": -1, "limit": 1, "reverse": true}}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['118']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=xZ6egEhh%2BlChVfXVPVD8YDggenvqtv9YVI1kUABHZSqerspp7tLf1BOFEB5vpSJ3RUUQmElNf2kq8Up%2BqGs3ow%3D%3D;
          _aquarium_NURSERY_production_session=WEdBOGo4U21nWnJkZDByZ2ErSE1FeFpEVkE1OVM4ZFJPTFNNcnd5NlhQOWQyQ2lETk1rVDFnYmNwbFBiWnlnMTFkSzQ1ZFkxUklGcE0rMmNnMmZHVm1PWk9LLzNUVTBCd1liZkxDMVBBeXBmaUEwZHJaTjhvWFNsVFpVQ2Zmd3RyQlNWRlV5NytET3BqNUVraGtldXBFQzh2eEx2emF2cDRxM2lJSFM4OEJIZlpXaUNYblMxREZWc0E5ZnJTMlBEVWhkOFVGNDBWbDVacXEvcC92L0cveklUSmdRN0lYalRGbHJMalc1VnZvWkh4SjJvdzUxU25UdXNzQmFPSERadVFEVmZ3Q1dPaEVFZnlwVVpZR2c1Y2F1VVZTN3lrdWV0TDV6Um9vYUxKWHQ2a01tdlAvMEhhUTdKUW5tM3pHRUFiK0lsWjI5SnFTWDJiYVlGclY0RlppQ21MZVRuOUh0T1hvbnZIbHFZWjZVNzdLVGl0aTFFa2tyVytVeHpZMXM3aWZJMDFycENoblZEblBwTEtGcWRKcFVtMFZzWFJ1TkEyNmVlVkdaWFhPYz0tLTZoVW9XMzJuV0doLys5Y3UxNngxOFE9PQ%3D%3D--1cac2424c270f93e630e78a91a59326644cf5ee8;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '[{"id":1539,"name":"Make PCR Fragment (copy)","category":"ZAbeTest","deployed":false,"on_the_fly":false,"created_at":"2018-10-29T14:37:27.000-07:00","updated_at":"2018-10-29T14:39:02.000-07:00"}]'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:14:49 GMT']
      ETag: [W/"cac7a4ab9d35e701807538ddac13bc65"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=DzJMpZUG5VELWf6JdPnP3IhS%2FjPvjbCFS4Z%2FWl7VtiZUAhhMM7XA1bmJG0ImDBHL9TeU0Ex2MLQ1%2BlF09vnkrw%3D%3D;
          path=/, _aquarium_NURSERY_production_session=OUQ0YVNZTTJLYzdSY2RObFZxSzF4RWNEckxJOGJ0a3lIa0o5dEJYM2N6VkhldzJJdjBtUDRuRFNyZDdsZDk5b0lEV2JQS1VjK2g0L21RZ1haa0NKSmJGUHhvZFBTdWRER0YyRVorZGcxdkY4OGdFQkUwWGV1dENoNnl6YlNYTFNQQTdaYmZwTlVUZHFVWmVlWXY5cThRVDFvTTFTekJlVWtmczM1WEpabkpRMVVvUWZpV3Q0YzVsamV5VTJ1MTVJVktZNXI4dW12Ly9WSFE5UVpwSElsN2Rpa1RXQjRkNkZ1Zmgva3o2T2lQQWxLU2hXYUhNZGhQb08xOUJFRzhJMW1xTXdOaFFUSy9jUkk5RWFUek9za216d3NQT2JxOVdhSFNCaXBMbWJnMS9OVm8zSzFaN3hxR1RwbmwvMGhrN0lZNEhnSGp2aS9FT0pvek1PWTZGT2lTbk5tb1pBTk9mTWZFTlFRdUkwUE1SakNEQmpkZDErbUJCZEJYWWE0WE9mZDhCOXdJY3diNE9jcFo4eENJU1MvMEZNcDg1MHR6azhqRXV0ZmJ2RmNYOD0tLXMyTS9SL0FmNHMvN1VtQW5LQnZEUlE9PQ%3D%3D--aed0f01141f812436d2da6c90b1752622163577c;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [2dde37c2-d36e-40ba-8652-9d830d8bf406]
      X-Runtime: ['0.004866']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Code", "method": "where", "arguments": {"parent_id": 1539},
      "options": {"offset": -1, "limit": -1, "reverse": false}}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['128']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=xZ6egEhh%2BlChVfXVPVD8YDggenvqtv9YVI1kUABHZSqerspp7tLf1BOFEB5vpSJ3RUUQmElNf2kq8Up%2BqGs3ow%3D%3D;
          _aquarium_NURSERY_production_session=WEdBOGo4U21nWnJkZDByZ2ErSE1FeFpEVkE1OVM4ZFJPTFNNcnd5NlhQOWQyQ2lETk1rVDFnYmNwbFBiWnlnMTFkSzQ1ZFkxUklGcE0rMmNnMmZHVm1PWk9LLzNUVTBCd1liZkxDMVBBeXBmaUEwZHJaTjhvWFNsVFpVQ2Zmd3RyQlNWRlV5NytET3BqNUVraGtldXBFQzh2eEx2emF2cDRxM2lJSFM4OEJIZlpXaUNYblMxREZWc0E5ZnJTMlBEVWhkOFVGNDBWbDVacXEvcC92L0cveklUSmdRN0lYalRGbHJMalc1VnZvWkh4SjJvdzUxU25UdXNzQmFPSERadVFEVmZ3Q1dPaEVFZnlwVVpZR2c1Y2F1VVZTN3lrdWV0TDV6Um9vYUxKWHQ2a01tdlAvMEhhUTdKUW5tM3pHRUFiK0lsWjI5SnFTWDJiYVlGclY0RlppQ21MZVRuOUh0T1hvbnZIbHFZWjZVNzdLVGl0aTFFa2tyVytVeHpZMXM3aWZJMDFycENoblZEblBwTEtGcWRKcFVtMFZzWFJ1TkEyNmVlVkdaWFhPYz0tLTZoVW9XMzJuV0doLys5Y3UxNngxOFE9PQ%3D%3D--1cac2424c270f93e630e78a91a59326644cf5ee8;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: "[{\"id\":89285,\"name\":\"protocol\",\"content\":\"needs \\\"Cloning
        Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds 'Standard
        Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n    \\n
        \ # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/L Plasmid Stock\\\" : \\\"1 ng/L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/L Template Stocks\\\"\\n      \\n      check \\\"Grab
        #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with #{ops_w_undiluted_template.map
        { |op| op.temporary[:diluted_stock].id }.join(\\\", \\\")}\\\"\\n      check
        \\\"Add template stocks and water into newly labeled 1.5 mL tubes following
        the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n          .start_table\\n
        \         .custom_column(heading: \\\"Newly-labeled tube\\\") { |op| op.temporary[:diluted_stock].id
        }\\n          .input_item(input, heading: \\\"Template stock, 1 uL\\\", checkable:
        true)\\n          .custom_column(heading: \\\"Water volume\\\", checkable:
        true) { |op| op.input(input).item.get(:concentration).to_f - 1 }\\n          .end_table\\n
        \     check \\\"Vortex and then spin down for a few seconds\\\"\\n    end\\n
        \   \\n    # return input stocks\\n    release ops_w_undiluted_template.map
        { |op| op.input(input).item }, interactive: true, method: \\\"boxes\\\"\\n
        \   \\n    # retrieve the rest of the inputs\\n    operations.reject { |op|
        ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set diluted
        stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:37:28.000-07:00\",\"updated_at\":\"2018-10-29T14:37:28.000-07:00\",\"user_id\":193},{\"id\":89286,\"name\":\"precondition\",\"content\":\"def
        validate_property sample, field_name\\r\\n  validation_block = Proc.new\\r\\n
        \ property = sample.properties[field_name]\\r\\n  if property.nil?\\r\\n    raise
        \\\"Could not find property #{field_name}\\\"\\r\\n  end\\r\\n  validation_block.call(sample,
        property)\\r\\nend\\r\\n\\r\\n# Appends associates msgs to plan and operation\\r\\ndef
        precondition_warnings op, msgs, key=:precondition_warnings, sep=\\\";\\\"\\r\\n
        \ plan = op.plan\\r\\n  if plan\\r\\n    plan_msg = op.plan.get key\\r\\n
        \   plan_msgs = plan_msg.split(sep).map { |x| x.strip } if plan_msg\\r\\n
        \ end\\r\\n  plan_msgs ||= []\\r\\n  op_msgs = []\\r\\n\\r\\n  msgs.each {
        |valid, m|\\r\\n    if valid\\r\\n      plan_msgs.delete(m)\\r\\n    else\\r\\n
        \     plan_msgs \\u003c\\u003c m\\r\\n      op_msgs \\u003c\\u003c m\\r\\n
        \   end\\r\\n  }\\r\\n  op_msgs.uniq!\\r\\n  plan_msgs.uniq!\\r\\n\\r\\n  op.associate
        key, op_msgs.join(sep + \\\" \\\")\\r\\n  op.plan.associate key, plan_msgs.join(sep
        + \\\" \\\") if op.plan\\r\\nend\\r\\n\\r\\ndef precondition(op)\\r\\n  ready
        = true\\r\\n  msgs = []\\r\\n  \\r\\n  #output fragment must have length!\\r\\n
        \ if op.output(\\\"Fragment\\\").sample.properties[\\\"Length\\\"].nil? ||
        op.output(\\\"Fragment\\\").sample.properties[\\\"Length\\\"] \\u003c= 0\\r\\n
        \     op.associate(\\\"Output Fragment must have a defined length!\\\", \\\"\\\")\\r\\n
        \     return false\\r\\n  end\\r\\n\\r\\n  # Validate sample, valid_block,
        valid_message\\r\\n  [\\\"Forward Primer\\\", \\\"Reverse Primer\\\"].each
        do |n|\\r\\n    sample = op.input(n).sample\\r\\n\\r\\n    msgs \\u003c\\u003c
        validate_property(sample, \\\"T Anneal\\\") { |s, property|\\r\\n      validator
        = Proc.new { |p| p.to_f.between?(0.01, 100) }\\r\\n      msg = \\\"T Anneal
        #{property} for Primer \\\\\\\"#{s.name}\\\\\\\" is invalid\\\"\\r\\n      [validator.call(property),
        msg]\\r\\n    }\\r\\n  end\\r\\n  msgs.select! { |valid, m| !valid }\\r\\n
        \ msgs.compact!\\r\\n  precondition_warnings op, msgs\\r\\n  ready = false
        if msgs.any?\\r\\n  ready\\r\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:37:28.000-07:00\",\"updated_at\":\"2018-10-29T14:37:28.000-07:00\",\"user_id\":193},{\"id\":89287,\"name\":\"cost_model\",\"content\":\"#
        Kilroy was here 2017-10-18 22:33:52\\n# Kilroy was here 2017-09-28 05:11:58\\n#
        Kilroy was here 2017-09-21 20:39:57\\n# Make PCR Fragment Cost Model\\n\\ndef
        cost(op)\\n    {\\n        materials: 1.04,\\n        labor: 6.45\\n    }
        \     \\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:37:28.000-07:00\",\"updated_at\":\"2018-10-29T14:37:28.000-07:00\",\"user_id\":193},{\"id\":89288,\"name\":\"documentation\",\"content\":\"This
        is run after **Extract Fragment** and is a precursor to **Assemble Plasmid**.
        The technician combines the inputted forward primer, reverse primer, and the
        template in a stripwell, and runs the PCR in a thermocycler. \",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:37:28.000-07:00\",\"updated_at\":\"2018-10-29T14:37:28.000-07:00\",\"user_id\":193},{\"id\":89290,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.running.make\\n          reaction[:stripwells] += ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:39:16.000-07:00\",\"updated_at\":\"2018-10-29T14:39:16.000-07:00\",\"user_id\":193},{\"id\":89291,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.running.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:40:06.000-07:00\",\"updated_at\":\"2018-10-29T14:40:06.000-07:00\",\"user_id\":193},{\"id\":89292,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    operations.make\\n
        \   show do\\n        note \\\"#{operations.output_collections[FRAGMENT]}\\\"\\n
        \   end\\n    \\n    # grab all necessary items\\n    dilute_stocks_and_retrieve
        TEMPLATE\\n    kapa_stock_item = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme
        Stock\\\")[0]\\n    take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n
        \   \\n    #check the volumes of input primers for all operations, and ensure
        they are sufficient\\n    operations.each { |op| op.temporary[:primer_vol]
        = 2.5 }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.running.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:41:42.000-07:00\",\"updated_at\":\"2018-10-29T14:41:42.000-07:00\",\"user_id\":193},{\"id\":89295,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    operations.make\\n
        \   show do\\n        note \\\"#{operations.output_collections[FRAGMENT]}\\\"\\n
        \   end\\n    \\n    # grab all necessary items\\n    dilute_stocks_and_retrieve
        TEMPLATE\\n    kapa_stock_item = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme
        Stock\\\")[0]\\n    take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n
        \   \\n    #check the volumes of input primers for all operations, and ensure
        they are sufficient\\n    operations.each { |op| op.temporary[:primer_vol]
        = 2.5 }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.running.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:43:54.000-07:00\",\"updated_at\":\"2018-10-29T14:43:54.000-07:00\",\"user_id\":193},{\"id\":89297,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n\\n    \\n    #
        grab all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    operations.make\\n    show do\\n        note
        \\\"#{operations.output_collections[FRAGMENT]}\\\"\\n    end\\n    \\n    #
        build a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info
        pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.running.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:44:04.000-07:00\",\"updated_at\":\"2018-10-29T14:44:04.000-07:00\",\"user_id\":193},{\"id\":89298,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # build
        a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info
        pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.running.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:44:21.000-07:00\",\"updated_at\":\"2018-10-29T14:44:21.000-07:00\",\"user_id\":193},{\"id\":89299,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # build
        a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info
        pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          operations.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:45:00.000-07:00\",\"updated_at\":\"2018-10-29T14:45:00.000-07:00\",\"user_id\":193},{\"id\":89300,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # build
        a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info
        pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          operations.make\\n          reaction[:stripwells] += operations.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:45:11.000-07:00\",\"updated_at\":\"2018-10-29T14:45:11.000-07:00\",\"user_id\":193},{\"id\":89301,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # build
        a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { \\n          title \\\"pcr #{idx}\\\"\\n          note
        pcrs.to_s  \\n      }\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          operations.make\\n          reaction[:stripwells] += operations.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:45:59.000-07:00\",\"updated_at\":\"2018-10-29T14:45:59.000-07:00\",\"user_id\":193},{\"id\":89303,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # build
        a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { \\n          title \\\"pcr #{idx}\\\"\\n          note
        pcrs.to_s  \\n      }\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += operations.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:46:33.000-07:00\",\"updated_at\":\"2018-10-29T14:46:33.000-07:00\",\"user_id\":193},{\"id\":89304,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # build
        a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { \\n          title \\\"pcr #{idx}\\\"\\n          note
        pcrs.to_s  \\n      }\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          show do note \\\"#{ops}\\\"\\n          ops.make\\n          reaction[:stripwells]
        += operations.output_collections[FRAGMENT]# ops.map { |op| op.output(FRAGMENT).collection
        }.uniq\\n      end\\n      pcr_reactions \\u003c\\u003c reaction\\n    end\\n
        \   pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:47:05.000-07:00\",\"updated_at\":\"2018-10-29T14:47:05.000-07:00\",\"user_id\":193},{\"id\":89305,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # build
        a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { \\n          title \\\"pcr #{idx}\\\"\\n          note
        pcrs.to_s  \\n      }\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          show do note \\\"#{ops}\\\" end\\n          ops.make\\n          reaction[:stripwells]
        += operations.output_collections[FRAGMENT]# ops.map { |op| op.output(FRAGMENT).collection
        }.uniq\\n      end\\n      pcr_reactions \\u003c\\u003c reaction\\n    end\\n
        \   pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:47:10.000-07:00\",\"updated_at\":\"2018-10-29T14:47:10.000-07:00\",\"user_id\":193},{\"id\":89307,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # build
        a pcrs hash that groups pcr by T Anneal\\n    pcrs = build_pcrs_hash\\n\\n
        \   # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { \\n          title \\\"pcr #{idx}\\\"\\n          note
        pcrs.to_s  \\n      }\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n
        \   \\n    pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#
        ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T14:47:37.000-07:00\",\"updated_at\":\"2018-10-29T14:47:37.000-07:00\",\"user_id\":193},{\"id\":89333,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:28:26.000-07:00\",\"updated_at\":\"2018-10-29T15:28:26.000-07:00\",\"user_id\":193},{\"id\":89334,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:35:17.000-07:00\",\"updated_at\":\"2018-10-29T15:35:17.000-07:00\",\"user_id\":193},{\"id\":89335,\"name\":\"precondition\",\"content\":\"def
        validate_property sample, field_name\\r\\n  validation_block = Proc.new\\r\\n
        \ property = sample.properties[field_name]\\r\\n  if property.nil?\\r\\n    raise
        \\\"Could not find property #{field_name}\\\"\\r\\n  end\\r\\n  validation_block.call(sample,
        property)\\r\\nend\\r\\n\\r\\n# Appends associates msgs to plan and operation\\r\\ndef
        precondition_warnings op, msgs, key=:precondition_warnings, sep=\\\";\\\"\\r\\n
        \ plan = op.plan\\r\\n  if plan\\r\\n    plan_msg = op.plan.get key\\r\\n
        \   plan_msgs = plan_msg.split(sep).map { |x| x.strip } if plan_msg\\r\\n
        \ end\\r\\n  plan_msgs ||= []\\r\\n  op_msgs = []\\r\\n\\r\\n  msgs.each {
        |valid, m|\\r\\n    if valid\\r\\n      plan_msgs.delete(m)\\r\\n    else\\r\\n
        \     plan_msgs \\u003c\\u003c m\\r\\n      op_msgs \\u003c\\u003c m\\r\\n
        \   end\\r\\n  }\\r\\n  op_msgs.uniq!\\r\\n  plan_msgs.uniq!\\r\\n\\r\\n  op.associate
        key, op_msgs.join(sep + \\\" \\\")\\r\\n  op.plan.associate key, plan_msgs.join(sep
        + \\\" \\\") if op.plan\\r\\nend\\r\\n\\r\\ndef precondition(op)\\r\\n  ready
        = true\\r\\n  msgs = []\\r\\n  \\r\\n  #output fragment must have length!\\r\\n
        \ if op.output(\\\"Fragment\\\").sample.properties[\\\"Length\\\"].nil? ||
        op.output(\\\"Fragment\\\").sample.properties[\\\"Length\\\"] \\u003c= 0\\r\\n
        \     op.associate(\\\"Output Fragment must have a defined length!\\\", \\\"\\\")\\r\\n
        \     return false\\r\\n  end\\r\\n\\r\\n  # Validate sample, valid_block,
        valid_message\\r\\n  [\\\"Forward Primer\\\", \\\"Reverse Primer\\\"].each
        do |n|\\r\\n    sample = op.input(n).sample\\r\\n\\r\\n    msgs \\u003c\\u003c
        validate_property(sample, \\\"T Anneal\\\") { |s, property|\\r\\n      validator
        = Proc.new { |p| p.to_f.between?(0.01, 100) }\\r\\n      msg = \\\"T Anneal
        #{property} for Primer \\\\\\\"#{s.name}\\\\\\\" is invalid\\\"\\r\\n      [validator.call(property),
        msg]\\r\\n    }\\r\\n  end\\r\\n  msgs.select! { |valid, m| !valid }\\r\\n
        \ msgs.compact!\\r\\n  precondition_warnings op, msgs\\r\\n  ready = false
        if msgs.any?\\r\\n  ready\\r\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:35:17.000-07:00\",\"updated_at\":\"2018-10-29T15:35:17.000-07:00\",\"user_id\":193},{\"id\":89336,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # # grab
        all necessary items\\n    # dilute_stocks_and_retrieve TEMPLATE\\n    # kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   # take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n
        \   \\n    # #check the volumes of input primers for all operations, and ensure
        they are sufficient\\n    # operations.each { |op| op.temporary[:primer_vol]
        = 2.5 }\\n    # check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:35:36.000-07:00\",\"updated_at\":\"2018-10-29T15:35:36.000-07:00\",\"user_id\":193},{\"id\":89337,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # # grab
        all necessary items\\n    # dilute_stocks_and_retrieve TEMPLATE\\n    # kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   # take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n
        \   \\n    # #check the volumes of input primers for all operations, and ensure
        they are sufficient\\n    # operations.each { |op| op.temporary[:primer_vol]
        = 2.5 }\\n    # check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]
        #ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:36:04.000-07:00\",\"updated_at\":\"2018-10-29T15:36:04.000-07:00\",\"user_id\":193},{\"id\":89338,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # # grab
        all necessary items\\n    # dilute_stocks_and_retrieve TEMPLATE\\n    # kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   # take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n
        \   \\n    # #check the volumes of input primers for all operations, and ensure
        they are sufficient\\n    # operations.each { |op| op.temporary[:primer_vol]
        = 2.5 }\\n    # check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]
        #ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:36:11.000-07:00\",\"updated_at\":\"2018-10-29T15:36:11.000-07:00\",\"user_id\":193},{\"id\":89339,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n\\n    pcrs
        = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info
        pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.map { |op|
        op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions \\u003c\\u003c
        reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate a table
        for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells = pcrs.collect
        { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:41:53.000-07:00\",\"updated_at\":\"2018-10-29T15:41:53.000-07:00\",\"user_id\":193},{\"id\":89340,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n\\n    pcrs
        = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info
        pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n
        \ \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n
        \ \\n  \\n  \\n  \\n  \\n  # dilute to 1ng/uL stocks if necessary\\n  def
        dilute_stocks_and_retrieve input\\n  \\n    # only use inputs that haven't
        been diluted and that don't have diluted stocks already\\n    ops_w_undiluted_template
        = operations.reject { true }\\n    operations.each do |op|\\n        next
        if op.input(input).object_type.name.include?(\\\"1 ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X
        PCR Template\\\") || op.input(input).object_type.name.include?(\\\"Unverified
        PCR Fragment\\\")\\n        \\n        sample = op.input(input).sample\\n
        \       ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.map { |op|
        op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions \\u003c\\u003c
        reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate a table
        for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells = pcrs.collect
        { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:42:08.000-07:00\",\"updated_at\":\"2018-10-29T15:42:08.000-07:00\",\"user_id\":193},{\"id\":89341,\"name\":\"precondition\",\"content\":\"def
        validate_property sample, field_name\\r\\n  validation_block = Proc.new\\r\\n
        \ property = sample.properties[field_name]\\r\\n  if property.nil?\\r\\n    raise
        \\\"Could not find property #{field_name}\\\"\\r\\n  end\\r\\n  validation_block.call(sample,
        property)\\r\\nend\\r\\n\\r\\n# Appends associates msgs to plan and operation\\r\\ndef
        precondition_warnings op, msgs, key=:precondition_warnings, sep=\\\";\\\"\\r\\n
        \ plan = op.plan\\r\\n  if plan\\r\\n    plan_msg = op.plan.get key\\r\\n
        \   plan_msgs = plan_msg.split(sep).map { |x| x.strip } if plan_msg\\r\\n
        \ end\\r\\n  plan_msgs ||= []\\r\\n  op_msgs = []\\r\\n\\r\\n  msgs.each {
        |valid, m|\\r\\n    if valid\\r\\n      plan_msgs.delete(m)\\r\\n    else\\r\\n
        \     plan_msgs \\u003c\\u003c m\\r\\n      op_msgs \\u003c\\u003c m\\r\\n
        \   end\\r\\n  }\\r\\n  op_msgs.uniq!\\r\\n  plan_msgs.uniq!\\r\\n\\r\\n  op.associate
        key, op_msgs.join(sep + \\\" \\\")\\r\\n  op.plan.associate key, plan_msgs.join(sep
        + \\\" \\\") if op.plan\\r\\nend\\r\\n\\r\\ndef precondition(op)\\r\\n  ready
        = true\\r\\n  msgs = []\\r\\n  \\r\\n  #output fragment must have length!\\r\\n
        \ if op.output(\\\"Fragment\\\").sample.properties[\\\"Length\\\"].nil? ||
        op.output(\\\"Fragment\\\").sample.properties[\\\"Length\\\"] \\u003c= 0\\r\\n
        \     op.associate(\\\"Output Fragment must have a defined length!\\\", \\\"\\\")\\r\\n
        \     return false\\r\\n  end\\r\\n\\r\\n  # Validate sample, valid_block,
        valid_message\\r\\n  [\\\"Forward Primer\\\", \\\"Reverse Primer\\\"].each
        do |n|\\r\\n    sample = op.input(n).sample\\r\\n\\r\\n    msgs \\u003c\\u003c
        validate_property(sample, \\\"T Anneal\\\") { |s, property|\\r\\n      validator
        = Proc.new { |p| p.to_f.between?(0.01, 100) }\\r\\n      msg = \\\"T Anneal
        #{property} for Primer \\\\\\\"#{s.name}\\\\\\\" is invalid\\\"\\r\\n      [validator.call(property),
        msg]\\r\\n    }\\r\\n  end\\r\\n  msgs.select! { |valid, m| !valid }\\r\\n
        \ msgs.compact!\\r\\n  precondition_warnings op, msgs\\r\\n  ready = false
        if msgs.any?\\r\\n  ready\\r\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:42:08.000-07:00\",\"updated_at\":\"2018-10-29T15:42:08.000-07:00\",\"user_id\":193},{\"id\":89342,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n\\n    pcrs
        = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info
        pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n
        \ \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n
        \ \\n  \\n  \\n  \\n  \\n  # dilute to 1ng/uL stocks if necessary\\n  def
        dilute_stocks_and_retrieve input\\n  \\n    # only use inputs that haven't
        been diluted and that don't have diluted stocks already\\n    ops_w_undiluted_template
        = operations.reject { true }\\n    operations.each do |op|\\n        next
        if op.input(input).object_type.name.include?(\\\"1 ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X
        PCR Template\\\") || op.input(input).object_type.name.include?(\\\"Unverified
        PCR Fragment\\\")\\n        \\n        sample = op.input(input).sample\\n
        \       ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]
        #ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:44:10.000-07:00\",\"updated_at\":\"2018-10-29T15:44:10.000-07:00\",\"user_id\":193},{\"id\":89343,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n\\n    pcrs
        = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n    pcrs.each_with_index
        do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info
        pcr\\n    end if debug\\n    \\n    return {batches: pcrs}\\n  end\\n\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]
        #ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:45:35.000-07:00\",\"updated_at\":\"2018-10-29T15:45:35.000-07:00\",\"user_id\":193},{\"id\":89344,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # # grab
        all necessary items\\n    # dilute_stocks_and_retrieve TEMPLATE\\n    # kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   # take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n
        \   \\n    # #check the volumes of input primers for all operations, and ensure
        they are sufficient\\n    # operations.each { |op| op.temporary[:primer_vol]
        = 2.5 }\\n    # check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    \\n    dilute_stocks_and_retrieve input\\n
        \   \\n    pcrs = build_pcrs_hash\\n\\n    # show the result of the binning
        algorithm\\n    pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr
        #{idx}\\\"}\\n      log_bin_info pcr\\n    end if debug\\n    \\n    return
        {batches: pcrs}\\n  end\\n\\n  \\n  # dilute to 1ng/uL stocks if necessary\\n
        \ def dilute_stocks_and_retrieve input\\n  \\n    # only use inputs that haven't
        been diluted and that don't have diluted stocks already\\n    ops_w_undiluted_template
        = operations.reject { true }\\n    operations.each do |op|\\n        next
        if op.input(input).object_type.name.include?(\\\"1 ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X
        PCR Template\\\") || op.input(input).object_type.name.include?(\\\"Unverified
        PCR Fragment\\\")\\n        \\n        sample = op.input(input).sample\\n
        \       ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]
        #ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:52:50.000-07:00\",\"updated_at\":\"2018-10-29T15:52:50.000-07:00\",\"user_id\":193},{\"id\":89345,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # # grab
        all necessary items\\n    # dilute_stocks_and_retrieve TEMPLATE\\n    # kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   # take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n
        \   \\n    # #check the volumes of input primers for all operations, and ensure
        they are sufficient\\n    # operations.each { |op| op.temporary[:primer_vol]
        = 2.5 }\\n    # check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    pcrs = build_pcrs_hash\\n\\n    # show the
        result of the binning algorithm\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info pcr\\n    end
        if debug\\n    \\n    return {batches: pcrs}\\n  end\\n\\n  \\n  # dilute
        to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve input\\n
        \ \\n    # only use inputs that haven't been diluted and that don't have diluted
        stocks already\\n    ops_w_undiluted_template = operations.reject { true }\\n
        \   operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]
        #ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:52:56.000-07:00\",\"updated_at\":\"2018-10-29T15:52:56.000-07:00\",\"user_id\":193},{\"id\":89346,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n    \\n    # grab all
        necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    pcrs = build_pcrs_hash\\n\\n    # show the
        result of the binning algorithm\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show { title \\\"pcr #{idx}\\\"}\\n      log_bin_info pcr\\n    end
        if debug\\n    \\n    return {batches: pcrs}\\n  end\\n\\n  \\n  # dilute
        to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve input\\n
        \ \\n    # only use inputs that haven't been diluted and that don't have diluted
        stocks already\\n    ops_w_undiluted_template = operations.reject { true }\\n
        \   operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]
        #ops.map { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:53:04.000-07:00\",\"updated_at\":\"2018-10-29T15:53:04.000-07:00\",\"user_id\":193},{\"id\":89347,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:55:00.000-07:00\",\"updated_at\":\"2018-10-29T15:55:00.000-07:00\",\"user_id\":193},{\"id\":89348,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # # generate a table for
        stripwells\\n    # stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        # prepare and label stripwells for PCR\\n    # prepare_stripwells stripwell_tab\\n
        \   \\n    # # add templates to stripwells for pcr\\n    # load_templates
        pcrs\\n    \\n    # # add primers to stripwells\\n    # load_primers pcrs\\n\\n
        \   # # add kapa master mix to stripwells\\n    # add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # # run the thermocycler\\n    # start_pcr pcrs\\n    \\n    #
        # store \\n    # operations.running.store io: \\\"input\\\", interactive:
        true, method: \\\"boxes\\\"\\n    # release [kapa_stock_item], interactive:
        true\\n    \\n    # get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:55:14.000-07:00\",\"updated_at\":\"2018-10-29T15:55:14.000-07:00\",\"user_id\":193},{\"id\":89350,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # # generate a table for
        stripwells\\n    # stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        # prepare and label stripwells for PCR\\n    # prepare_stripwells stripwell_tab\\n
        \   \\n    # # add templates to stripwells for pcr\\n    # load_templates
        pcrs\\n    \\n    # # add primers to stripwells\\n    # load_primers pcrs\\n\\n
        \   # # add kapa master mix to stripwells\\n    # add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # # run the thermocycler\\n    # start_pcr pcrs\\n    \\n    #
        # store \\n    # operations.running.store io: \\\"input\\\", interactive:
        true, method: \\\"boxes\\\"\\n    # release [kapa_stock_item], interactive:
        true\\n    \\n    # get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n
        \ end\\n  \\n  # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T15:56:48.000-07:00\",\"updated_at\":\"2018-10-29T15:56:48.000-07:00\",\"user_id\":193},{\"id\":89351,\"name\":\"protocol\",\"content\":\"needs
        \\\"Cloning Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds
        'Standard Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n
        \   \\n  # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1539,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-29T16:05:44.000-07:00\",\"updated_at\":\"2018-10-29T16:05:44.000-07:00\",\"user_id\":193}]"}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:14:49 GMT']
      ETag: [W/"1d6daf1d04ac93213cd665b59b9b34b2"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=HSSm38j6FwV6JHMdQM8NB%2FVnSG8NBPhIZyxXxpDN7HxGFPI2bkkygcj0ltYSOtMQiAIijK7%2FeHkZUHnoOOG%2B9Q%3D%3D;
          path=/, _aquarium_NURSERY_production_session=cWZOc3FkcVYySHlYYlE2UXg4bEgzMXlmdDBhVjkrMG1rQ3B1MVRUd0RBWEhOc2JJK3B1UzlMQm9xWGoyZFl2eitJaUYwTEpUNEZoYUd0VFIrU0ZqRWJ6Q1pRMnlCS21oUDM5NkprNkRkRFh4ckdCaU13ZSt2SEI4OVh2TUJlbWo1NDBpd1E4VnlsZm4raHkxcnpiOVJIUUYzK1o3cGtYRGVhUUpHOUdiUUplN0JZNVNIcDV5ck1rQmFSLzhrZjJSNTRtblVRRHNNSHV3czFXT2p5QlptenZJTVFBaFlDSzNoNjhJMEFXeUxwN2Z2SDBMOW1FUjlGYXVOVjZYNHFUR28vc0NZZURQaC9UL05WUEhkdlR3b21wVitUVm50di9VTG95TVY1emc3MjBsL2FLMm15em84K3M3ZUROTnIvdEZOUmN0aFRYYjQzN20wcGVwNXRBbkVHdUw0a1pYbGlQeTYxRkhUQlZkSHVwNVBPL2NyUFR4eXNZQWdSWGhBbG5LVTZ2WlA4SThlL2tsaFZRMEtBNloxVEdhZmNZcFNkTWNyOGNsZDloUUxhND0tLUlXWXhCSTNKcU1zcURWZTBhY2MwbXc9PQ%3D%3D--9036de575109d37fc96c7d189e004d25b460d5ee;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [9b3c5e5a-c3c2-42db-851a-a125f9f9dde8]
      X-Runtime: ['0.195813']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
version: 1
