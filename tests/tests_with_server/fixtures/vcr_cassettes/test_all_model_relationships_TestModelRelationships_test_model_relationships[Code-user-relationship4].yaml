interactions:
- request:
    body: '{"model": "Code", "method": "where", "arguments": {}, "options": {"offset":
      -1, "limit": 1, "reverse": true}}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['109']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=xZ6egEhh%2BlChVfXVPVD8YDggenvqtv9YVI1kUABHZSqerspp7tLf1BOFEB5vpSJ3RUUQmElNf2kq8Up%2BqGs3ow%3D%3D;
          _aquarium_NURSERY_production_session=WEdBOGo4U21nWnJkZDByZ2ErSE1FeFpEVkE1OVM4ZFJPTFNNcnd5NlhQOWQyQ2lETk1rVDFnYmNwbFBiWnlnMTFkSzQ1ZFkxUklGcE0rMmNnMmZHVm1PWk9LLzNUVTBCd1liZkxDMVBBeXBmaUEwZHJaTjhvWFNsVFpVQ2Zmd3RyQlNWRlV5NytET3BqNUVraGtldXBFQzh2eEx2emF2cDRxM2lJSFM4OEJIZlpXaUNYblMxREZWc0E5ZnJTMlBEVWhkOFVGNDBWbDVacXEvcC92L0cveklUSmdRN0lYalRGbHJMalc1VnZvWkh4SjJvdzUxU25UdXNzQmFPSERadVFEVmZ3Q1dPaEVFZnlwVVpZR2c1Y2F1VVZTN3lrdWV0TDV6Um9vYUxKWHQ2a01tdlAvMEhhUTdKUW5tM3pHRUFiK0lsWjI5SnFTWDJiYVlGclY0RlppQ21MZVRuOUh0T1hvbnZIbHFZWjZVNzdLVGl0aTFFa2tyVytVeHpZMXM3aWZJMDFycENoblZEblBwTEtGcWRKcFVtMFZzWFJ1TkEyNmVlVkdaWFhPYz0tLTZoVW9XMzJuV0doLys5Y3UxNngxOFE9PQ%3D%3D--1cac2424c270f93e630e78a91a59326644cf5ee8;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: "[{\"id\":89429,\"name\":\"protocol\",\"content\":\"needs \\\"Cloning
        Libs/Cloning\\\"\\nneeds 'PCR Libs/GradientPcrBatching'\\nneeds 'Standard
        Libs/Debug'\\nneeds 'Standard Libs/Feedback'\\n\\nclass Protocol\\n    \\n
        \ # I/O\\n  FWD = \\\"Forward Primer\\\"\\n  REV = \\\"Reverse Primer\\\"\\n
        \ TEMPLATE = \\\"Template\\\"\\n  FRAGMENT = \\\"Fragment\\\"\\n  \\n  # other\\n
        \ SEC_PER_KB = 30 # sec, extension timer per KB for KAPA\\n  \\n  # get the
        gradient PCR magic\\n  include Cloning\\n  include GradientPcrBatching\\n
        \ include Debug\\n  include Feedback\\n\\n  def main\\n     \\n    # grab
        all necessary items\\n    dilute_stocks_and_retrieve TEMPLATE\\n    kapa_stock_item
        = find(:sample, name: \\\"Kapa HF Master Mix\\\")[0].in(\\\"Enzyme Stock\\\")[0]\\n
        \   take [kapa_stock_item], interactive: true,  method: \\\"boxes\\\"\\n    \\n
        \   #check the volumes of input primers for all operations, and ensure they
        are sufficient\\n    operations.each { |op| op.temporary[:primer_vol] = 2.5
        }\\n    check_volumes [FWD, REV], :primer_vol, :make_aliquots_from_stock,
        check_contam: true\\n    \\n    # build a pcrs hash that groups pcr by T Anneal\\n
        \   pcrs = build_pcrs_hash\\n\\n    # show the result of the binning algorithm\\n
        \   pcrs.each_with_index do |pcr, idx|\\n      show { title \\\"pcr #{idx}\\\"}\\n
        \     log_bin_info pcr\\n    end if debug\\n\\n    # generate a table for
        stripwells\\n    stripwell_tab = build_stripwell_table pcrs\\n    \\n    #
        prepare and label stripwells for PCR\\n    prepare_stripwells stripwell_tab\\n
        \   \\n    # add templates to stripwells for pcr\\n    load_templates pcrs\\n
        \   \\n    # add primers to stripwells\\n    load_primers pcrs\\n\\n    #
        add kapa master mix to stripwells\\n    add_mix stripwell_tab, kapa_stock_item\\n
        \   \\n    # run the thermocycler\\n    start_pcr pcrs\\n    \\n    # store
        \\n    operations.running.store io: \\\"input\\\", interactive: true, method:
        \\\"boxes\\\"\\n    release [kapa_stock_item], interactive: true\\n    \\n
        \   get_protocol_feedback\\n    \\n    return {batches: pcrs}\\n  end\\n  \\n
        \ # dilute to 1ng/uL stocks if necessary\\n  def dilute_stocks_and_retrieve
        input\\n  \\n    # only use inputs that haven't been diluted and that don't
        have diluted stocks already\\n    ops_w_undiluted_template = operations.reject
        { true }\\n    operations.each do |op|\\n        next if op.input(input).object_type.name.include?(\\\"1
        ng/\xB5L\\\") || op.input(input).object_type.name.include?(\\\"50X PCR Template\\\")
        || op.input(input).object_type.name.include?(\\\"Unverified PCR Fragment\\\")\\n
        \       \\n        sample = op.input(input).sample\\n        ot_name = op.input(input).object_type.name.include?(\\\"Unverified\\\")
        ? \\\"1 ng/\xB5L Plasmid Stock\\\" : \\\"1 ng/\xB5L \\\" + sample.sample_type.name
        + \\\" Stock\\\"\\n        new_stock = produce new_sample sample.name, of:
        sample.sample_type.name, as: ot_name\\n        op.temporary[:diluted_stock]
        = new_stock\\n        ops_w_undiluted_template.push op\\n    end\\n    \\n
        \   # retrieve operation inputs (doesn't include the stocks replaced by diluted
        stocks above)\\n    ops_w_undiluted_template.retrieve\\n    \\n    # all stocks
        may be diluted already\\n    if ops_w_undiluted_template.empty?\\n        operations.retrieve\\n
        \       return\\n    end\\n    \\n    # ensure concentrations\\n    check_concentration
        ops_w_undiluted_template, input\\n    \\n    # dilute stocks\\n    show do\\n
        \     title \\\"Make 1 ng/\xB5L Template Stocks\\\"\\n      \\n      check
        \\\"Grab #{ops_w_undiluted_template.length} 1.5 mL tubes, label them with
        #{ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].id }.join(\\\",
        \\\")}\\\"\\n      check \\\"Add template stocks and water into newly labeled
        1.5 mL tubes following the table below\\\"\\n      \\n      table ops_w_undiluted_template\\n
        \         .start_table\\n          .custom_column(heading: \\\"Newly-labeled
        tube\\\") { |op| op.temporary[:diluted_stock].id }\\n          .input_item(input,
        heading: \\\"Template stock, 1 uL\\\", checkable: true)\\n          .custom_column(heading:
        \\\"Water volume\\\", checkable: true) { |op| op.input(input).item.get(:concentration).to_f
        - 1 }\\n          .end_table\\n      check \\\"Vortex and then spin down for
        a few seconds\\\"\\n    end\\n    \\n    # Add association from which item
        the 1ng/ul dilution came from\\n    ops_w_undiluted_template.map { |op| op.temporary[:diluted_stock].associate(:diluted_from,
        op.input(input).item.id) }\\n    \\n    # return input stocks\\n    release
        ops_w_undiluted_template.map { |op| op.input(input).item }, interactive: true,
        method: \\\"boxes\\\"\\n    \\n    # retrieve the rest of the inputs\\n    operations.reject
        { |op| ops_w_undiluted_template.include? op }.retrieve\\n    \\n    # set
        diluted stocks as inputs\\n    ops_w_undiluted_template.each { |op| op.input(input).set
        item: op.temporary[:diluted_stock] }\\n  end\\n  \\n  \\n  # TODO dilute from
        stock if item is aliquot\\n  # Callback for check_volume.\\n  # takes in lists
        of all ops that have input aliquots with insufficient volume, sorted by item,\\n
        \ # and takes in the inputs which were checked for those ops.\\n  # Deletes
        bad items and remakes each from primer stock\\n  def make_aliquots_from_stock
        bad_ops_by_item, inputs\\n    # bad_ops_by_item is accessible by bad_ops_by_item[item]
        = [op1, op2, op3...]\\n    # where each op has a bad volume reading for the
        given item\\n    \\n    # Construct list of all stocks needed for making aliquots.
        Error ops for which no primer stock is available\\n    # for every non-errored
        op that has low item volume,\\n    # replace the old aliquot item with a new
        one. \\n    aliquots_to_make = 0\\n    stocks = []\\n    ops_by_fresh_item
        = Hash.new(0)\\n    stock_table = [[\\\"Primer Stock ID\\\", \\\"Primer Aliquot
        ID\\\"]]\\n    transfer_table = [[\\\"Old Aliquot ID\\\", \\\"New Aliquot
        ID\\\"]]\\n    bad_ops_by_item.each do |item, ops|\\n      stock = item.sample.in(\\\"Primer
        Stock\\\").first ######## items is a string?\\n      if stock.nil?\\n        ops.each
        { |op| op.error :no_primer, \\\"You need to order a primer stock for primer
        sample #{item.sample.id}.\\\" }\\n        bad_ops_by_item.except! item\\n
        \     else\\n        stocks.push stock\\n        aliquots_to_make += 1\\n
        \       item.mark_as_deleted\\n        fresh_item = produce new_sample item.sample.name,
        of: item.sample.sample_type.name, as: item.object_type.name\\n        bad_ops_by_item.except!
        item\\n        ops_by_fresh_item[fresh_item] = ops\\n        ops.each do |op|
        \\n          input = inputs.find { |input| op.input(input).item == item }\\n
        \         op.input(input).set item: fresh_item\\n        end\\n        stock_table.push
        [stock.id, {content: fresh_item.id, check: true}]\\n        if item.get(:contaminated)
        != \\\"Yes\\\"\\n          transfer_table.push [item.id, {content: fresh_item.id,
        check: true}]    \\n        end\\n      end\\n    end\\n    \\n    bad_ops_by_item.merge!
        ops_by_fresh_item\\n    take stocks, interactive: true\\n    \\n    # label
        new aliquot tubes and dilute\\n    show do \\n      title \\\"Grab 1.5 mL
        tubes\\\"\\n      \\n      note \\\"Grab #{aliquots_to_make} 1.5 mL tubes\\\"\\n
        \     note \\\"Label each tube with the following ids: #{bad_ops_by_item.keys.map
        { |item| item.id }.sort.to_sentence}\\\"\\n      note \\\"Using the 100 uL
        pipette, pipette 90uL of water into each tube\\\"\\n    end\\n  \\n    # make
        new aliquots\\n    show do \\n      title \\\"Transfer primer stock into primer
        aliquot\\\"\\n      \\n      note \\\"Pipette 10 uL of the primer stock into
        the primer aliquot according to the following table:\\\"\\n      table stock_table\\n
        \   end\\n    \\n    \\n    if transfer_table.length \\u003e 1\\n      show
        do\\n        title \\\"Transfer Residual Primer\\\"\\n        \\n        note
        \\\"Transfer primer residue from the low volume aliquots into the fresh aliquots
        according to the following table:\\\"\\n        table transfer_table\\n      end\\n
        \   end\\n    \\n    release stocks, interactive: true\\n  end\\n  \\n  #
        build a pcrs hash that groups pcr by T Anneal\\n  def build_pcrs_hash\\n    \\n
        \   pcr_operations = operations.map do |op|\\n      PcrOperation.new({\\n
        \       extension_time: op.output(FRAGMENT).sample.properties[\\\"Length\\\"]
        * SEC_PER_KB / 1000,\\n        anneal_temp: min(op.input(FWD).sample.properties[\\\"T
        Anneal\\\"], op.input(REV).sample.properties[\\\"T Anneal\\\"]),\\n        unique_id:
        op.id\\n      })\\n    end\\n\\n    result_hash = batch(pcr_operations)\\n
        \   pcr_reactions = []\\n    result_hash.each do |thermocycler_group, row_groups|\\n
        \     reaction = {}\\n      extension_time = thermocycler_group.max_extension
        + 60\\n      reaction[:mm], reaction[:ss] = (extension_time.to_i).divmod(60)\\n
        \     reaction[:mm] = \\\"0#{reaction[:mm]}\\\" if reaction[:mm].between?(0,
        9)\\n      reaction[:ss] = \\\"0#{reaction[:ss]}\\\" if reaction[:ss].between?(0,
        9)\\n      \\n      reaction[:ops_by_bin] = {}\\n      sorted_rows = row_groups.to_a.sort
        { |a,b| a.min_anneal \\u003c=\\u003e b.min_anneal }\\n      sorted_rows.each
        do |row_group|\\n          reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        = [].extend(OperationList)\\n          row_group.members.sort { |a,b| a.anneal_temp
        \\u003c=\\u003e b.anneal_temp }.each do |pcr_op|\\n            reaction[:ops_by_bin][row_group.min_anneal.round(1)]
        \\u003c\\u003c (Operation.find(pcr_op.unique_id))\\n          end\\n      end\\n
        \     \\n      # trim bin if we cant fit all rows into one thermocycler\\n
        \     while reaction[:ops_by_bin].keys.size \\u003e 8\\n        extra_ops
        = reaction[:ops_by_bin][reaction[:ops_by_bin].keys.last]\\n        extra_ops.each
        do |op|\\n            op.error :batching_issue, \\\"We weren't able to batch
        this operation into a running thermocycler for this Job, try again.\\\"\\n
        \           show do note \\\"failed batching\\\" end\\n        end\\n        reaction[:ops_by_bin].except(reaction[:ops_by_bin].keys.last)\\n
        \     end\\n      \\n      reaction[:bins] = reaction[:ops_by_bin].keys\\n
        \     reaction[:stripwells] = []\\n      reaction[:ops_by_bin].each do |bin,
        ops|\\n          ops.make\\n          reaction[:stripwells] += ops.output_collections[FRAGMENT]#ops.map
        { |op| op.output(FRAGMENT).collection }.uniq\\n      end\\n      pcr_reactions
        \\u003c\\u003c reaction\\n    end\\n    pcr_reactions\\n  end\\n  \\n  # generate
        a table for stripwells\\n  def build_stripwell_table pcrs\\n    stripwells
        = pcrs.collect { |pcr| pcr[:stripwells] }.flatten\\n    stripwell_tab = [[\\\"Stripwell\\\",
        \\\"Wells to pipette\\\"]] + stripwells.map { |sw| [\\\"#{sw.id} (#{sw.num_samples
        \\u003c= 6 ? 6 : 12} wells)\\\", { content: sw.non_empty_string, check: true
        }] }\\n  end\\n  \\n  # prepare and label stripwells for PCR\\n    def prepare_stripwells
        stripwell_tab\\n    show do\\n      title \\\"Label and prepare stripwells\\\"\\n
        \     \\n      note \\\"Label stripwells, and pipette 19 uL of molecular grade
        water into each based on the following table:\\\"\\n      table stripwell_tab\\n
        \     stripwell_tab\\n    end\\n  end\\n  \\n  # add templates to stripwells
        for pcr\\n  def load_templates pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n
        \     show do\\n        title \\\"Load templates for PCR ##{idx + 1}\\\"\\n
        \       \\n        pcr[:ops_by_bin].each do |bin, ops|\\n          table ops\\n
        \             .start_table\\n              .output_collection(FRAGMENT, heading:
        \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\") {
        |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(TEMPLATE,
        heading: \\\"Template, 1 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add primers to stripwells\\n  def load_primers
        pcrs\\n    pcrs.each_with_index do |pcr, idx|\\n      show do\\n        title
        \\\"Load primers for PCR ##{idx + 1}\\\"\\n        \\n        pcr[:ops_by_bin].each
        do |bin, ops|\\n          table ops.start_table\\n              .output_collection(FRAGMENT,
        heading: \\\"Stripwell\\\")\\n              .custom_column(heading: \\\"Well\\\")
        { |op| op.output(FRAGMENT).column + 1 }\\n              .input_item(FWD, heading:
        \\\"Forward Primer, 2.5 uL\\\", checkable: true)\\n              .input_item(REV,
        heading: \\\"Reverse Primer, 2.5 uL\\\", checkable: true)\\n              .end_table\\n
        \       end\\n        warning \\\"Use a fresh pipette tip for each transfer.\\\".upcase\\n
        \     end\\n    end\\n  end\\n  \\n  # add kapa master mix to stripwells\\n
        \ def add_mix stripwell_tab, kapa_stock_item\\n      show do\\n          title
        \\\"Add Master Mix\\\"\\n          \\n          note \\\"Pipette 25 L of master
        mix (#{kapa_stock_item}) into stripwells based on the following table:\\\"\\n
        \         table stripwell_tab\\n          warning \\\"USE A NEW PIPETTE TIP
        FOR EACH WELL AND PIPETTE UP AND DOWN TO MIX.\\\"\\n          check \\\"Cap
        each stripwell. Press each one very hard to make sure it is sealed.\\\"\\n
        \     end\\n  end\\n  \\n  # run the thermocycler and update the positions
        of the stripwells\\n  def start_pcr pcrs\\n      pcrs.each_with_index do |pcr,
        idx|\\n        is_gradient = pcr[:bins].length \\u003e 1\\n        # log_bin_info
        pcr # use for debugging bad binning behavior\\n        resp = show do\\n          if
        !is_gradient\\n            title \\\"Start PCR ##{idx + 1} at #{pcr[:bins].first}
        C\\\"\\n            \\n            check \\\"Place the stripwell(s) #{pcr[:stripwells].collect
        { |sw| \\\"#{sw}\\\" }.join(\\\", \\\")} into an available thermal cycler
        and close the lid.\\\"\\n            get \\\"text\\\", var: \\\"name\\\",
        label: \\\"Enter the name of the thermocycler used\\\", default: \\\"TC1\\\"\\n
        \           check \\\"Click 'Home' then click 'Saved Protocol'. Choose 'YY'
        and then 'CLONEPCR'.\\\"\\n            check \\\"Set the anneal temperature
        to \\u003cb\\u003e#{pcr[:bins].first} C\\u003c/b\\u003e. This is the 3rd temperature.\\\"\\n
        \         else\\n            title \\\"Start PCR ##{idx + 1} (gradient) over
        range #{pcr[:bins].first}-#{pcr[:bins].last} C\\\"\\n            check \\\"Click
        'Home' then click 'Saved Protocol'. Choose 'YY' and then 'CLONEPCR'.\\\"\\n
        \           check \\\"Click on annealing temperature -\\u003e options, and
        check the gradient checkbox.\\\"\\n            check \\\"Set the annealing
        temperature range to be #{pcr[:bins].first}-#{pcr[:bins].last} C.\\\"\\n            note
        \\\"Cancel this PCR batch if something doesn't look right, for example if
        the thermocycler does not allow this temperature range.\\\"\\n            select
        [\\\"yes\\\", \\\"no\\\"], var: \\\"batching_bad\\\", label: \\\"Cancel this
        batch?\\\", default: 1\\n            note \\\"The following stripwells are
        ordered front to back.\\\"\\n            \\n            pcr[:stripwells].map.with_index
        do |sw, idx|\\n              temp = pcr[:ops_by_bin].keys[idx].to_f\\n              check
        \\\"Place the stripwell #{sw} into a row of the thermocycler with the temperature
        as close as possible to \\u003cb\\u003e#{temp} C\\u003c/b\\u003e\\\"\\n            end\\n
        \           get \\\"text\\\", var: \\\"name\\\", label: \\\"Enter the name
        of the thermocycler used\\\", default: \\\"TC1\\\"\\n          end\\n          check
        \\\"Set the 4th time (extension time) to be #{pcr[:mm]}:#{pcr[:ss]}.\\\"\\n
        \         check \\\"Press 'Run' and select 50 uL.\\\"\\n        end\\n        \\n
        \       impossible_pcr_handler(pcr) if resp.get_response(:batching_bad) ==
        \\\"yes\\\"\\n        \\n        # set the location of the stripwell\\n        pcr[:stripwells].flatten.each
        do |sw|\\n          sw.move resp[:name]\\n        end\\n      end\\n  end\\n
        \ \\n  def impossible_pcr_handler(pcr)\\n      pcr[:ops_by_bin].each do |bin,
        ops|\\n          ops.each do |op|\\n            op.error :batching_issue,
        \\\"We weren't able to batch this operation into a running thermocycler for
        this Job, try again.\\\"\\n          end\\n      end\\n      pcr[:stripwells].each
        do |sw|\\n          sw.mark_as_deleted\\n      end\\n      \\n      show do\\n
        \       title 'Reaction Canceled'\\n        note \\\"All operations in this
        pcr reaction are canceled, try them again in a seperate job.\\\"\\n        note
        \\\"The other Reactions will go forward as planned.\\\"\\n      end\\n  end\\n\\n
        \ def log_bin_info pcr\\n    show do\\n      title \\\"bin info\\\"\\n      note
        \\\"ops_by_bin\\\"\\n      pcr[:ops_by_bin].each do |bin, ops|\\n        opids
        = ops.map { |op| op.id }\\n        check \\\"#{bin.to_s}  =\\u003e  #{opids.to_s}\\\"\\n
        \     end\\n\\n      note \\\"bins\\\"\\n      pcr[:bins].each do |bin|\\n
        \       check \\\"#{bin.to_s}\\\"\\n      end\\n    end\\n  end\\nend\",\"parent_id\":1460,\"parent_class\":\"OperationType\",\"created_at\":\"2018-10-31T13:38:11.000-07:00\",\"updated_at\":\"2018-10-31T13:38:11.000-07:00\",\"user_id\":192}]"}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:13:08 GMT']
      ETag: [W/"1c9c3a3782770c01a7dd4af9f5cf70a0"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=fi3%2FcJ6GEt56z3En06GDRuyl2BdDmT%2BOzn8tfA90eFolHauZODU3WsgflOyBVF1RkcCy9OBiv7%2BwAwNSp1gq0w%3D%3D;
          path=/, _aquarium_NURSERY_production_session=akVtUFdLMEgybE1KNzh6cTdCTks4V28zOGRUV3djOHJpNkR0d0hBblMxQkZaOXZGd3lJZm0xbVFVTm1CTmdaR0JuakdQbHJVUlI5MjE4RlZGTDJxVXBkR2pKSEpSVGNCalJmcTBvc2tWSFhXUmNRbTBTb0hsbUxaYWd3WmZPQmhBQXo5eUxDL1lZT0VNZm1IOHFBNVlyT1o5aTNTS3g5azQvSjJuUW5VRU9FOEk0ZXQyTTVuQ0MzN0JmbWRXcmwwNzNQQ2VLT0xTcWdJRjlQcVVrSk9uZnBkTFRBRlMxVEpZSVhhTCtHUUV5MUJnYnBDTmgzMGVYTmhKWmJrYlRmRUdnSFhYQ3c2Wmk1VFo0SVF0TG1jZlE0TkdFVUJtRU44Y2R4TTd6eVp0c0d4TUdRNzNmeWlXb2JUODdqWEZZSlRFRnhiQ25WeG9icVdPVEVsWCs0RU1KRDBKejZlWllJaEVYMWFFTnhkN2RCak8wR0p3c0FaVldOQUM2NE4wdWZmaGlSS0w3bUh6ZUlJUkV0blRsQnhYTXVFb2VyVEdSSFR6aEZHbUJnVDkrST0tLW1CSGpKTnJIYkp1ejFQY01PQXZZREE9PQ%3D%3D--cefe60500f091ed7114a6ce3d9fe79940b636dd6;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [7a24cf59-3a04-4a23-b664-16cad8c661b4]
      X-Runtime: ['0.047807']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "User", "id": 192}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['28']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=xZ6egEhh%2BlChVfXVPVD8YDggenvqtv9YVI1kUABHZSqerspp7tLf1BOFEB5vpSJ3RUUQmElNf2kq8Up%2BqGs3ow%3D%3D;
          _aquarium_NURSERY_production_session=WEdBOGo4U21nWnJkZDByZ2ErSE1FeFpEVkE1OVM4ZFJPTFNNcnd5NlhQOWQyQ2lETk1rVDFnYmNwbFBiWnlnMTFkSzQ1ZFkxUklGcE0rMmNnMmZHVm1PWk9LLzNUVTBCd1liZkxDMVBBeXBmaUEwZHJaTjhvWFNsVFpVQ2Zmd3RyQlNWRlV5NytET3BqNUVraGtldXBFQzh2eEx2emF2cDRxM2lJSFM4OEJIZlpXaUNYblMxREZWc0E5ZnJTMlBEVWhkOFVGNDBWbDVacXEvcC92L0cveklUSmdRN0lYalRGbHJMalc1VnZvWkh4SjJvdzUxU25UdXNzQmFPSERadVFEVmZ3Q1dPaEVFZnlwVVpZR2c1Y2F1VVZTN3lrdWV0TDV6Um9vYUxKWHQ2a01tdlAvMEhhUTdKUW5tM3pHRUFiK0lsWjI5SnFTWDJiYVlGclY0RlppQ21MZVRuOUh0T1hvbnZIbHFZWjZVNzdLVGl0aTFFa2tyVytVeHpZMXM3aWZJMDFycENoblZEblBwTEtGcWRKcFVtMFZzWFJ1TkEyNmVlVkdaWFhPYz0tLTZoVW9XMzJuV0doLys5Y3UxNngxOFE9PQ%3D%3D--1cac2424c270f93e630e78a91a59326644cf5ee8;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":192,"name":"Eriberto Lopez","login":"elopez","created_at":"2017-07-20T09:19:54.000-07:00","updated_at":"2017-07-20T09:19:54.000-07:00","password_digest":"$2a$10$t6kG6oECRZz10YE15y5p0uKeCulXhzzh/.7zsCQNuXF5XqaEK7g6.","remember_token":"iRjxzS2KV2WZKFjr-sNWzA","admin":false,"key":null,"groups":[{"id":217,"name":"elopez","description":"A
        group containing only user Eriberto Lopez","created_at":"2017-07-20T09:19:54.000-07:00","updated_at":"2017-07-20T09:19:54.000-07:00"},{"id":1,"name":"admin","description":"These
        users can use administrative functions (make users, etc)","created_at":"2013-11-15T13:37:36.000-08:00","updated_at":"2013-11-15T13:37:36.000-08:00"}]}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 01 Nov 2018 04:13:08 GMT']
      ETag: [W/"95bde8d34902e2a5863e5541fdd355d5"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=W9Iz46l3mQcgXd%2FSBJNakTTcqrcOW640tDnWUrgSdGIA4mcKD8S8g5KNOhlWZoSGSbnAVK2gLgXKRfh8ED4m6w%3D%3D;
          path=/, _aquarium_NURSERY_production_session=bWV4c0xDa1ZqaGY5cXp1UnYzRE94ZHpmVGFNTExOS0xsbGFRRzZzWkJ0YVhteGU2NWVjL203YWRaU0M3TE8zMHhLR1NCTWFBSUphVzMyTTFpUnVYZi8yYitYbjBJMHRyS1ZzYlE3UkN1T1kwZ1k1b3N6WkRHd1hiaU9GQXV2NHBUTjRiYUdvbEtCYml0bW5DZTIzQjJBaWh0aFRqYVpUZlhBQjNIS2RJOFlwL1R2UEw5VVVmNVlUa0xKWlhpY2hkWnl0aE8xNU43M2lDMVMvSlorRnkyTmM4WGRzM0FuTXh4SUJwMk9uYzFkZVV1N3BBc3FmQnVtRllqVGF1K3JJaHh5SmxaRmhkeWVPRWRDZUFseUxzSC83Tmo1L1FvbFJsSi9oczBFOFZ3MFAyL1F3VEdRSklOWXZZYWJsZVZPY0tJb1h2ZzZPNVczcUhva0JjQVJlRjVCbDFZZGhBRDVaS2RPVDROMlFpTndMdkEzeG82MlNLeEtZMDFkRUZlbGVZMExvczR5TGx1NlBrNmorRGJsMzdDbE9GR0xDZUptdEJDSjBrNG8zc3VQMD0tLXJqaWpOcHpPcysxK0JIMExVT0tTb2c9PQ%3D%3D--64caa1c372b09707e12fb2abf65f55aa31ff45bc;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [dded5df9-b57b-4291-9438-c191cb8796d6]
      X-Runtime: ['0.006221']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "Code", "method": "where", "arguments": {}, "options": {"offset":
      -1, "limit": 1, "reverse": true}}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['109']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=FnznZis4%2FqM3BE%2FxdqCWGmlEWsOpa0GHdB1Bl%2FVHMGSNx%2FqwxnfZiMdQtGYQLIDsgGj2QKWiO7yYJvaFjgkD8g%3D%3D;
          _aquarium_NURSERY_production_session=OFZUMzJkYXpIQjczRUlNaTMrbUc1eW02YjcwTHMrd3JGZU5VTG5NeW1qMFdIV1hXbHBlSFZFWkhDSWdZNy9SYVZZNFIydUNyMWVpYkpBeVVXM202OWxCdnBJai9qTkU5TWx1bTRKaDUyZ3EwRTVqRlZqZEEvTzFaTFN3U2VYTGt3Q2xkUzUwbHJ1di9nK2NEdHJmODdhYXhYdEVsckhnVktsb3l5MzIrV2VhVkwydFQwSVY0ZC9sZ3NnUjc2MXpvTVNtWFVYVTlOektyTG9YRjlsRGFUeENlNW5idGhFTzd5czhaY1NuUTJUdHZoYzF1MjVKTGtSU2pOdHFkTENrdlNrbG5JTTR6Q1NxWXJ5NTJwUHpHL1B3NzMrZjJNWkcyb3JWNDA5NFhhN0dkSk9mM2ZlN1pEa2ZaMjUyQlJtbDAyRTUyZ0g4K0hQa1NaeERuUFpsWkdiYUJYMVp3Vzh3a0Rnek9CdEVYLytHSHpsSTVrdStENGpxSDJtZ3BIakx5NXl6WTBzSmF1Skc3NThxS2NLaU5JNTNhc1BpQS91c3IrTU9ZTEFWQ3Nkaz0tLTlPN3Uwbm12N0tGVlZsd1JSUEczUWc9PQ%3D%3D--f48ba8c65ab798caf2b08d61aa8533f63ae2200c;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: "[{\"id\":90792,\"name\":\"protocol\",\"content\":\"# Author: Pei
        Wu , Sep 2018\\r\\nneeds \\\"Standard Libs/Feedback\\\"\\r\\nclass Protocol\\r\\n
        \ include Feedback\\r\\n  def main\\r\\n    \\r\\n    # Gather all reserved
        samples.\\r\\n    operations.retrieve\\r\\n\\r\\n    op_in_protein   = []\\r\\n
        \   op_in_before    = []\\r\\n    op_in_after     = []\\r\\n    \\r\\n    #amount_before
        \  = []\\r\\n    #amount_after    = []\\r\\n    #amount_protein  = []\\r\\n
        \   \\r\\n    #pbs_before      = []\\r\\n    #pbs_after       = []\\r\\n    #pbs_protein
        \    = []\\r\\n    \\r\\n    op_count = 0\\r\\n    \\r\\n    operations.running.each
        do |op|\\r\\n        # generate randon OD values for debug\\r\\n        #op.set_input_data(\\\"Protein\\\",
        :od_value, Random.rand(0.8..1.0)) if debug\\r\\n        #op.set_input_data(\\\"Before
        IPTG\\\", :od_value, Random.rand(0.8..1.0)) if debug\\r\\n        #op.set_input_data(\\\"After
        IPTG\\\", :od_value, Random.rand(0.8..1.0)) if debug\\r\\n        # \\r\\n
        \       op_count = op_count + 1\\r\\n        op_in_protein   \\u003c\\u003c
        op.input(\\\"Protein\\\").item.id\\r\\n        op_in_before    \\u003c\\u003c
        op.input(\\\"Before IPTG\\\").item.id\\r\\n        op_in_after     \\u003c\\u003c
        op.input(\\\"After IPTG\\\").item.id\\r\\n        \\r\\n        #tmp_before
        \ = (op.input_data(\\\"Before IPTG\\\", :od_value).to_f * 100).floor\\r\\n
        \       #tmp_after   = (op.input_data(\\\"After IPTG\\\", :od_value).to_f
        * 100).floor\\r\\n        #tmp_protein = (op.input_data(\\\"Protein\\\", :od_value).to_f
        * 100).floor\\r\\n        \\r\\n        #amount_before   \\u003c\\u003c tmp_before\\r\\n
        \       #amount_after    \\u003c\\u003c tmp_after\\r\\n        #amount_protein
        \ \\u003c\\u003c tmp_protein\\r\\n        #pbs_before  \\u003c\\u003c (240
        - tmp_before)\\r\\n        #pbs_after   \\u003c\\u003c (240 - tmp_after)\\r\\n
        \       #pbs_protein \\u003c\\u003c (240 - tmp_protein)\\r\\n    end\\r\\n\\r\\n
        \   #op_in_gel = []\\r\\n    #operations.each do |op|\\r\\n    #    op_in_gel
        \\u003c\\u003c op.input(\\\"SDS Gel\\\").collection.id\\r\\n    #end\\r\\n\\r\\n
        \   op_in_gel = operations.map { |op| op.input(\\\"SDS Gel\\\").collection.id
        }.uniq\\r\\n    \\r\\n    # Don't use generic operations.make\\r\\n    operations.each
        do |op|\\r\\n        op.output(\\\"SDS Gel\\\").make_part(\\r\\n          op.input(\\\"SDS
        Gel\\\").collection,\\r\\n          op.input(\\\"SDS Gel\\\").row,\\r\\n          op.input(\\\"SDS
        Gel\\\").column\\r\\n        )\\r\\n    end\\r\\n    \\r\\n    op_out_gel
        = operations.map { |op| op.output(\\\"SDS Gel\\\").collection.id }.uniq\\r\\n
        \   \\r\\n    tank_count = (op_in_gel.size)/4.floor\\r\\n    remainder = (op_in_gel.size)
        % 4\\r\\n    if remainder != 0\\r\\n        tank_count = tank_count + 1\\r\\n
        \   end\\r\\n\\r\\n    # Load samples into wells using a pipet with gel loading
        tips. [note] load samples slowly to allow them to settle evenly on the bottom
        of the well\\r\\n    # Arrange them in the following order:\\r\\n\\r\\n    #
        \ -----------------------------------------------------------------------------------------\\r\\n
        \   # | marker |         Batch 1          |         Batch 2          |         Batch
        3          |\\r\\n    # | ---------------------------------------------------------------------------------------
        |\\r\\n    # | marker | Before | After  | Sample | Before | After  | Sample
        | Before | After  | Sample |\\r\\n    #  -----------------------------------------------------------------------------------------\\r\\n
        \   \\r\\n    #  -----------------------------------------------------------------------------------------\\r\\n
        \   # | Col 1  | Col 2  | Col 3  | Col 4  | Col 5  | Col 6  | Col 7  | Col
        8  | Col 9  | Col 10 |\\r\\n    # | ---------------------------------------------------------------------------------------
        |\\r\\n    # | marker | ID_B1  | ID_A1  | ID_I1  | ID_B2  | ID_A2  | ID_I2
        \ | ID_B3  | ID_A3  | ID_I3  |\\r\\n    #  -----------------------------------------------------------------------------------------\\r\\n
        \   grab_lids(tank_count)\\r\\n    \\r\\n    load_marker(op_in_gel)\\r\\n
        \   \\r\\n    load_sample_into_wells(op_count,op_in_protein,op_in_before,op_in_after,op_in_gel)\\r\\n\\r\\n
        \   # Place the lid on the tank and make sure to align it with the color-coded
        plugs.\\r\\n    place_lid_and_align_to_plugs\\r\\n    \\r\\n    set_a_30mins_timer\\r\\n
        \   \\r\\n    # Apply 100V to the electrophoresis.\\r\\n    \\r\\n    # Run
        the gel until the smallest protein of the protein marker is completely down
        to the SDS-PAGE.\\r\\n    \\r\\n    # Turn off the power supply, remove the
        tank and pour off the running buffer.\\r\\n    \\r\\n    # Open the arms of
        assembly and remove the gel cassettes.\\r\\n    remove_gel_cassette(op_in_gel)\\r\\n
        \   \\r\\n    # Remove the gels from the gel cassette by gently separating
        the two plates of the gel cassette.\\r\\n    gel_removal\\r\\n    \\r\\n    #
        Remove the gel by floating it off the plate, inverting the gel and plate under
        water.\\r\\n    \\r\\n    # Soak the gel in water and put the container on
        the shaker in the incubator.\\r\\n    gel_wash(op_in_gel)\\r\\n    \\r\\n
        \   # Replace water with clean water every 5mins for three times.\\r\\n    second_wash(op_in_gel)\\r\\n
        \   \\r\\n    final_wash_add_staining(op_in_gel)\\r\\n    \\r\\n    # Pour
        off water and add 20mL gel staining buffer to the container.\\r\\n    \\r\\n
        \   # Put the container on the shaker in incubator for 1hour.\\r\\n    # Pour
        off the gel staining buffer and add clean water to the container to wash the
        gel.\\r\\n    put_container_on_shaker_1hr(op_in_gel)\\r\\n    \\r\\n    #
        Replace the water with clean water every 10mins until the gel background is
        completely clear and gel band can be easily distinguished.\\r\\n    remove_gel_stain(op_in_gel)\\r\\n
        \   \\r\\n    background_wash(op_in_gel)\\r\\n    \\r\\n    # Take a photo
        of the gel. Save the photo and discard the gel.\\r\\n    check_gel_clean(op_in_gel)\\r\\n
        \   \\r\\n    operations.each do |op|\\r\\n        op.input(\\\"Protein\\\").item.mark_as_deleted\\r\\n
        \       op.input(\\\"Before IPTG\\\").item.mark_as_deleted\\r\\n        op.input(\\\"After
        IPTG\\\").item.mark_as_deleted\\r\\n      end\\r\\n    \\r\\n    operations.store(io:
        \\\"output\\\", interactive: true)\\r\\n\\r\\n    return {}\\r\\n  end\\r\\n
        \ \\r\\n  def grab_lids(tank_count)\\r\\n    show do\\r\\n        title \\\"Set
        up the power supply\\\"\\r\\n        check \\\"In the gel room, obtain a power
        supply and set it to 200 V.\\\"\\r\\n        check \\\"Grab \\u003cb\\u003e#{tank_count}\\u003c/b\\u003e
        lid(s). Attach the electrodes of a lid to the power supply. Make sure to align
        the color-coded plugs and jacks.\\\"\\r\\n        image \\\"Actions/ProteinPurification/lid.jpg\\\"\\r\\n
        \   end\\r\\n  end\\r\\n  \\r\\n  def load_marker(op_in_gel)\\r\\n    show
        do\\r\\n        title \\\"Add protein ladder to gel\\\"\\r\\n        check
        \\\"Grab the protein ladder from a box label \\u003cb\\u003eprotein purification\\u003c/b\\u003e
        in -20\xB0C freezer (B1-165).\\\"\\r\\n        check \\\"Pipette 10 \xB5l
        of the protein ladder to well position 1 (the leftmost well) of gel #{op_in_gel.to_sentence}.\\\"\\r\\n
        \   end\\r\\n  end\\r\\n\\r\\n  def load_sample_into_wells(op_count,op_in_protein,op_in_before,op_in_after,op_in_gel)\\r\\n
        \   show do \\r\\n      title \\\"Load sample into gel\\\"\\r\\n      bullet
        \\\"Transfer samples from the tube to the well according to the following
        table:\\\"\\r\\n      note \\\"Load samples by using a P200 pipettor with
        gel loading tips.\\\"\\r\\n      for i in 0...op_in_gel.size\\r\\n        note
        \\\"Gel #{i+1}: #{op_in_gel[i]}\\\"\\r\\n        op_table = [[\\\"Gel ID\\\",\\\"Well
        number\\\",\\\"Sample ID\\\"]]\\r\\n        well_no = 2\\r\\n        if (i+1)*3
        \\u003e op_count\\r\\n            length = op_count - (i*3)\\r\\n        else\\r\\n
        \           length = 3\\r\\n        end\\r\\n        for j in 0...length\\r\\n
        \           # before\\r\\n            row = []\\r\\n            row \\u003c\\u003c
        op_in_gel[i]\\r\\n            row \\u003c\\u003c well_no\\r\\n            row
        \\u003c\\u003c {content:op_in_before[i*3+j], check: true}\\r\\n            op_table
        \\u003c\\u003c row\\r\\n            well_no = well_no + 1\\r\\n            #
        after\\r\\n            row = []\\r\\n            row \\u003c\\u003c op_in_gel[i]\\r\\n
        \           row \\u003c\\u003c well_no\\r\\n            row \\u003c\\u003c
        {content:op_in_after[i*3+j], check: true}\\r\\n            op_table \\u003c\\u003c
        row\\r\\n            well_no = well_no + 1\\r\\n            # sample\\r\\n
        \           row = []\\r\\n            row \\u003c\\u003c op_in_gel[i]\\r\\n
        \           row \\u003c\\u003c well_no\\r\\n            row \\u003c\\u003c
        {content:op_in_protein[i*3+j], check: true}\\r\\n            op_table \\u003c\\u003c
        row\\r\\n            well_no = well_no + 1\\r\\n        end\\r\\n        table
        op_table\\r\\n      end\\r\\n      warning \\\"Load samples slowly to allow
        them to settle evenly on the bottom of the well. Be carefully not to puncture
        the bottom of gel wells.\\\"\\r\\n      image \\\"Actions/ProteinPurification/loading_tip.jpg\\\"\\r\\n
        \   end\\r\\n  end\\r\\n    \\r\\n  def place_lid_and_align_to_plugs\\r\\n
        \   show do \\r\\n      title \\\"Start Electrophoresis\\\"\\r\\n      bullet
        \\\"Carefully attach the lid to tank. Attach the red electrode to the red
        terminal of the power supply, and the black \\r\\n      electrode to the neighboring
        black terminal\\\"\\r\\n      bullet \\\"Set the power supply to 200V.\\\"\\r\\n
        \     bullet \\\"Hit the RUN button on the power supply.\\\"\\r\\n      image
        \\\"Actions/ProteinPurification/Start_Electrophoresis.jpg\\\"\\r\\n    end\\r\\n
        \ end\\r\\n  \\r\\n  def set_a_30mins_timer\\r\\n      show do\\r\\n        title
        \\\"Check on gels\\\"\\r\\n        check \\\"Set a 30-mins timer.\\\"\\r\\n
        \       timer initial: { hours: 0, minutes: 30, seconds: 0}\\r\\n        check
        \\\"The protein ladder should be fully separated by electrophoresis. Grab
        a lab manager to check on the gel with you. The lab manager may have you set
        another timer after checking the gel.\\\"\\r\\n      end\\r\\n  end\\r\\n
        \ \\r\\n  def remove_gel_cassette(op_in_gel)\\r\\n    show do \\r\\n        title
        \\\"Remove gel cassette\\\"\\r\\n        bullet \\\"After electrophoresis
        is done, turn off the power supply and remove the tank lids.\\\"\\r\\n        bullet
        \\\"Pour off the running buffer.\\\"\\r\\n        warning \\\"Make sure the
        gel ID is still labeled on the gel cassette.\\\"\\r\\n        bullet \\\"Grab
        \\u003cb\\u003e#{op_in_gel.size}\\u003c/b\\u003e box(es) and label with ID:
        #{op_in_gel.to_sentence}.\\\"\\r\\n        bullet \\\"Add water to the box.\\\"\\r\\n
        \       bullet \\\"Open the arms of assembly and release the gel cassette.\\\"\\r\\n
        \       bullet \\\"Place the gel cassettes into the corresponding box.\\\"\\r\\n
        \       image \\\"Actions/ProteinPurification/empty_box.jpg\\\"\\r\\n    end\\r\\n
        \ end\\r\\n\\r\\n  def gel_removal\\r\\n    show do \\r\\n      title \\\"Gel
        removal\\\"\\r\\n      bullet \\\"Grab a gel releaser.\\\"\\r\\n      bullet
        \\\"Gently separate the two plates of a gel cassette by using a gel releaser.\\\"\\r\\n
        \     bullet \\\"Remove the short plate on the top.\\\"\\r\\n      bullet
        \\\"Cut away the top layer of gel by using a gel releaser.\\\"\\r\\n      bullet
        \\\"Inverting the gel and plater under water. Floating the gel off the plate
        in the corresponding box.\\\"\\r\\n      image \\\"Actions/ProteinPurification/gel_releaser.jpg\\\"\\r\\n
        \   end\\r\\n  end\\r\\n\\r\\n  def gel_wash(op_in_gel)\\r\\n    show do \\r\\n
        \     title \\\"Wash gels\\\"\\r\\n      bullet \\\"Place #{op_in_gel.to_sentence}
        on a shaker in the still incubator.\\\"\\r\\n      bullet \\\"Wash gels for
        5 minutes.\\\"\\r\\n      timer initial: { hours: 0, minutes: 5, seconds:
        0}\\r\\n      image \\\"Actions/ProteinPurification/shaker_in_incubator.jpg\\\"\\r\\n
        \   end\\r\\n  end\\r\\n    \\r\\n  def second_wash(op_in_gel)\\r\\n    show
        do \\r\\n      title \\\"Second wash\\\"\\r\\n      bullet \\\"Retrieve the
        box from shaker. Replace with clean water.\\\"\\r\\n      bullet \\\"Return
        #{op_in_gel.to_sentence} to the shaker in the still incubator.\\\"\\r\\n      bullet
        \\\"Wash gels for 5 minutes.\\\"\\r\\n      timer initial: { hours: 0, minutes:
        5, seconds: 0}\\r\\n    end\\r\\n  end\\r\\n  \\r\\n  def final_wash_add_staining(op_in_gel)\\r\\n
        \   show do\\r\\n        title \\\"Third wash\\\"\\r\\n        bullet \\\"Retrieve
        the box from shaker. Replace with clean water.\\\"\\r\\n        bullet \\\"Return
        #{op_in_gel.to_sentence} to the shaker in the still incubator.\\\"\\r\\n        bullet
        \\\"Wash gels for 5 minutes.\\\"\\r\\n        timer initial: { hours: 0, minutes:
        5, seconds: 0}\\r\\n        bullet \\\"Pour off water and add 20 mL of gel
        staining buffer (R1-350) to each box.\\\"\\r\\n        image \\\"Actions/ProteinPurification/gel_staining_buffer.jpg\\\"\\r\\n
        \   end\\r\\n  end\\r\\n\\r\\n  def put_container_on_shaker_1hr(op_in_gel)\\r\\n
        \   show do \\r\\n      title \\\"Stain gel\\\"\\r\\n      bullet \\\"Place
        #{op_in_gel.to_sentence} on a shaker in the still incubator.\\\"\\r\\n      bullet
        \\\"Stain gel for 1 hour.\\\"\\r\\n      timer initial: { hours: 1, minutes:
        0, seconds: 0}\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def remove_gel_stain(op_in_gel)\\r\\n
        \   show do \\r\\n      title \\\"Remove gel staining buffer\\\"\\r\\n      bullet
        \\\"Remove #{op_in_gel.to_sentence} from the shaker.\\\"\\r\\n      bullet
        \\\"Pour off gel staining buffer and rinse the gel with water.\\\"\\r\\n      bullet
        \\\"Add water to the box.\\\"\\r\\n    end\\r\\n  end\\r\\n  \\r\\n  def background_wash(op_in_gel)\\r\\n
        \   show do\\r\\n        title \\\"Destain gel \\\"\\r\\n        bullet \\\"Place
        #{op_in_gel.to_sentence} on a shaker in the still incubator.\\\"\\r\\n        bullet
        \\\"Wash gel for 1 hour.\\\"\\r\\n        timer initial: { hours: 1, minutes:
        0, seconds: 0}\\r\\n    end\\r\\n  end\\r\\n  \\r\\n  def check_gel_clean(op_in_gel)\\r\\n
        \   show do\\r\\n        title \\\"Check on gels\\\"\\r\\n        bullet \\\"Retrieve
        #{op_in_gel.to_sentence} from the shaker.\\\"\\r\\n        bullet \\\"Make
        sure that the excess blue dye has been removed from the gel matrix background
        and the protein bands can be distinguished. (as an example shown in the picture
        below).\\\"\\r\\n        bullet \\\"Store the gel in the box saturated with
        water.\\\"\\r\\n        bullet \\\"If the background is still in dark blue,
        wash gels for another 1 hour or leave it on the shaker overnight. Grab a manager
        to check on the gels.\\\"\\r\\n        image \\\"Actions/ProteinPurification/gel_staining.jpg\\\"\\r\\n
        \   end\\r\\n  end\\r\\n  \\r\\nend\",\"parent_id\":1545,\"parent_class\":\"OperationType\",\"created_at\":\"2018-11-07T21:21:56.000-08:00\",\"updated_at\":\"2018-11-07T21:21:56.000-08:00\",\"user_id\":200}]"}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 08 Nov 2018 07:24:57 GMT']
      ETag: [W/"23baa4c3a55daee2caa26995218c231b"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=ZQ0Y5wK1B7rdJ3f8JI%2FzjvkrTCxmIexlkBQAG6eT%2FOD%2BtgUx7%2FogkS1zjGtCA%2BV4EAfgr2roll58L7cJ3N3Pdg%3D%3D;
          path=/, _aquarium_NURSERY_production_session=RHc5NnZMNzM0aC91ZDdJTTcwcGlMeElTVGl5OVM5OHpRd2xJbDNNZmtXSUJIS3Nhc2N6eStoTlg1TEVvbDZnOElNQmliZEtlWjVFdkpXSy9pOC9uQ3FOVjJDWUdlb1ZubHFjUXE5MGlaRFNUWGt4R1pWWnR3aWFlR1FsZnQvZEVzYmtuZkxKVHQxSzlPT2dNano3MytsSXEwc05hM3drRGRTTzgxVTRPa01DOXBQek5kOFJneVFIeFUvZlF4V3ZlODBQU3A2VmpwMGEyWm9EbnIrWnNsaHp2ZEZ2T0JydlRCNXFZMTFETmtRaFNYcVFubytFUkhFVVhOd0dpQTF3QXlzdEZpQ1NwTkFBYUV4VVBtdnV2cDVwZ040Z1dnZk96RHlQZjJKNG92d1cyZ1U4VkIzOEJKcDQzWXRjWkszSHFqZ1RLZU5qeUNOaFhUb25LZUJQdjVCd1Q4OVVubSsyVitUOFRMUUJJa0I3UFl0RWhuaUNZUEg5YXU4aTltRmJyeFNLYUpydUdiWlZBSHRJS1M5Zm4wV2pEcWhsQXFkZVZwNEQyQmdkejNLTT0tLXgvb3FsbG15NlpRL1dSR1kvU3hnL0E9PQ%3D%3D--2d0784b96c3f4fc2f8b9d4169e9e39ba0d6fbf5c;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [9c011411-9cea-4021-9066-fe60eb857720]
      X-Runtime: ['0.049064']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
- request:
    body: '{"model": "User", "id": 200}'
    headers:
      Accept: ['*/*']
      Accept-Encoding: ['gzip, deflate']
      Connection: [keep-alive]
      Content-Length: ['28']
      Content-Type: [application/json]
      Cookie: [XSRF-TOKEN=FnznZis4%2FqM3BE%2FxdqCWGmlEWsOpa0GHdB1Bl%2FVHMGSNx%2FqwxnfZiMdQtGYQLIDsgGj2QKWiO7yYJvaFjgkD8g%3D%3D;
          _aquarium_NURSERY_production_session=OFZUMzJkYXpIQjczRUlNaTMrbUc1eW02YjcwTHMrd3JGZU5VTG5NeW1qMFdIV1hXbHBlSFZFWkhDSWdZNy9SYVZZNFIydUNyMWVpYkpBeVVXM202OWxCdnBJai9qTkU5TWx1bTRKaDUyZ3EwRTVqRlZqZEEvTzFaTFN3U2VYTGt3Q2xkUzUwbHJ1di9nK2NEdHJmODdhYXhYdEVsckhnVktsb3l5MzIrV2VhVkwydFQwSVY0ZC9sZ3NnUjc2MXpvTVNtWFVYVTlOektyTG9YRjlsRGFUeENlNW5idGhFTzd5czhaY1NuUTJUdHZoYzF1MjVKTGtSU2pOdHFkTENrdlNrbG5JTTR6Q1NxWXJ5NTJwUHpHL1B3NzMrZjJNWkcyb3JWNDA5NFhhN0dkSk9mM2ZlN1pEa2ZaMjUyQlJtbDAyRTUyZ0g4K0hQa1NaeERuUFpsWkdiYUJYMVp3Vzh3a0Rnek9CdEVYLytHSHpsSTVrdStENGpxSDJtZ3BIakx5NXl6WTBzSmF1Skc3NThxS2NLaU5JNTNhc1BpQS91c3IrTU9ZTEFWQ3Nkaz0tLTlPN3Uwbm12N0tGVlZsd1JSUEczUWc9PQ%3D%3D--f48ba8c65ab798caf2b08d61aa8533f63ae2200c;
          remember_token=SLLRrvtYchvNLhWHJR3FVg; remember_token_NURSERY_production=SLLRrvtYchvNLhWHJR3FVg]
      User-Agent: [python-requests/2.20.0]
    method: POST
    uri: http://52.27.43.242:81/json
  response:
    body: {string: '{"id":200,"name":"Pei-Rung Wu","login":"pei","created_at":"2017-10-18T13:00:07.000-07:00","updated_at":"2017-11-04T17:31:23.000-07:00","password_digest":"$2a$10$lfXxFmTGYh7byiySl7YGxuhX8p02gRUfBUMCKxoN00BENGIIUB4k.","remember_token":"OJL1LSYis4eBeBrR-Aq9WA","admin":false,"key":null,"groups":[{"id":225,"name":"pei","description":"A
        group containing only user Pei-Rung Wu","created_at":"2017-10-18T13:00:08.000-07:00","updated_at":"2017-10-18T13:00:08.000-07:00"},{"id":1,"name":"admin","description":"These
        users can use administrative functions (make users, etc)","created_at":"2013-11-15T13:37:36.000-08:00","updated_at":"2013-11-15T13:37:36.000-08:00"}]}'}
    headers:
      Cache-Control: ['max-age=0, private, must-revalidate']
      Connection: [keep-alive]
      Content-Type: [application/json; charset=utf-8]
      Date: ['Thu, 08 Nov 2018 07:24:57 GMT']
      ETag: [W/"bd51f1e05f8f5c821192a06e8e4c5901"]
      Server: [nginx/1.10.3 (Ubuntu)]
      Set-Cookie: [XSRF-TOKEN=EWxIRRYMYm9HPYFbUJB6wvFLLXO0Uw4IxXtyzOM46OuK11WT%2B0NFRLdpesw2HGw0GGeB8LiadDMpQMXemHbbfQ%3D%3D;
          path=/, _aquarium_NURSERY_production_session=ZmJzVUwrcTY3TE41enRXdzQ1RGgrTko0bVQvR092NDg5QlhiWWlPVEZOZzZVYTNkN3VCYXVGMzVWM2k0bVNobi8xNDVSNXlSZWs1cmtJcnBWWFRvRzFtNUlPZDFNUjFHTkZ6UUswRktBYi84QzRwcWlvNXpmUEloUUpoQ055T3pJbWRLR24vTWRjRUdDbUZZUFFkZW5VaGpTNVlFUy8xYlMyR3pRS1VaUVl3NXRXNml2TFBzZFFrUlVuREFLWDJvQThCalFEVXZXTUFZTWh6T3QrRld0S1pJcnJidE16MjI1RmRDL0doTFJlam9POEVFeHpwanFldFBtM1ROQXVhMDdZaThzNmh3T2FBYjJ6Z2V2OHRuVmVZQ1ZjdVZXemdJNmVtbUE1WCsrUEhPMnNYUlRpVVBoK0huRlNWdnVhcTlKQmk0Y01zRUtKdUowZUMvWGNiTFpGQmxsTjlpMjZwSW1ZazJTRGNaaTBtMy9ubVhMd2F4ZnZmdVVwWDlKNkJWUlZ4TmxMQ1VrdHpMRkZPNkNiU2wvQ0dpak9nUTR5a2FXMW9YdVBtQk1NQT0tLU5kQ1FFV3V6azFISlhGS1NlWmVVVUE9PQ%3D%3D--f22540844ea0234b92502fd964888b78f08fd6f1;
          path=/; HttpOnly]
      Vary: [Origin]
      X-Content-Type-Options: [nosniff]
      X-Frame-Options: [SAMEORIGIN]
      X-Request-Id: [a719675e-02a5-45ae-b0f1-06adc57b5b55]
      X-Runtime: ['0.018568']
      X-XSS-Protection: [1; mode=block]
    status: {code: 200, message: OK}
version: 1
